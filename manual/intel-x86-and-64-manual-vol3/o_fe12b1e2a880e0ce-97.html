<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 97</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:16px;font-family:Times;color:#0860a8;}
	.ft05{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page97-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce097.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:774px;white-space:nowrap" class="ft00">Vol. 3A&#160;3-9</p>
<p style="position:absolute;top:47px;left:589px;white-space:nowrap" class="ft01">PROTECTED-MODE MEMORY&#160;MANAGEMENT</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft02">2.&#160;Implied load&#160;instructions&#160;such&#160;as the far pointer&#160;versions&#160;of&#160;the&#160;CALL,&#160;JMP,&#160;and&#160;RET&#160;instructions,&#160;the&#160;SYSENTER&#160;</p>
<p style="position:absolute;top:117px;left:95px;white-space:nowrap" class="ft05">and SYSEXIT instructions,&#160;and&#160;the IRET, INT<i>n</i>,&#160;INTO&#160;and INT3&#160;instructions. These instructions change&#160;the&#160;<br/>contents of&#160;the&#160;CS register&#160;(and sometimes&#160;other segment registers)&#160;as an&#160;incidental part of their&#160;operation.</p>
<p style="position:absolute;top:157px;left:69px;white-space:nowrap" class="ft02">The MOV instruction can&#160;also be used&#160;to&#160;store the&#160;visible&#160;part of&#160;a segment&#160;register in&#160;a general-purpose register.</p>
<p style="position:absolute;top:208px;left:69px;white-space:nowrap" class="ft04">3.4.4&#160;</p>
<p style="position:absolute;top:208px;left:150px;white-space:nowrap" class="ft04">Segment Loading Instructions in IA-32e Mode</p>
<p style="position:absolute;top:238px;left:69px;white-space:nowrap" class="ft05">Because ES, DS,&#160;and SS&#160;segment&#160;registers are&#160;not used in 64-bit mode,&#160;their fields (base,&#160;limit,&#160;and attribute) in&#160;<br/>segment descriptor&#160;registers are&#160;ignored. Some forms of segment load instructions are&#160;also invalid (for&#160;example,&#160;<br/>LDS,&#160;POP ES). Address calculations&#160;that&#160;reference&#160;the ES,&#160;DS, or&#160;SS&#160;segments are treated as&#160;if the&#160;segment&#160;base&#160;<br/>is zero.&#160;<br/>The processor checks that&#160;all linear-address references are&#160;in canonical form instead of performing&#160;limit checks.&#160;<br/>Mode&#160;switching does&#160;not change&#160;the&#160;contents of the&#160;segment&#160;registers or&#160;the&#160;associated&#160;descriptor&#160;registers.&#160;<br/>These registers&#160;are&#160;also not changed during 64-bit&#160;mode&#160;execution,&#160;unless explicit segment loads are&#160;performed.<br/>In order&#160;to set&#160;up compatibility&#160;mode for an application,&#160;segment-load instructions&#160;(MOV to&#160;Sreg, POP Sreg)&#160;work&#160;<br/>normally in&#160;64-bit mode.&#160;An&#160;entry is&#160;read&#160;from&#160;the system&#160;descriptor table&#160;(GDT&#160;or LDT) and is&#160;loaded&#160;in the&#160;<br/>hidden&#160;portion of the&#160;segment register.&#160;The descriptor-register base,&#160;limit,&#160;and attribute fields are&#160;all&#160;loaded.&#160;<br/>However,&#160;the&#160;contents of the data&#160;and stack&#160;segment&#160;selector&#160;and the&#160;descriptor registers&#160;are ignored.<br/>When&#160;FS&#160;and&#160;GS&#160;segment overrides&#160;are&#160;used&#160;in&#160;64-bit&#160;mode, their respective&#160;base&#160;addresses&#160;are used&#160;in&#160;the&#160;linear&#160;<br/>address calculation: (FS&#160;or&#160;GS).base + index + displacement.&#160;FS.base and GS.base&#160;are then expanded to the full&#160;<br/>linear-address size&#160;supported by&#160;the implementation. The&#160;resulting effective&#160;address&#160;calculation can wrap&#160;across&#160;<br/>positive and&#160;negative addresses; the&#160;resulting linear&#160;address must be canonical.<br/>In 64-bit mode, memory accesses using&#160;FS-segment and&#160;GS-segment overrides&#160;are not checked&#160;for&#160;a runtime limit&#160;<br/>nor&#160;subjected&#160;to attribute-checking.&#160;Normal segment loads (MOV&#160;to&#160;Sreg&#160;and&#160;POP&#160;Sreg) into FS&#160;and GS load&#160;a&#160;<br/>standard 32-bit base value&#160;in&#160;the&#160;hidden portion of the&#160;segment register. The base address bits above&#160;the&#160;standard&#160;<br/>32&#160;bits&#160;are cleared&#160;to 0&#160;to allow consistency&#160;for&#160;implementations that&#160;use less than 64 bits.&#160;<br/>The&#160;hidden&#160;descriptor register fields for FS.base&#160;and&#160;GS.base are&#160;physically mapped&#160;to MSRs&#160;in order&#160;to load all&#160;<br/>address&#160;bits&#160;supported by a&#160;64-bit implementation. Software&#160;with&#160;CPL = 0 (privileged&#160;software) can&#160;load all&#160;<br/>supported&#160;linear-address bits into&#160;FS.base or&#160;GS.base&#160;using WRMSR. Addresses&#160;written&#160;into the&#160;64-bit FS.base&#160;<br/>and&#160;GS.base&#160;registers must be in&#160;canonical&#160;form. A WRMSR instruction that attempts to&#160;write a&#160;non-canonical&#160;<br/>address to&#160;those&#160;registers&#160;causes a&#160;#GP fault.&#160;<br/>When&#160;in compatibility mode, FS and GS overrides&#160;operate&#160;as defined by&#160;32-bit mode&#160;behavior regardless&#160;of&#160;the&#160;<br/>value&#160;loaded into the upper 32&#160;linear-address bits&#160;of the&#160;hidden descriptor&#160;register&#160;base field.&#160;Compatibility mode&#160;<br/>ignores&#160;the&#160;upper 32&#160;bits when calculating&#160;an effective address.<br/>A new 64-bit&#160;mode instruction,&#160;SWAPGS,&#160;can be used to&#160;load&#160;GS&#160;base. SWAPGS exchanges&#160;the&#160;kernel&#160;data struc-<br/>ture pointer from the&#160;IA32_KERNEL_GS_BASE&#160;MSR&#160;with the&#160;GS&#160;base&#160;register. The kernel&#160;can&#160;then&#160;use&#160;the GS&#160;<br/>prefix on normal memory references to&#160;access&#160;the kernel data structures. An&#160;attempt&#160;to write&#160;a non-canonical&#160;<br/>value&#160;(using&#160;WRMSR) to&#160;the&#160;IA32_KERNEL_GS_BASE MSR&#160;causes a&#160;#GP fault.</p>
<p style="position:absolute;top:836px;left:69px;white-space:nowrap" class="ft04">3.4.5 Segment&#160;</p>
<p style="position:absolute;top:836px;left:226px;white-space:nowrap" class="ft04">Descriptors</p>
<p style="position:absolute;top:867px;left:69px;white-space:nowrap" class="ft05">A segment descriptor&#160;is a&#160;data structure&#160;in a&#160;GDT or&#160;LDT&#160;that&#160;provides&#160;the processor with the&#160;size&#160;and&#160;location of&#160;<br/>a segment,&#160;as well&#160;as access control and&#160;status information.&#160;Segment&#160;descriptors are&#160;typically&#160;created by&#160;<br/>compilers, linkers,&#160;loaders, or the&#160;operating&#160;system&#160;or&#160;executive, but&#160;not&#160;application progra<a href="o_fe12b1e2a880e0ce-98.html">ms.&#160;Figure&#160;3-8&#160;illus-<br/></a>trates&#160;the general&#160;descriptor format for all&#160;types&#160;of segment descriptors.</p>
</div>
</body>
</html>
