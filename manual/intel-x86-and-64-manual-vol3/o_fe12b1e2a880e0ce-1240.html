<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1240</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:18px;font-family:Times;color:#000000;}
	.ft04{font-size:11px;font-family:Times;color:#000000;}
	.ft05{font-size:18px;font-family:Times;color:#0860a8;}
	.ft06{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:22px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1240-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce1240.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">33-2&#160;Vol. 3C</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">HANDLING&#160;BOUNDARY&#160;CONDITIONS&#160;IN A VIRTUAL MACHINE MONITOR</p>
<p style="position:absolute;top:100px;left:93px;white-space:nowrap" class="ft06">INIT&#160;and&#160;SIPI&#160;events are&#160;treated&#160;specially.&#160;INIT&#160;assertions are always blocked&#160;in VMX root operation&#160;and while&#160;<br/>in&#160;SMM,&#160;and unblocked&#160;otherwise. SIPI&#160;events&#160;are always blocked&#160;in VMX&#160;root operation.<br/>The&#160;interruptibility state&#160;is&#160;loaded from the&#160;VMCS guest-state&#160;area on&#160;every VM&#160;entry&#160;and&#160;saved into the VMCS&#160;<br/>on every VM&#160;exit.</p>
<p style="position:absolute;top:178px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:178px;left:93px;white-space:nowrap" class="ft06"><b>Event injection</b>. VMX operation allows injecting&#160;interruptions to&#160;a guest virtual machine through the&#160;use&#160;of&#160;<br/>VM-entry interrupt-information&#160;field&#160;in VMCS. Injectable&#160;interruptions&#160;include&#160;external interrupts,&#160;NMI,&#160;<br/>processor&#160;exceptions,&#160;software generated interrupts, and software&#160;traps. If the interrupt-information&#160;field&#160;<br/>indicates a&#160;valid interrupt,&#160;exception or trap event&#160;upon the next VM entry;&#160;the processor will use&#160;the&#160;<br/>information in the field to vector&#160;a&#160;virtual interruption through the guest IDT after all guest state and&#160;MSRs are&#160;<br/>loaded.&#160;Delivery through the&#160;guest&#160;IDT emulates vectoring in&#160;non-VMX&#160;operation&#160;by&#160;doing&#160;the normal privilege&#160;<br/>checks and&#160;pushing appropriate entries&#160;to the&#160;guest&#160;stack&#160;(entries&#160;may include&#160;RFLAGS, EIP&#160;and exception&#160;<br/>error&#160;code). A VMM&#160;with&#160;host&#160;control of NMI&#160;and&#160;external interrupts&#160;can use&#160;the event-injection facility&#160;to&#160;<br/>forward virtual interruptions&#160;to various guest virtual machines.</p>
<p style="position:absolute;top:332px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:333px;left:93px;white-space:nowrap" class="ft06"><b>Interrupt-window exiting</b>.&#160;When set&#160;to 1,&#160;the “interrupt-window exiting”&#160;VM-execution co<a href="o_fe12b1e2a880e0ce-1055.html">ntrol (Section&#160;<br/>24.6.2) causes</a>&#160;VM&#160;exits when&#160;guest RFLAGS.IF&#160;is&#160;1&#160;and no&#160;other conditions&#160;block external interrupts. A VM&#160;exit&#160;<br/>occurs at the beginning of any instruction at which RFLAGS.IF&#160;=&#160;1&#160;and on which the&#160;interruptibility state of the&#160;<br/>guest would allow delivery&#160;of&#160;an interrupt. For example:&#160;when&#160;the guest&#160;executes an STI&#160;instruction,&#160;<br/>RFLAGS&#160;=&#160;1, and&#160;if at the&#160;completion&#160;of&#160;next instruction&#160;the interruptibility state masking due to&#160;STI&#160;is&#160;<br/>removed; a&#160;VM&#160;exit&#160;occurs if the&#160;“interrupt-window exiting” VM-execution control&#160;is 1. This feature&#160;allows&#160;a&#160;<br/>VMM&#160;to&#160;queue&#160;a virtual interrupt&#160;to the guest when the guest is&#160;not&#160;in an interruptible&#160;state.&#160;The&#160;VMM can set&#160;<br/>the “interrupt-window exiting”&#160;VM-execution control for&#160;the guest&#160;and&#160;depend on&#160;a VM&#160;exit to know&#160;when&#160;the&#160;<br/>guest becomes interruptible&#160;(and,&#160;therefore, when&#160;it can&#160;inject&#160;a&#160;virtual interrupt). The VMM&#160;can&#160;detect such&#160;<br/>VM exits&#160;by checking&#160;for&#160;the&#160;basic exit&#160;reason “interrupt-window”&#160;(value&#160;= 7). If&#160;this feature&#160;is not used,&#160;the&#160;<br/>VMM will need to&#160;poll&#160;and check&#160;the interruptibility state of the&#160;guest&#160;to deliver virtual interrupts.&#160;</p>
<p style="position:absolute;top:520px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:520px;left:93px;white-space:nowrap" class="ft06"><b>NMI-window exiting</b>. If&#160;the “virtual NMIs”&#160;VM-execution is&#160;set,&#160;the&#160;processor tracks virtual-NMI blocking.&#160;<br/>The&#160;“NMI-window&#160;exiting” VM-execution<a href="o_fe12b1e2a880e0ce-1055.html">&#160;control (Section 24.6.2</a>) causes&#160;VM&#160;exits&#160;when there is no&#160;virtual-NMI&#160;<br/>blocking. For example,&#160;after execution&#160;of&#160;the IRET&#160;instruction, a&#160;VM&#160;exit occurs if the&#160;“NMI-window&#160;exiting”&#160;VM-<br/>execution control is 1. This feature allows a VMM to queue a virtual NMI to a guest when the guest is not ready&#160;<br/>to receive&#160;NMIs. The&#160;VMM can set&#160;the&#160;“NMI-window&#160;exiting” VM-execution control for the guest and depend on&#160;<br/>a VM&#160;exit to&#160;know&#160;when&#160;the guest becomes&#160;ready for NMIs&#160;(and, therefore,&#160;when&#160;it&#160;can inject&#160;a virtual NMI).&#160;<br/>The&#160;VMM can&#160;detect such VM&#160;exits by checking&#160;for&#160;the basic exit&#160;reason “NMI&#160;window” (value&#160;= 8). If this&#160;<br/>feature&#160;is not&#160;used, the&#160;VMM will need&#160;to&#160;poll and check the&#160;interruptibility state&#160;of the&#160;guest&#160;to deliver&#160;virtual&#160;<br/>NMIs.&#160;</p>
<p style="position:absolute;top:674px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:675px;left:93px;white-space:nowrap" class="ft06"><b>VM-exit&#160;information</b>.&#160;The VM-exit&#160;information fields&#160;provide&#160;details on VM&#160;exits due to&#160;exceptions and&#160;<br/>interrupts. This information&#160;is provided&#160;through&#160;the&#160;exit-qualification,&#160;VM-exit-interruption-information,&#160;<br/>instruction-length and&#160;interruption-error-code fields.&#160;Also,&#160;for VM exits&#160;that occur in&#160;the course&#160;of&#160;vectoring&#160;<br/>through the guest IDT,&#160;information about the event that was being vectored&#160;through the guest IDT is provided&#160;<br/>in the&#160;IDT-vectoring-information and&#160;IDT-vectoring-error-code&#160;fields.&#160;These&#160;information fields&#160;allow the&#160;VMM to&#160;<br/>identify&#160;the exception&#160;cause and to handle&#160;it&#160;properly.</p>
<p style="position:absolute;top:813px;left:68px;white-space:nowrap" class="ft05">33.3&#160;</p>
<p style="position:absolute;top:813px;left:147px;white-space:nowrap" class="ft05">EXTERNAL INTERRUPT&#160;VIRTUALIZATION</p>
<p style="position:absolute;top:849px;left:68px;white-space:nowrap" class="ft06">VMX&#160;operation&#160;allows both host and&#160;guest control of external&#160;interrupts.&#160;While guest control of external&#160;interrupts&#160;<br/>might be suitable for partitioned&#160;usages&#160;(different CPU cores/threads&#160;and I/O devices partitioned&#160;to&#160;independent&#160;<br/>virtual machines), most&#160;VMMs built&#160;upon&#160;VMX are&#160;expected&#160;to utilize&#160;host control of external interrupts. The rest of&#160;<br/>this&#160;section describes a&#160;general host-controlled&#160;interrupt&#160;virtualization&#160;architecture for standard PC&#160;platforms&#160;<br/>through&#160;the&#160;use&#160;of&#160;VMX&#160;supported&#160;features.<br/>With&#160;host control of external&#160;interrupts, the&#160;VMM (or&#160;the host&#160;OS in&#160;a hosted&#160;VMM model) manages&#160;the&#160;physical&#160;<br/>interrupt&#160;controllers in the platform and&#160;the interrupts generated through them. The&#160;VMM&#160;exposes&#160;software-<br/>emulated&#160;virtual&#160;interrupt&#160;controller devices (such as&#160;PIC and APIC)&#160;to each&#160;guest&#160;virtual&#160;machine&#160;instance.</p>
</div>
</body>
</html>
