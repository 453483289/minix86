<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1245</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:14px;font-family:Times;color:#0860a8;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:18px;font-family:Times;color:#000000;}
	.ft05{font-size:11px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1245-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce1245.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:769px;white-space:nowrap" class="ft00">Vol. 3C&#160;33-7</p>
<p style="position:absolute;top:47px;left:436px;white-space:nowrap" class="ft01">HANDLING&#160;BOUNDARY&#160;CONDITIONS&#160;IN A VIRTUAL MACHINE MONITOR</p>
<p style="position:absolute;top:99px;left:69px;white-space:nowrap" class="ft02">33.3.3.3 &#160;&#160;Processing of&#160;External&#160;Interrupts by&#160;VMM</p>
<p style="position:absolute;top:127px;left:69px;white-space:nowrap" class="ft07">Upon VM&#160;exit,&#160;the&#160;VMM&#160;can&#160;determine&#160;the exit&#160;cause of&#160;an&#160;external interrupt&#160;by checking&#160;the exit-reason field&#160;<br/>(value&#160;=&#160;1)&#160;in VMCS. If&#160;the acknowledge-interrupt<a href="o_fe12b1e2a880e0ce-1063.html">-on-exit control (see Section&#160;24.7.1) is</a>&#160;enabled,&#160;the&#160;VMM&#160;can&#160;<br/>use&#160;the saved host vector&#160;(in the&#160;exit-interruption-information field) to switch to the&#160;appropriate interrupt handler.&#160;<br/>If the&#160;“acknowledge&#160;interrupt&#160;on exit”&#160;VM-exit&#160;control is&#160;0, the&#160;VMM may&#160;re-enable&#160;interrupts&#160;(by setting&#160;<br/>RFLAGS.IF) to&#160;allow&#160;vectoring&#160;of&#160;external interrupts through the monitor/host&#160;IDT.&#160;<br/>The&#160;following steps&#160;may need&#160;to&#160;be&#160;performed&#160;by&#160;the VMM&#160;to process an&#160;external interrupt:</p>
<p style="position:absolute;top:239px;left:69px;white-space:nowrap" class="ft04">•</p>
<p style="position:absolute;top:240px;left:95px;white-space:nowrap" class="ft06"><b>Host&#160;Owned&#160;I/O Devices:</b>&#160;For host-owned&#160;I/O&#160;devices,&#160;the&#160;interrupting device&#160;is&#160;owned by the&#160;VMM (or&#160;<br/>hosting OS in a hosted VMM). In this&#160;model, the interrupt service&#160;routine in&#160;the&#160;VMM/host driver&#160;is invoked and,&#160;<br/>upon ISR&#160;completion,&#160;the appropriate&#160;write sequences&#160;(TPR updates, EOI etc.)&#160;to respective&#160;interrupt&#160;<br/>controllers&#160;are performed as&#160;normal. If&#160;the work&#160;completion&#160;indicated by&#160;the driver implies virtual device&#160;<br/>activity,&#160;the VMM&#160;runs&#160;the virtual device emulation.&#160;Depending on&#160;the device class,&#160;physical device activity&#160;<br/>could&#160;imply activity&#160;by multiple&#160;virtual devices mapped&#160;over&#160;the device. For&#160;each&#160;affected&#160;virtual device, the&#160;<br/>VMM injects a&#160;virtual&#160;external interrupt event to&#160;respective guest virtual machines.&#160;The&#160;guest&#160;driver interacts&#160;<br/>with the&#160;emulated&#160;virtual device to&#160;process the&#160;virtual&#160;interrupt. The interrupt&#160;controller&#160;emulation&#160;in the VMM&#160;<br/>supports various guest&#160;accesses to&#160;the&#160;VMM’s&#160;virtual&#160;interrupt&#160;controller.</p>
<p style="position:absolute;top:394px;left:69px;white-space:nowrap" class="ft04">•</p>
<p style="position:absolute;top:394px;left:95px;white-space:nowrap" class="ft06"><b>Guest Assigned I/O Devices:</b>&#160;For&#160;assigned&#160;I/O devices, either&#160;the VMM&#160;uses&#160;a software proxy or it&#160;can&#160;<br/>directly map&#160;the&#160;physical device&#160;to&#160;the&#160;assigned&#160;VM. In&#160;both cases,&#160;servicing of the&#160;interrupt&#160;condition on the&#160;<br/>physical&#160;device&#160;is initiated by&#160;the driver&#160;running&#160;inside&#160;the&#160;guest&#160;VM. With&#160;host&#160;control of external&#160;interrupts,&#160;<br/>interrupts&#160;from assigned&#160;physical devices cause VM exits to the&#160;VMM and vectoring through the host IDT to the&#160;<br/>registered VMM&#160;interrupt handler.&#160;To&#160;unblock delivery&#160;of other&#160;low priority&#160;platform&#160;interrupts,&#160;the VMM&#160;<br/>interrupt handler must&#160;mask the&#160;interrupt&#160;source (for&#160;level triggered&#160;interrupts)&#160;and&#160;issue the appropriate EOI&#160;<br/>write sequences.&#160;</p>
<p style="position:absolute;top:517px;left:69px;white-space:nowrap" class="ft06">Once&#160;the&#160;physical interrupt source is&#160;masked&#160;and the&#160;platform&#160;EOI&#160;generated, the&#160;VMM can map&#160;the host vector to&#160;<br/>its&#160;corresponding guest vector to&#160;inject&#160;the virtual interrupt&#160;into the&#160;assigned VM.&#160;The&#160;guest&#160;software does EOI&#160;<br/>write&#160;sequences to&#160;its virtual interrupt controller&#160;after completing&#160;interrupt processing. For level&#160;triggered&#160;inter-<br/>rupts,&#160;these&#160;EOI&#160;writes to&#160;the virtual interrupt controller may be trapped by the VMM which may&#160;in turn unmask&#160;<br/>the&#160;previously masked interrupt&#160;source.</p>
<p style="position:absolute;top:628px;left:69px;white-space:nowrap" class="ft02">33.3.3.4 &#160;&#160;Generation of&#160;Virtual Interrupt Events&#160;by&#160;VMM</p>
<p style="position:absolute;top:656px;left:69px;white-space:nowrap" class="ft07">The&#160;following provides some&#160;of the&#160;general steps that&#160;need&#160;to be&#160;taken by VMM&#160;designs&#160;when&#160;generating&#160;virtual&#160;<br/>interrupts:<br/>1.&#160;Check virtual&#160;processor&#160;interruptibility state. The&#160;virtual processor&#160;interruptibility state&#160;is reflected&#160;in&#160;the guest&#160;</p>
<p style="position:absolute;top:713px;left:95px;white-space:nowrap" class="ft06">RFLAGS.IF flag and the processor interruptibility-state saved in&#160;the&#160;guest state area&#160;of the controlling-VMCS.&#160;If&#160;<br/>RFLAGS.IF is&#160;set and&#160;the&#160;interruptibility state&#160;indicates readiness&#160;to&#160;take&#160;external&#160;interrupts (STI-masking and&#160;<br/>MOV-SS/POP-SS-masking bits are clear),&#160;the&#160;guest&#160;virtual processor is ready to&#160;take external&#160;interrupts. If&#160;the&#160;<br/>VMM&#160;design&#160;supports non-active&#160;guest sleep&#160;states, the&#160;VMM needs&#160;to make&#160;sure&#160;the&#160;current guest sleep&#160;state&#160;<br/>allows injection of external&#160;interrupt&#160;events.&#160;</p>
<p style="position:absolute;top:803px;left:69px;white-space:nowrap" class="ft03">2.&#160;If&#160;the guest virtual processor state is&#160;currently&#160;not&#160;interruptible,&#160;a VMM may utilize&#160;the “interrupt-window&#160;</p>
<p style="position:absolute;top:820px;left:94px;white-space:nowrap" class="ft06">exiting” VM-execution to&#160;notify the&#160;VMM (through a VM exit)&#160;when the virtual processor&#160;state changes to inter-<br/>ruptible state.&#160;</p>
<p style="position:absolute;top:860px;left:69px;white-space:nowrap" class="ft03">3.&#160;Check the virtual interrupt&#160;controller state.&#160;If the&#160;guest&#160;VM exposes a&#160;virtual&#160;local APIC, the&#160;current&#160;value&#160;of its&#160;</p>
<p style="position:absolute;top:877px;left:94px;white-space:nowrap" class="ft06">processor priority&#160;register&#160;specifies if&#160;guest&#160;software&#160;allows dispensing&#160;an external&#160;virtual&#160;interrupt with a&#160;<br/>specific priority&#160;to the&#160;virtual&#160;processor.&#160;If the&#160;virtual&#160;interrupt&#160;is routed through the&#160;local vector table (LVT)&#160;<br/>entry of the local&#160;APIC, the&#160;mask bits in&#160;the corresponding&#160;LVT entry specifies&#160;if&#160;the interrupt is&#160;currently&#160;<br/>masked.&#160;Similarly,&#160;the virtual interrupt controller’s current&#160;mask (IO-APIC&#160;or PIC) and priority&#160;settings&#160;reflect&#160;<br/>guest&#160;state to&#160;accept specific external&#160;interrupts.&#160;The&#160;VMM needs to&#160;check both&#160;the virtual processor and&#160;<br/>interrupt controller&#160;states&#160;to verify&#160;its guest interruptibility state. If&#160;the&#160;guest is&#160;currently&#160;interruptible,&#160;the&#160;<br/>VMM can&#160;inject&#160;the virtual interrupt.&#160;If&#160;the current&#160;guest state&#160;does&#160;not allow injecting&#160;a virtual interrupt, the&#160;<br/>interrupt&#160;needs to be&#160;queued&#160;by the&#160;VMM&#160;until it&#160;can be&#160;delivered.</p>
<p style="position:absolute;top:1016px;left:69px;white-space:nowrap" class="ft03">4.&#160;Prioritize&#160;the&#160;use&#160;of VM-entry event injection.&#160;A&#160;VMM&#160;may&#160;use VM-entry event injection to&#160;deliver various&#160;</p>
<p style="position:absolute;top:1033px;left:94px;white-space:nowrap" class="ft06">virtual events (such as external interrupts, exceptions, traps, and so&#160;forth). VMM designs may prioritize&#160;use&#160;of&#160;<br/>virtual-interrupt injection between these event&#160;types.&#160;Since&#160;each&#160;VM&#160;entry allows injection of one&#160;event,&#160;</p>
</div>
</body>
</html>
