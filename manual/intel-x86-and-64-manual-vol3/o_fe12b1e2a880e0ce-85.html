<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 85</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:16px;font-family:Times;color:#0860a8;}
	.ft04{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft05{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page85-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce085.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:767px;white-space:nowrap" class="ft00">Vol. 3A&#160;2-23</p>
<p style="position:absolute;top:47px;left:634px;white-space:nowrap" class="ft01">SYSTEM ARCHITECTURE OVERVIEW</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft04">The LAR&#160;(load access rights)&#160;instruction verifies the&#160;accessibility of a&#160;specified segment and&#160;loads&#160;access&#160;rights&#160;<br/>information from the&#160;segment’s segment descriptor&#160;into&#160;a general-purpose register.&#160;Software&#160;can then&#160;examine&#160;<br/>the access rights&#160;to determine&#160;if&#160;the segment type is&#160;compatible&#160;with&#160;its intended use.&#160;<a href="o_fe12b1e2a880e0ce-176.html">See Section 5.10.1,&#160;<br/>“Checking Access Rights (LAR&#160;Instruction)”&#160;</a>for&#160;a detailed&#160;explanation of&#160;the function&#160;and use&#160;of this instruction.<br/>The LSL&#160;(load&#160;segment&#160;limit) instruction verifies the&#160;accessibility of a&#160;specified segment&#160;and loads the&#160;segment&#160;<br/>limit from the&#160;segment’s segment descriptor&#160;into&#160;a general-purpose&#160;register. Software&#160;can then&#160;compare&#160;the&#160;<br/>segment limit&#160;with&#160;an offset into&#160;the segment to&#160;determine whether the&#160;offset lies within&#160;the&#160;segment. See<a href="o_fe12b1e2a880e0ce-177.html">&#160;Section&#160;<br/>5.10.3,&#160;“Checking That the Pointer&#160;Offset Is&#160;Within&#160;Limits&#160;(LSL&#160;Instruction)” for a det</a>ailed explanation of&#160;the func-<br/>tion and&#160;use of this&#160;instruction.<br/>The VERR&#160;(verify for reading) and VERW&#160;(verify for writing)&#160;instructions verify if a selected segment&#160;is readable or&#160;<br/>writable, respectively, at&#160;a given&#160;CPL.&#160;Se<a href="o_fe12b1e2a880e0ce-177.html">e Section 5.10.2,&#160;“Checking Read/Write&#160;Rights&#160;(VERR&#160;and VERW&#160;Instruc-<br/>tions)”&#160;</a>for&#160;a detailed explanation&#160;of&#160;the function and&#160;use of these instructions.</p>
<p style="position:absolute;top:347px;left:69px;white-space:nowrap" class="ft03">2.8.3&#160;</p>
<p style="position:absolute;top:347px;left:150px;white-space:nowrap" class="ft03">Loading and Storing Debug Registers</p>
<p style="position:absolute;top:378px;left:69px;white-space:nowrap" class="ft04">Internal debugging facilities in the&#160;processor are&#160;controlled&#160;by&#160;a set&#160;of 8&#160;debug registers&#160;(DR0-DR7).&#160;The MOV&#160;<br/>instruction allows setup data to&#160;be&#160;loaded&#160;to&#160;and&#160;stored&#160;from&#160;these&#160;registers.<br/>On&#160;processors&#160;that support Intel&#160;64&#160;architecture, debug&#160;registers DR0-DR7 are&#160;64&#160;bits.&#160;In&#160;32-bit modes&#160;and&#160;<br/>compatibility&#160;mode, writes to&#160;a debug&#160;register&#160;fill the&#160;upper&#160;32&#160;bits&#160;with&#160;zeros. Reads return the&#160;lower 32 bits.&#160;In&#160;<br/>64-bit mode,&#160;the upper 32&#160;bits&#160;of DR6-DR7&#160;are reserved&#160;and&#160;must be written with&#160;zeros. Writing one to any of&#160;the&#160;<br/>upper 32 bits causes an exception, #GP(0).<br/>In 64-bit&#160;mode,&#160;MOV&#160;DRn&#160;instructions&#160;read&#160;or write all 64&#160;bits&#160;of a&#160;debug register (operand-size&#160;prefixes&#160;are&#160;<br/>ignored). All 64&#160;bits of DR0-DR3&#160;are writable&#160;by software. However,&#160;MOV&#160;DRn instructions do&#160;not check that&#160;<br/>addresses written&#160;to DR0-DR3 are in&#160;the&#160;limits of the&#160;implementation. Address matching is supported&#160;only on&#160;valid&#160;<br/>addresses generated by the&#160;processor&#160;implementation.</p>
<p style="position:absolute;top:592px;left:69px;white-space:nowrap" class="ft03">2.8.4&#160;</p>
<p style="position:absolute;top:592px;left:149px;white-space:nowrap" class="ft03">Invalidating Caches and TLBs</p>
<p style="position:absolute;top:622px;left:69px;white-space:nowrap" class="ft04">The&#160;processor&#160;provides&#160;several instructions for use&#160;in explicitly invalidating its&#160;caches and TLB entries. The INVD&#160;<br/>(invalidate&#160;cache with no writeback)&#160;instruction&#160;invalidates&#160;all&#160;data and instruction entries in the&#160;internal caches&#160;<br/>and sends a&#160;signal&#160;to the&#160;external caches&#160;indicating&#160;that they should&#160;also be invalidated.<br/>The&#160;WBINVD (invalidate cache&#160;with&#160;writeback) instruction&#160;performs the&#160;same function as&#160;the INVD&#160;instruction,&#160;<br/>except that&#160;it writes&#160;back modified lines&#160;in its&#160;internal&#160;caches to&#160;memory before it&#160;invalidates the&#160;caches. After&#160;<br/>invalidating the&#160;caches local to the executing logical processor or processor core, WBINVD signals caches higher in&#160;<br/>the cache&#160;hierarchy&#160;(caches shared with the&#160;invalidating&#160;logical processor or&#160;core) to&#160;write&#160;back any&#160;data they&#160;have&#160;<br/>in modified&#160;state&#160;at the&#160;time of&#160;instruction&#160;execution and&#160;to invalidate their contents.&#160;<br/>Note, non-shared caches&#160;may not be written back&#160;nor&#160;invalidated<a href="o_fe12b1e2a880e0ce-86.html">. In&#160;Figure 2-10&#160;</a>below,&#160;if code executing&#160;on either&#160;<br/>LP0&#160;or LP1 were&#160;to execute a WBINVD,&#160;the shared L1&#160;and L2&#160;for LP0/LP1&#160;will be&#160;written back and invalidated&#160;as will&#160;<br/>the shared L3. However,&#160;the L1 and&#160;L2&#160;caches&#160;not shared with LP0&#160;and LP1 will not be written back&#160;nor&#160;invalidated.</p>
</div>
</body>
</html>
