<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 204</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:16px;font-family:Times;color:#0860a8;}
	.ft04{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft05{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page204-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce204.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">6-18&#160;Vol. 3A</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">INTERRUPT&#160;AND EXCEPTION&#160;HANDLING</p>
<p style="position:absolute;top:100px;left:68px;white-space:nowrap" class="ft04">the interrupt&#160;handler&#160;to use&#160;faster 16-byte aligned&#160;loads and&#160;stores (MOVAPS rather than&#160;MOVUPS)&#160;to save&#160;and&#160;<br/>restore XMM&#160;registers.&#160;<br/>Although the RSP alignment&#160;is always performed when&#160;LMA =&#160;1,&#160;it is&#160;only of consequence&#160;for the kernel-mode case&#160;<br/>where&#160;there&#160;is&#160;no&#160;stack switch or IST&#160;used. For&#160;a stack&#160;switch&#160;or IST,&#160;the&#160;OS&#160;would&#160;have&#160;presumably put suitably&#160;<br/>aligned&#160;RSP values in&#160;the TSS.</p>
<p style="position:absolute;top:224px;left:68px;white-space:nowrap" class="ft03">6.14.3&#160;</p>
<p style="position:absolute;top:224px;left:148px;white-space:nowrap" class="ft03">IRET in IA-32e Mode&#160;</p>
<p style="position:absolute;top:255px;left:68px;white-space:nowrap" class="ft04">In&#160;IA-32e&#160;mode,&#160;IRET&#160;executes&#160;with an&#160;8-byte&#160;operand&#160;size. There is&#160;nothing that forces&#160;this requirement.&#160;The&#160;<br/>stack is&#160;formatted in such&#160;a way that for&#160;actions&#160;where&#160;IRET is&#160;required,&#160;the 8-byte IRET&#160;operand size&#160;works&#160;<br/>correctly.&#160;<br/>Because interrupt&#160;stack-frame&#160;pushes&#160;are always eight bytes in&#160;IA-32e&#160;mode,&#160;an IRET&#160;must pop&#160;eight byte&#160;items&#160;<br/>off&#160;the stack. This&#160;is accomplished by&#160;preceding the&#160;IRET&#160;with a&#160;64-bit operand-size&#160;prefix. The size&#160;of&#160;the pop is&#160;<br/>determined&#160;by the&#160;address size of the instruction.&#160;The&#160;SS/ESP/RSP size&#160;adjustment&#160;is&#160;determined by the stack&#160;size.<br/>IRET pops SS:RSP&#160;unconditionally off the interrupt stack frame only when it is&#160;executed&#160;in 64-bit mode.&#160;In&#160;compat-<br/>ibility mode,&#160;IRET pops SS:RSP&#160;off&#160;the stack&#160;only if&#160;there is&#160;a&#160;CPL change.&#160;This allows legacy applications to&#160;<br/>execute properly in&#160;compatibility mode when&#160;using the IRET&#160;instruction. 64-bit interrupt service routines that exit&#160;<br/>with&#160;an IRET&#160;unconditionally pop SS:RSP off of the&#160;interrupt&#160;stack frame,&#160;even&#160;if&#160;the target code segment is&#160;<br/>running&#160;in 64-bit&#160;mode or&#160;at CPL = 0. This&#160;is because the&#160;original interrupt always pushes SS:RSP.<br/>In IA-32e mode, IRET is allowed to load&#160;a&#160;NULL&#160;SS&#160;under certain&#160;conditions.&#160;If the target mode&#160;is 64-bit&#160;mode&#160;and&#160;<br/>the target&#160;CPL&#160;≠&#160;3,&#160;IRET&#160;allows&#160;SS&#160;to&#160;be&#160;loaded&#160;with&#160;a&#160;NULL&#160;selector. As part of the&#160;stack switch mechanism,&#160;an&#160;<br/>interrupt or exception&#160;sets&#160;the new SS&#160;to&#160;NULL, instead&#160;of&#160;fetching a new SS&#160;selector&#160;from&#160;the&#160;TSS and loading the&#160;<br/>corresponding&#160;descriptor from the&#160;GDT&#160;or&#160;LDT.&#160;The&#160;new SS&#160;selector is&#160;set to&#160;NULL&#160;in order to properly handle&#160;<br/>returns from&#160;subsequent nested&#160;far transfers. If&#160;the called&#160;procedure itself is&#160;interrupted,&#160;the NULL&#160;SS&#160;is pushed&#160;on&#160;<br/>the&#160;stack frame. On&#160;the&#160;subsequent IRET, the&#160;NULL&#160;SS&#160;on&#160;the&#160;stack&#160;acts as&#160;a&#160;flag to tell the&#160;processor&#160;not to load&#160;<br/>a new SS&#160;descriptor.</p>
<p style="position:absolute;top:608px;left:68px;white-space:nowrap" class="ft03">6.14.4&#160;</p>
<p style="position:absolute;top:608px;left:148px;white-space:nowrap" class="ft03">Stack Switching in IA-32e Mode&#160;</p>
<p style="position:absolute;top:639px;left:68px;white-space:nowrap" class="ft04">The IA-32&#160;architecture provides a mechanism to automatically switch stack&#160;frames&#160;in&#160;response to an interrupt.&#160;The&#160;<br/>64-bit extensions&#160;of&#160;Intel&#160;64&#160;architecture&#160;implement a modified&#160;version of the&#160;legacy&#160;stack-switching mechanism&#160;<br/>and&#160;an alternative&#160;stack-switching mechanism&#160;called&#160;the interrupt&#160;stack table (IST).<br/>In IA-32&#160;modes, the&#160;legacy&#160;IA-32&#160;stack-switch mechanism&#160;is&#160;unchanged. In IA-32e&#160;mode,&#160;the legacy stack-switch&#160;<br/>mechanism&#160;is modified.&#160;When stacks&#160;are switched as part&#160;of a&#160;64-bit mode&#160;privilege-level change&#160;(resulting&#160;from&#160;<br/>an interrupt), a new SS&#160;descriptor is not loaded. IA-32e&#160;mode loads only&#160;an&#160;inner-level&#160;RSP&#160;from&#160;the&#160;TSS.&#160;The&#160;new&#160;<br/>SS&#160;selector is&#160;forced to&#160;NULL&#160;and the SS&#160;selector’s&#160;RPL&#160;field&#160;is set&#160;to the&#160;new&#160;CPL. The new SS&#160;is set to&#160;NULL&#160;in&#160;<br/>order&#160;to handle&#160;nested far transfers&#160;(far CALL, INT,&#160;interrupts&#160;and&#160;exceptions).&#160;The old&#160;SS&#160;and RSP&#160;are saved&#160;on&#160;<br/>the&#160;new&#160;stack<a href="o_fe12b1e2a880e0ce-205.html">&#160;(Figure&#160;6-8). On</a>&#160;the&#160;subsequent IRET,&#160;the&#160;old&#160;SS&#160;is&#160;popped&#160;from&#160;the stack&#160;and&#160;loaded&#160;into&#160;the SS&#160;<br/>register.<br/>In&#160;summary, a&#160;stack switch in IA-32e mode works like the legacy&#160;stack&#160;switch, except that&#160;a new&#160;SS&#160;selector is&#160;not&#160;<br/>loaded&#160;from the&#160;TSS.&#160;Instead,&#160;the&#160;new SS&#160;is forced&#160;to NULL.</p>
</div>
</body>
</html>
