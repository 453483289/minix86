<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1697</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:12px;font-family:Times;color:#0860a8;}
	.ft04{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft05{font-size:11px;line-height:22px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1697-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce1697.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:761px;white-space:nowrap" class="ft00">Vol. 3C&#160;36-13</p>
<p style="position:absolute;top:47px;left:685px;white-space:nowrap" class="ft01">INTELÂ®&#160;PROCESSOR TRACE</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft04">Intel PT is not frozen on PMI, and thus the interrupt&#160;handler will be&#160;traced&#160;(though filtering&#160;can&#160;prevent this).&#160;The&#160;<br/>Freeze_Perfmon_on_PMI and&#160;Freeze_LBRs_on_PMI&#160;settings&#160;in&#160;IA32_DEBUGCTL will be applied on&#160;ToPA&#160;PMI just as&#160;<br/>on other PMIs, and&#160;hence Perfmon counters&#160;are frozen.<br/>Assuming the&#160;PMI&#160;handler&#160;wishes to&#160;read&#160;any buffered packets&#160;for&#160;persistent output, or&#160;wishes&#160;to modify any&#160;Intel&#160;<br/>PT MSRs, software&#160;should first&#160;disable packet&#160;generation&#160;by&#160;clearing TraceEn.&#160;This&#160;ensures that&#160;all buffered packets&#160;<br/>are&#160;written&#160;to memory&#160;and avoids tracing of&#160;the PMI handler.&#160;The&#160;configuration MSRs&#160;can then be used to&#160;deter-<br/>mine&#160;where tracing has&#160;stopped.&#160;If packet&#160;generation&#160;is&#160;disabled&#160;by the&#160;handler,&#160;it&#160;should then be manually re-<br/>enabled before the&#160;IRET if&#160;continued tracing is&#160;desired.<br/>In rare cases, it may be possible to trigger a second&#160;ToPA&#160;PMI before the first is&#160;handled. This can happen if&#160;another&#160;<br/>ToPA&#160;region with INT=1&#160;is filled before,&#160;or shortly after,&#160;the&#160;first PMI is&#160;taken, perhaps due to&#160;EFLAGS.IF&#160;being&#160;<br/>cleared&#160;for an&#160;extended&#160;period of time.&#160;This can manifest&#160;in&#160;two ways: either the&#160;second&#160;PMI&#160;is triggered before the&#160;<br/>first&#160;is taken, and hence&#160;only&#160;one PMI is&#160;taken, or&#160;the second is&#160;triggered&#160;after the first is&#160;taken, and&#160;thus&#160;will&#160;be&#160;<br/>taken when the handler for the first completes. Software can&#160;minimize the&#160;likelihood of the second case by clearing&#160;<br/>TraceEn&#160;at the beginning&#160;of the PMI handler.&#160;Further,&#160;it&#160;can&#160;detect such cases by then&#160;checking&#160;the&#160;Interrupt&#160;<br/>Request&#160;Register (IRR) for PMI pending,&#160;and&#160;checking the&#160;ToPA&#160;table&#160;base&#160;and&#160;off-set pointers (in&#160;<br/>IA32_RTIT_OUTPUT_BASE and&#160;IA32_RTIT_OUTPUT_MASK_PTRS)&#160;to see if multiple entries with INT=1 have been&#160;<br/>filled.</p>
<p style="position:absolute;top:410px;left:69px;white-space:nowrap" class="ft03">ToPA&#160;PMI and Single&#160;Output&#160;Region&#160;ToPA&#160;Implementation</p>
<p style="position:absolute;top:435px;left:69px;white-space:nowrap" class="ft04">A processor that&#160;supports only a&#160;single&#160;ToPA&#160;output region implementation (such that&#160;only one&#160;output region is&#160;<br/>supported; see above)&#160;will&#160;attempt&#160;to signal&#160;a ToPA&#160;PMI interrupt before the&#160;output wraps and&#160;overwrites the top&#160;<br/>of the&#160;buffer.&#160;To&#160;support this functionality,&#160;the PMI handler&#160;should disable&#160;packet&#160;generation as&#160;soon as possible.<br/>Due&#160;to PMI skid, it&#160;is possible&#160;that,&#160;in rare&#160;cases,&#160;the&#160;wrap will have occurred&#160;before&#160;the PMI&#160;is delivered.&#160;Software&#160;<br/>can avoid this by setting the&#160;STOP bit in the&#160;ToPA&#160;entry (see<a href="o_fe12b1e2a880e0ce-1695.html">&#160;Table&#160;36-3</a>); this will&#160;disable&#160;tracing once the&#160;region is&#160;<br/>filled,&#160;and no&#160;wrap will occur.&#160;This approach has&#160;the downside of&#160;disabling&#160;packet generation&#160;so that some&#160;of the&#160;<br/>instructions that&#160;led up&#160;to the PMI will not&#160;be traced. If the PMI skid is&#160;significant enough&#160;to cause the&#160;region&#160;to fill&#160;<br/>and&#160;tracing&#160;to be disabled,&#160;the PMI&#160;handler will need&#160;to&#160;clear the&#160;IA32_RTIT_STATUS.Stopped&#160;indication before&#160;<br/>tracing can&#160;resume.</p>
<p style="position:absolute;top:606px;left:69px;white-space:nowrap" class="ft03">ToPA&#160;PMI&#160;and&#160;XSAVES/XRSTORS&#160;State&#160;Handling</p>
<p style="position:absolute;top:631px;left:69px;white-space:nowrap" class="ft04">In some cases&#160;the ToPA&#160;PMI may be&#160;taken after completion&#160;of&#160;an&#160;XSAVES instruction that switches&#160;Intel PT state,&#160;<br/>and&#160;in&#160;such cases any&#160;modification of Intel PT MSRs&#160;within&#160;the&#160;PMI&#160;handler will&#160;not&#160;persist when the&#160;saved Intel&#160;PT&#160;<br/>context&#160;is later restored&#160;with XRSTORS.&#160;To&#160;account for such a scenario,&#160;it is&#160;recommended that&#160;the&#160;Intel&#160;PT output&#160;<br/>configuration be&#160;modified&#160;by altering&#160;the&#160;ToPA&#160;tables&#160;themselves, rather&#160;than the&#160;Intel PT output&#160;MSRs.&#160;<br/><a href="o_fe12b1e2a880e0ce-1698.html">Table&#160;36-4 de</a>picts&#160;a recommended&#160;PMI&#160;handler algorithm&#160;for managing&#160;multi-region&#160;ToPA&#160;output&#160;and handling&#160;<br/>ToPA&#160;PMIs that&#160;may arrive&#160;between&#160;XSAVES and&#160;XRSTORS.&#160;This algorithm&#160;is flexible&#160;to&#160;allow software&#160;to choose&#160;<br/>between&#160;adding entries&#160;to the current ToPA&#160;table,&#160;adding&#160;a&#160;new&#160;ToPA&#160;table, or&#160;using the&#160;current ToPA&#160;table as&#160;a&#160;<br/>circular buffer.&#160;It assumes&#160;that the&#160;ToPA&#160;entry&#160;that triggers the PMI is&#160;not&#160;the&#160;last entry in&#160;the table,&#160;which&#160;is the&#160;<br/>recommended&#160;treatment.</p>
</div>
</body>
</html>
