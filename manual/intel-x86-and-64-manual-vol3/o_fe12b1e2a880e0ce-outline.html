<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Document Outline</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="o_fe12b1e2a880e0ce-53.html">Chapter 1 About This Manual</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-53.html">1.1 Intel® 64 and IA-32 Processors Covered in this Manual</a></li>
<li><a href="o_fe12b1e2a880e0ce-55.html">1.2 Overview of The SYSTEM PROGRAMMING GUIDE</a></li>
<li><a href="o_fe12b1e2a880e0ce-58.html">1.3 Notational Conventions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-58.html">1.3.1 Bit and Byte Order</a></li>
<li><a href="o_fe12b1e2a880e0ce-58.html">1.3.2 Reserved Bits and Software Compatibility</a></li>
<li><a href="o_fe12b1e2a880e0ce-59.html">1.3.3 Instruction Operands</a></li>
<li><a href="o_fe12b1e2a880e0ce-59.html">1.3.4 Hexadecimal and Binary Numbers</a></li>
<li><a href="o_fe12b1e2a880e0ce-59.html">1.3.5 Segmented Addressing</a></li>
<li><a href="o_fe12b1e2a880e0ce-60.html">1.3.6 Syntax for CPUID, CR, and MSR Values</a></li>
<li><a href="o_fe12b1e2a880e0ce-61.html">1.3.7 Exceptions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-61.html">1.4 Related Literature</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-63.html">Chapter 2 System Architecture Overview</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-63.html">2.1 Overview of the System-Level Architecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-65.html">2.1.1 Global and Local Descriptor Tables</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-66.html">2.1.1.1 Global and Local Descriptor Tables in IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-66.html">2.1.2 System Segments, Segment Descriptors, and Gates</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-66.html">2.1.2.1 Gates in IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-67.html">2.1.3 Task-State Segments and Task Gates</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-67.html">2.1.3.1 Task-State Segments in IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-67.html">2.1.4 Interrupt and Exception Handling</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-67.html">2.1.4.1 Interrupt and Exception Handling IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-68.html">2.1.5 Memory Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-68.html">2.1.5.1 Memory Management in IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-68.html">2.1.6 System Registers</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-69.html">2.1.6.1 System Registers in IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-69.html">2.1.7 Other System Resources</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-69.html">2.2 Modes of Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-71.html">2.2.1 Extended Feature Enable Register</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-71.html">2.3 System Flags and Fields in the EFLAGS Register</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-73.html">2.3.1 System Flags and Fields in IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-73.html">2.4 Memory-Management Registers</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-74.html">2.4.1 Global Descriptor Table Register (GDTR)</a></li>
<li><a href="o_fe12b1e2a880e0ce-74.html">2.4.2 Local Descriptor Table Register (LDTR)</a></li>
<li><a href="o_fe12b1e2a880e0ce-74.html">2.4.3 IDTR Interrupt Descriptor Table Register</a></li>
<li><a href="o_fe12b1e2a880e0ce-75.html">2.4.4 Task Register (TR)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-75.html">2.5 Control Registers</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-81.html">2.5.1 CPUID Qualification of Control Register Flags</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-81.html">2.6 Extended Control Registers (Including XCR0)</a></li>
<li><a href="o_fe12b1e2a880e0ce-82.html">2.7 Protection Key Rights Register (PKRU)</a></li>
<li><a href="o_fe12b1e2a880e0ce-82.html">2.8 System Instruction Summary</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-84.html">2.8.1 Loading and Storing System Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-84.html">2.8.2 Verifying of Access Privileges</a></li>
<li><a href="o_fe12b1e2a880e0ce-85.html">2.8.3 Loading and Storing Debug Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-85.html">2.8.4 Invalidating Caches and TLBs</a></li>
<li><a href="o_fe12b1e2a880e0ce-86.html">2.8.5 Controlling the Processor</a></li>
<li><a href="o_fe12b1e2a880e0ce-86.html">2.8.6 Reading Performance-Monitoring and Time-Stamp Counters</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-87.html">2.8.6.1 Reading Counters in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-87.html">2.8.7 Reading and Writing Model-Specific Registers</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-87.html">2.8.7.1 Reading and Writing Model-Specific Registers in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-87.html">2.8.8 Enabling Processor Extended States</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-89.html">Chapter 3 Protected-Mode Memory Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-89.html">3.1 Memory Management Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-90.html">3.2 Using Segments</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-91.html">3.2.1 Basic Flat Model</a></li>
<li><a href="o_fe12b1e2a880e0ce-91.html">3.2.2 Protected Flat Model</a></li>
<li><a href="o_fe12b1e2a880e0ce-92.html">3.2.3 Multi-Segment Model</a></li>
<li><a href="o_fe12b1e2a880e0ce-93.html">3.2.4 Segmentation in IA-32e Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-93.html">3.2.5 Paging and Segmentation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-94.html">3.3 Physical Address Space</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-94.html">3.3.1 Intel® 64 Processors and Physical Address Space</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-94.html">3.4 Logical and Linear Addresses</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-95.html">3.4.1 Logical Address Translation in IA-32e Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-95.html">3.4.2 Segment Selectors</a></li>
<li><a href="o_fe12b1e2a880e0ce-96.html">3.4.3 Segment Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-97.html">3.4.4 Segment Loading Instructions in IA-32e Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-97.html">3.4.5 Segment Descriptors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-100.html">3.4.5.1 Code- and Data-Segment Descriptor Types</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-101.html">3.5 System Descriptor Types</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-102.html">3.5.1 Segment Descriptor Tables</a></li>
<li><a href="o_fe12b1e2a880e0ce-104.html">3.5.2 Segment Descriptor Tables in IA-32e Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-105.html">Chapter 4 Paging</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-105.html">4.1 Paging Modes and Control Bits</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-105.html">4.1.1 Three Paging Modes</a></li>
<li><a href="o_fe12b1e2a880e0ce-107.html">4.1.2 Paging-Mode Enabling</a></li>
<li><a href="o_fe12b1e2a880e0ce-108.html">4.1.3 Paging-Mode Modifiers</a></li>
<li><a href="o_fe12b1e2a880e0ce-109.html">4.1.4 Enumeration of Paging Features by CPUID</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-110.html">4.2 Hierarchical Paging Structures: an Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-111.html">4.3 32-Bit Paging</a></li>
<li><a href="o_fe12b1e2a880e0ce-117.html">4.4 PAE Paging</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-117.html">4.4.1 PDPTE Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-118.html">4.4.2 Linear-Address Translation with PAE Paging</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-123.html">4.5 IA-32e Paging</a></li>
<li><a href="o_fe12b1e2a880e0ce-132.html">4.6 Access Rights</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-133.html">4.6.1 Determination of Access Rights</a></li>
<li><a href="o_fe12b1e2a880e0ce-135.html">4.6.2 Protection Keys</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-135.html">4.7 Page-Fault Exceptions</a></li>
<li><a href="o_fe12b1e2a880e0ce-137.html">4.8 Accessed and Dirty Flags</a></li>
<li><a href="o_fe12b1e2a880e0ce-138.html">4.9 Paging and Memory Typing</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-138.html">4.9.1 Paging and Memory Typing When the PAT is Not Supported (Pentium Pro and Pentium II Processors)</a></li>
<li><a href="o_fe12b1e2a880e0ce-138.html">4.9.2 Paging and Memory Typing When the PAT is Supported (Pentium III and More Recent Processor Families)</a></li>
<li><a href="o_fe12b1e2a880e0ce-139.html">4.9.3 Caching Paging-Related Information about Memory Typing</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-139.html">4.10 Caching Translation Information</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-139.html">4.10.1 Process-Context Identifiers (PCIDs)</a></li>
<li><a href="o_fe12b1e2a880e0ce-140.html">4.10.2 Translation Lookaside Buffers (TLBs)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-140.html">4.10.2.1 Page Numbers, Page Frames, and Page Offsets</a></li>
<li><a href="o_fe12b1e2a880e0ce-140.html">4.10.2.2 Caching Translations in TLBs</a></li>
<li><a href="o_fe12b1e2a880e0ce-141.html">4.10.2.3 Details of TLB Use</a></li>
<li><a href="o_fe12b1e2a880e0ce-141.html">4.10.2.4 Global Pages</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-142.html">4.10.3 Paging-Structure Caches</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-142.html">4.10.3.1 Caches for Paging Structures</a></li>
<li><a href="o_fe12b1e2a880e0ce-144.html">4.10.3.2 Using the Paging-Structure Caches to Translate Linear Addresses</a></li>
<li><a href="o_fe12b1e2a880e0ce-144.html">4.10.3.3 Multiple Cached Entries for a Single Paging-Structure Entry</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-145.html">4.10.4 Invalidation of TLBs and Paging-Structure Caches</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-145.html">4.10.4.1 Operations that Invalidate TLBs and Paging-Structure Caches</a></li>
<li><a href="o_fe12b1e2a880e0ce-147.html">4.10.4.2 Recommended Invalidation</a></li>
<li><a href="o_fe12b1e2a880e0ce-148.html">4.10.4.3 Optional Invalidation</a></li>
<li><a href="o_fe12b1e2a880e0ce-148.html">4.10.4.4 Delayed Invalidation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-149.html">4.10.5 Propagation of Paging-Structure Changes to Multiple Processors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-150.html">4.11 Interactions with Virtual-Machine Extensions (VMX)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-150.html">4.11.1 VMX Transitions</a></li>
<li><a href="o_fe12b1e2a880e0ce-150.html">4.11.2 VMX Support for Address Translation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-151.html">4.12 Using Paging for Virtual Memory</a></li>
<li><a href="o_fe12b1e2a880e0ce-151.html">4.13 Mapping Segments to Pages</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-153.html">Chapter 5 Protection</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-153.html">5.1 Enabling and Disabling Segment and Page Protection</a></li>
<li><a href="o_fe12b1e2a880e0ce-154.html">5.2 Fields and Flags Used for Segment-Level and Page-Level Protection</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-155.html">5.2.1 Code-Segment Descriptor in 64-bit Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-156.html">5.3 Limit Checking</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-157.html">5.3.1 Limit Checking in 64-bit Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-157.html">5.4 Type Checking</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-158.html">5.4.1 Null Segment Selector Checking</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-158.html">5.4.1.1 NULL Segment Checking in 64-bit Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-158.html">5.5 Privilege Levels</a></li>
<li><a href="o_fe12b1e2a880e0ce-160.html">5.6 Privilege Level Checking When Accessing Data Segments</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-161.html">5.6.1 Accessing Data in Code Segments</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-162.html">5.7 Privilege Level Checking When Loading the SS Register</a></li>
<li><a href="o_fe12b1e2a880e0ce-162.html">5.8 Privilege Level Checking When Transferring Program Control Between Code Segments</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-162.html">5.8.1 Direct Calls or Jumps to Code Segments</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-163.html">5.8.1.1 Accessing Nonconforming Code Segments</a></li>
<li><a href="o_fe12b1e2a880e0ce-164.html">5.8.1.2 Accessing Conforming Code Segments</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-165.html">5.8.2 Gate Descriptors</a></li>
<li><a href="o_fe12b1e2a880e0ce-165.html">5.8.3 Call Gates</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-166.html">5.8.3.1 IA-32e Mode Call Gates</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-167.html">5.8.4 Accessing a Code Segment Through a Call Gate</a></li>
<li><a href="o_fe12b1e2a880e0ce-169.html">5.8.5 Stack Switching</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-171.html">5.8.5.1 Stack Switching in 64-bit Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-172.html">5.8.6 Returning from a Called Procedure</a></li>
<li><a href="o_fe12b1e2a880e0ce-172.html">5.8.7 Performing Fast Calls to System Procedures with the SYSENTER and SYSEXIT Instructions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-173.html">5.8.7.1 SYSENTER and SYSEXIT Instructions in IA-32e Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-174.html">5.8.8 Fast System Calls in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-175.html">5.9 Privileged Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-176.html">5.10 Pointer Validation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-176.html">5.10.1 Checking Access Rights (LAR Instruction)</a></li>
<li><a href="o_fe12b1e2a880e0ce-177.html">5.10.2 Checking Read/Write Rights (VERR and VERW Instructions)</a></li>
<li><a href="o_fe12b1e2a880e0ce-177.html">5.10.3 Checking That the Pointer Offset Is Within Limits (LSL Instruction)</a></li>
<li><a href="o_fe12b1e2a880e0ce-178.html">5.10.4 Checking Caller Access Privileges (ARPL Instruction)</a></li>
<li><a href="o_fe12b1e2a880e0ce-179.html">5.10.5 Checking Alignment</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-179.html">5.11 Page-Level Protection</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-180.html">5.11.1 Page-Protection Flags</a></li>
<li><a href="o_fe12b1e2a880e0ce-180.html">5.11.2 Restricting Addressable Domain</a></li>
<li><a href="o_fe12b1e2a880e0ce-180.html">5.11.3 Page Type</a></li>
<li><a href="o_fe12b1e2a880e0ce-180.html">5.11.4 Combining Protection of Both Levels of Page Tables</a></li>
<li><a href="o_fe12b1e2a880e0ce-181.html">5.11.5 Overrides to Page Protection</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-181.html">5.12 Combining Page and Segment Protection</a></li>
<li><a href="o_fe12b1e2a880e0ce-182.html">5.13 Page-Level Protection and Execute-Disable Bit</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-182.html">5.13.1 Detecting and Enabling the Execute-Disable Capability</a></li>
<li><a href="o_fe12b1e2a880e0ce-182.html">5.13.2 Execute-Disable Page Protection</a></li>
<li><a href="o_fe12b1e2a880e0ce-183.html">5.13.3 Reserved Bit Checking</a></li>
<li><a href="o_fe12b1e2a880e0ce-184.html">5.13.4 Exception Handling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-187.html">Chapter 6 Interrupt and Exception Handling</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-187.html">6.1 Interrupt and Exception Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-187.html">6.2 Exception and Interrupt Vectors</a></li>
<li><a href="o_fe12b1e2a880e0ce-188.html">6.3 Sources of Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-188.html">6.3.1 External Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-189.html">6.3.2 Maskable Hardware Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-190.html">6.3.3 Software-Generated Interrupts</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-190.html">6.4 Sources of Exceptions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-190.html">6.4.1 Program-Error Exceptions</a></li>
<li><a href="o_fe12b1e2a880e0ce-190.html">6.4.2 Software-Generated Exceptions</a></li>
<li><a href="o_fe12b1e2a880e0ce-190.html">6.4.3 Machine-Check Exceptions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-190.html">6.5 Exception Classifications</a></li>
<li><a href="o_fe12b1e2a880e0ce-191.html">6.6 Program or Task Restart</a></li>
<li><a href="o_fe12b1e2a880e0ce-192.html">6.7 NonMaskable Interrupt (NMI)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-192.html">6.7.1 Handling Multiple NMIs</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-192.html">6.8 Enabling and Disabling Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-192.html">6.8.1 Masking Maskable Hardware Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-193.html">6.8.2 Masking Instruction Breakpoints</a></li>
<li><a href="o_fe12b1e2a880e0ce-193.html">6.8.3 Masking Exceptions and Interrupts When Switching Stacks</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-194.html">6.9 Priority Among Simultaneous Exceptions and Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-195.html">6.10 Interrupt Descriptor Table (IDT)</a></li>
<li><a href="o_fe12b1e2a880e0ce-196.html">6.11 IDT Descriptors</a></li>
<li><a href="o_fe12b1e2a880e0ce-197.html">6.12 Exception and Interrupt Handling</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-197.html">6.12.1 Exception- or Interrupt-Handler Procedures</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-199.html">6.12.1.1 Protection of Exception- and Interrupt-Handler Procedures</a></li>
<li><a href="o_fe12b1e2a880e0ce-200.html">6.12.1.2 Flag Usage By Exception- or Interrupt-Handler Procedure</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-200.html">6.12.2 Interrupt Tasks</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-201.html">6.13 Error Code</a></li>
<li><a href="o_fe12b1e2a880e0ce-202.html">6.14 Exception and Interrupt Handling in 64-bit Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-202.html">6.14.1 64-Bit Mode IDT</a></li>
<li><a href="o_fe12b1e2a880e0ce-203.html">6.14.2 64-Bit Mode Stack Frame</a></li>
<li><a href="o_fe12b1e2a880e0ce-204.html">6.14.3 IRET in IA-32e Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-204.html">6.14.4 Stack Switching in IA-32e Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-205.html">6.14.5 Interrupt Stack Table</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-205.html">6.15 Exception and Interrupt Reference</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-206.html">Interrupt 0—Divide Error Exception (#DE)</a></li>
<li><a href="o_fe12b1e2a880e0ce-207.html">Interrupt 1—Debug Exception (#DB)</a></li>
<li><a href="o_fe12b1e2a880e0ce-208.html">Interrupt 2—NMI Interrupt</a></li>
<li><a href="o_fe12b1e2a880e0ce-209.html">Interrupt 3—Breakpoint Exception (#BP)</a></li>
<li><a href="o_fe12b1e2a880e0ce-210.html">Interrupt 4—Overflow Exception (#OF)</a></li>
<li><a href="o_fe12b1e2a880e0ce-211.html">Interrupt 5—BOUND Range Exceeded Exception (#BR)</a></li>
<li><a href="o_fe12b1e2a880e0ce-212.html">Interrupt 6—Invalid Opcode Exception (#UD)</a></li>
<li><a href="o_fe12b1e2a880e0ce-213.html">Interrupt 7—Device Not Available Exception (#NM)</a></li>
<li><a href="o_fe12b1e2a880e0ce-214.html">Interrupt 8—Double Fault Exception (#DF)</a></li>
<li><a href="o_fe12b1e2a880e0ce-216.html">Interrupt 9—Coprocessor Segment Overrun</a></li>
<li><a href="o_fe12b1e2a880e0ce-217.html">Interrupt 10—Invalid TSS Exception (#TS)</a></li>
<li><a href="o_fe12b1e2a880e0ce-220.html">Interrupt 11—Segment Not Present (#NP)</a></li>
<li><a href="o_fe12b1e2a880e0ce-222.html">Interrupt 12—Stack Fault Exception (#SS)</a></li>
<li><a href="o_fe12b1e2a880e0ce-223.html">Interrupt 13—General Protection Exception (#GP)</a></li>
<li><a href="o_fe12b1e2a880e0ce-226.html">Interrupt 14—Page-Fault Exception (#PF)</a></li>
<li><a href="o_fe12b1e2a880e0ce-229.html">Interrupt 16—x87 FPU Floating-Point Error (#MF)</a></li>
<li><a href="o_fe12b1e2a880e0ce-231.html">Interrupt 17—Alignment Check Exception (#AC)</a></li>
<li><a href="o_fe12b1e2a880e0ce-233.html">Interrupt 18—Machine-Check Exception (#MC)</a></li>
<li><a href="o_fe12b1e2a880e0ce-234.html">Interrupt 19—SIMD Floating-Point Exception (#XM)</a></li>
<li><a href="o_fe12b1e2a880e0ce-236.html">Interrupt 20—Virtualization Exception (#VE)</a></li>
<li><a href="o_fe12b1e2a880e0ce-237.html">Interrupts 32 to 255—User Defined Interrupts</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-239.html">Chapter 7 Task Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-239.html">7.1 Task Management Overview</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-239.html">7.1.1 Task Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-240.html">7.1.2 Task State</a></li>
<li><a href="o_fe12b1e2a880e0ce-240.html">7.1.3 Executing a Task</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-241.html">7.2 Task Management Data Structures</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-241.html">7.2.1 Task-State Segment (TSS)</a></li>
<li><a href="o_fe12b1e2a880e0ce-243.html">7.2.2 TSS Descriptor</a></li>
<li><a href="o_fe12b1e2a880e0ce-244.html">7.2.3 TSS Descriptor in 64-bit mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-245.html">7.2.4 Task Register</a></li>
<li><a href="o_fe12b1e2a880e0ce-246.html">7.2.5 Task-Gate Descriptor</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-247.html">7.3 Task Switching</a></li>
<li><a href="o_fe12b1e2a880e0ce-250.html">7.4 Task Linking</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-251.html">7.4.1 Use of Busy Flag To Prevent Recursive Task Switching</a></li>
<li><a href="o_fe12b1e2a880e0ce-251.html">7.4.2 Modifying Task Linkages</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-252.html">7.5 Task Address Space</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-252.html">7.5.1 Mapping Tasks to the Linear and Physical Address Spaces</a></li>
<li><a href="o_fe12b1e2a880e0ce-253.html">7.5.2 Task Logical Address Space</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-253.html">7.6 16-Bit Task-State Segment (TSS)</a></li>
<li><a href="o_fe12b1e2a880e0ce-254.html">7.7 Task Management in 64-bit Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-257.html">Chapter 8 Multiple-Processor Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-257.html">8.1 Locked Atomic Operations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-258.html">8.1.1 Guaranteed Atomic Operations</a></li>
<li><a href="o_fe12b1e2a880e0ce-259.html">8.1.2 Bus Locking</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-259.html">8.1.2.1 Automatic Locking</a></li>
<li><a href="o_fe12b1e2a880e0ce-259.html">8.1.2.2 Software Controlled Bus Locking</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-260.html">8.1.3 Handling Self- and Cross-Modifying Code</a></li>
<li><a href="o_fe12b1e2a880e0ce-261.html">8.1.4 Effects of a LOCK Operation on Internal Processor Caches</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-261.html">8.2 Memory Ordering</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-262.html">8.2.1 Memory Ordering in the Intel® Pentium® and Intel486™ Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-262.html">8.2.2 Memory Ordering in P6 and More Recent Processor Families</a></li>
<li><a href="o_fe12b1e2a880e0ce-263.html">8.2.3 Examples Illustrating the Memory-Ordering Principles</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-264.html">8.2.3.1 Assumptions, Terminology, and Notation</a></li>
<li><a href="o_fe12b1e2a880e0ce-265.html">8.2.3.2 Neither Loads Nor Stores Are Reordered with Like Operations</a></li>
<li><a href="o_fe12b1e2a880e0ce-265.html">8.2.3.3 Stores Are Not Reordered With Earlier Loads</a></li>
<li><a href="o_fe12b1e2a880e0ce-265.html">8.2.3.4 Loads May Be Reordered with Earlier Stores to Different Locations</a></li>
<li><a href="o_fe12b1e2a880e0ce-266.html">8.2.3.5 Intra-Processor Forwarding Is Allowed</a></li>
<li><a href="o_fe12b1e2a880e0ce-266.html">8.2.3.6 Stores Are Transitively Visible</a></li>
<li><a href="o_fe12b1e2a880e0ce-267.html">8.2.3.7 Stores Are Seen in a Consistent Order by Other Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-267.html">8.2.3.8 Locked Instructions Have a Total Order</a></li>
<li><a href="o_fe12b1e2a880e0ce-268.html">8.2.3.9 Loads and Stores Are Not Reordered with Locked Instructions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-268.html">8.2.4 Fast-String Operation and Out-of-Order Stores</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-269.html">8.2.4.1 Memory-Ordering Model for String Operations on Write-Back (WB) Memory</a></li>
<li><a href="o_fe12b1e2a880e0ce-269.html">8.2.4.2 Examples Illustrating Memory-Ordering Principles for String Operations</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-271.html">8.2.5 Strengthening or Weakening the Memory-Ordering Model</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-273.html">8.3 Serializing Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-274.html">8.4 Multiple-Processor (MP) Initialization</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-274.html">8.4.1 BSP and AP Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-275.html">8.4.2 MP Initialization Protocol Requirements and Restrictions</a></li>
<li><a href="o_fe12b1e2a880e0ce-275.html">8.4.3 MP Initialization Protocol Algorithm for MP Systems</a></li>
<li><a href="o_fe12b1e2a880e0ce-276.html">8.4.4 MP Initialization Example</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-276.html">8.4.4.1 Typical BSP Initialization Sequence</a></li>
<li><a href="o_fe12b1e2a880e0ce-278.html">8.4.4.2 Typical AP Initialization Sequence</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-279.html">8.4.5 Identifying Logical Processors in an MP System</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-280.html">8.5 Intel® Hyper-Threading Technology and Intel® Multi-Core Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-280.html">8.6 Detecting Hardware Multi-Threading Support and Topology</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-281.html">8.6.1 Initializing Processors Supporting Hyper-Threading Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-281.html">8.6.2 Initializing Multi-Core Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-282.html">8.6.3 Executing Multiple Threads on an Intel® 64 or IA-32 Processor Supporting Hardware Multi-Threading</a></li>
<li><a href="o_fe12b1e2a880e0ce-282.html">8.6.4 Handling Interrupts on an IA-32 Processor Supporting Hardware Multi-Threading</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-282.html">8.7 Intel® Hyper-Threading Technology Architecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-283.html">8.7.1 State of the Logical Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-284.html">8.7.2 APIC Functionality</a></li>
<li><a href="o_fe12b1e2a880e0ce-284.html">8.7.3 Memory Type Range Registers (MTRR)</a></li>
<li><a href="o_fe12b1e2a880e0ce-284.html">8.7.4 Page Attribute Table (PAT)</a></li>
<li><a href="o_fe12b1e2a880e0ce-284.html">8.7.5 Machine Check Architecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-285.html">8.7.6 Debug Registers and Extensions</a></li>
<li><a href="o_fe12b1e2a880e0ce-285.html">8.7.7 Performance Monitoring Counters</a></li>
<li><a href="o_fe12b1e2a880e0ce-285.html">8.7.8 IA32_MISC_ENABLE MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-285.html">8.7.9 Memory Ordering</a></li>
<li><a href="o_fe12b1e2a880e0ce-285.html">8.7.10 Serializing Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-285.html">8.7.11 Microcode Update Resources</a></li>
<li><a href="o_fe12b1e2a880e0ce-286.html">8.7.12 Self Modifying Code</a></li>
<li><a href="o_fe12b1e2a880e0ce-286.html">8.7.13 Implementation-Specific Intel HT Technology Facilities</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-286.html">8.7.13.1 Processor Caches</a></li>
<li><a href="o_fe12b1e2a880e0ce-286.html">8.7.13.2 Processor Translation Lookaside Buffers (TLBs)</a></li>
<li><a href="o_fe12b1e2a880e0ce-287.html">8.7.13.3 Thermal Monitor</a></li>
<li><a href="o_fe12b1e2a880e0ce-287.html">8.7.13.4 External Signal Compatibility</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-287.html">8.8 Multi-Core Architecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-288.html">8.8.1 Logical Processor Support</a></li>
<li><a href="o_fe12b1e2a880e0ce-288.html">8.8.2 Memory Type Range Registers (MTRR)</a></li>
<li><a href="o_fe12b1e2a880e0ce-288.html">8.8.3 Performance Monitoring Counters</a></li>
<li><a href="o_fe12b1e2a880e0ce-288.html">8.8.4 IA32_MISC_ENABLE MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-288.html">8.8.5 Microcode Update Resources</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-289.html">8.9 Programming Considerations for Hardware Multi-Threading Capable Processors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-289.html">8.9.1 Hierarchical Mapping of Shared Resources</a></li>
<li><a href="o_fe12b1e2a880e0ce-290.html">8.9.2 Hierarchical Mapping of CPUID Extended Topology Leaf</a></li>
<li><a href="o_fe12b1e2a880e0ce-291.html">8.9.3 Hierarchical ID of Logical Processors in an MP System</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-293.html">8.9.3.1 Hierarchical ID of Logical Processors with x2APIC ID</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-293.html">8.9.4 Algorithm for Three-Level Mappings of APIC_ID</a></li>
<li><a href="o_fe12b1e2a880e0ce-298.html">8.9.5 Identifying Topological Relationships in a MP System</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-302.html">8.10 Management of Idle and Blocked Conditions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-302.html">8.10.1 HLT Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-302.html">8.10.2 PAUSE Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-302.html">8.10.3 Detecting Support MONITOR/MWAIT Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-303.html">8.10.4 MONITOR/MWAIT Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-304.html">8.10.5 Monitor/Mwait Address Range Determination</a></li>
<li><a href="o_fe12b1e2a880e0ce-304.html">8.10.6 Required Operating System Support</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-305.html">8.10.6.1 Use the PAUSE Instruction in Spin-Wait Loops</a></li>
<li><a href="o_fe12b1e2a880e0ce-305.html">8.10.6.2 Potential Usage of MONITOR/MWAIT in C0 Idle Loops</a></li>
<li><a href="o_fe12b1e2a880e0ce-306.html">8.10.6.3 Halt Idle Logical Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-307.html">8.10.6.4 Potential Usage of MONITOR/MWAIT in C1 Idle Loops</a></li>
<li><a href="o_fe12b1e2a880e0ce-307.html">8.10.6.5 Guidelines for Scheduling Threads on Logical Processors Sharing Execution Resources</a></li>
<li><a href="o_fe12b1e2a880e0ce-308.html">8.10.6.6 Eliminate Execution-Based Timing Loops</a></li>
<li><a href="o_fe12b1e2a880e0ce-308.html">8.10.6.7 Place Locks and Semaphores in Aligned, 128-Byte Blocks of Memory</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-308.html">8.11 MP Initialization For P6 Family Processors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-308.html">8.11.1 Overview of the MP Initialization Process For P6 Family Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-309.html">8.11.2 MP Initialization Protocol Algorithm</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-310.html">8.11.2.1 Error Detection and Handling During the MP Initialization Protocol</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-313.html">Chapter 9 Processor Management and Initialization</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-313.html">9.1 Initialization Overview</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-314.html">9.1.1 Processor State After Reset</a></li>
<li><a href="o_fe12b1e2a880e0ce-317.html">9.1.2 Processor Built-In Self-Test (BIST)</a></li>
<li><a href="o_fe12b1e2a880e0ce-317.html">9.1.3 Model and Stepping Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-317.html">9.1.4 First Instruction Executed</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-317.html">9.2 x87 FPU Initialization</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-318.html">9.2.1 Configuring the x87 FPU Environment</a></li>
<li><a href="o_fe12b1e2a880e0ce-318.html">9.2.2 Setting the Processor for x87 FPU Software Emulation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-319.html">9.3 Cache Enabling</a></li>
<li><a href="o_fe12b1e2a880e0ce-319.html">9.4 Model-Specific Registers (MSRs)</a></li>
<li><a href="o_fe12b1e2a880e0ce-320.html">9.5 Memory Type Range Registers (MTRRs)</a></li>
<li><a href="o_fe12b1e2a880e0ce-320.html">9.6 Initializing SSE/SSE2/SSE3/SSSE3 Extensions</a></li>
<li><a href="o_fe12b1e2a880e0ce-320.html">9.7 Software Initialization for Real-Address Mode Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-320.html">9.7.1 Real-Address Mode IDT</a></li>
<li><a href="o_fe12b1e2a880e0ce-321.html">9.7.2 NMI Interrupt Handling</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-321.html">9.8 Software Initialization for Protected-Mode Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-321.html">9.8.1 Protected-Mode System Data Structures</a></li>
<li><a href="o_fe12b1e2a880e0ce-322.html">9.8.2 Initializing Protected-Mode Exceptions and Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-322.html">9.8.3 Initializing Paging</a></li>
<li><a href="o_fe12b1e2a880e0ce-322.html">9.8.4 Initializing Multitasking</a></li>
<li><a href="o_fe12b1e2a880e0ce-323.html">9.8.5 Initializing IA-32e Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-323.html">9.8.5.1 IA-32e Mode System Data Structures</a></li>
<li><a href="o_fe12b1e2a880e0ce-324.html">9.8.5.2 IA-32e Mode Interrupts and Exceptions</a></li>
<li><a href="o_fe12b1e2a880e0ce-324.html">9.8.5.3 64-bit Mode and Compatibility Mode Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-324.html">9.8.5.4 Switching Out of IA-32e Mode Operation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-325.html">9.9 Mode Switching</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-325.html">9.9.1 Switching to Protected Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-326.html">9.9.2 Switching Back to Real-Address Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-326.html">9.10 Initialization and Mode Switching Example</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-328.html">9.10.1 Assembler Usage</a></li>
<li><a href="o_fe12b1e2a880e0ce-328.html">9.10.2 STARTUP.ASM Listing</a></li>
<li><a href="o_fe12b1e2a880e0ce-337.html">9.10.3 MAIN.ASM Source Code</a></li>
<li><a href="o_fe12b1e2a880e0ce-337.html">9.10.4 Supporting Files</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-339.html">9.11 Microcode Update Facilities</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-340.html">9.11.1 Microcode Update</a></li>
<li><a href="o_fe12b1e2a880e0ce-343.html">9.11.2 Optional Extended Signature Table</a></li>
<li><a href="o_fe12b1e2a880e0ce-344.html">9.11.3 Processor Identification</a></li>
<li><a href="o_fe12b1e2a880e0ce-344.html">9.11.4 Platform Identification</a></li>
<li><a href="o_fe12b1e2a880e0ce-345.html">9.11.5 Microcode Update Checksum</a></li>
<li><a href="o_fe12b1e2a880e0ce-346.html">9.11.6 Microcode Update Loader</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-347.html">9.11.6.1 Hard Resets in Update Loading</a></li>
<li><a href="o_fe12b1e2a880e0ce-347.html">9.11.6.2 Update in a Multiprocessor System</a></li>
<li><a href="o_fe12b1e2a880e0ce-347.html">9.11.6.3 Update in a System Supporting Intel Hyper-Threading Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-347.html">9.11.6.4 Update in a System Supporting Dual-Core Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-347.html">9.11.6.5 Update Loader Enhancements</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-348.html">9.11.7 Update Signature and Verification</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-348.html">9.11.7.1 Determining the Signature</a></li>
<li><a href="o_fe12b1e2a880e0ce-349.html">9.11.7.2 Authenticating the Update</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-349.html">9.11.8 Optional Processor Microcode Update Specifications</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-350.html">9.11.8.1 Responsibilities of the BIOS</a></li>
<li><a href="o_fe12b1e2a880e0ce-351.html">9.11.8.2 Responsibilities of the Calling Program</a></li>
<li><a href="o_fe12b1e2a880e0ce-354.html">9.11.8.3 Microcode Update Functions</a></li>
<li><a href="o_fe12b1e2a880e0ce-354.html">9.11.8.4 INT 15H-based Interface</a></li>
<li><a href="o_fe12b1e2a880e0ce-354.html">9.11.8.5 Function 00H—Presence Test</a></li>
<li><a href="o_fe12b1e2a880e0ce-355.html">9.11.8.6 Function 01H—Write Microcode Update Data</a></li>
<li><a href="o_fe12b1e2a880e0ce-358.html">9.11.8.7 Function 02H—Microcode Update Control</a></li>
<li><a href="o_fe12b1e2a880e0ce-359.html">9.11.8.8 Function 03H—Read Microcode Update Data</a></li>
<li><a href="o_fe12b1e2a880e0ce-360.html">9.11.8.9 Return Codes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-363.html">Chapter 10 Advanced Programmable Interrupt Controller (APIC)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-363.html">10.1 Local and I/O APIC Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-366.html">10.2 System Bus Vs. APIC Bus</a></li>
<li><a href="o_fe12b1e2a880e0ce-366.html">10.3 The Intel® 82489DX External APIC, the APIC, the xAPIC, and the X2APIC</a></li>
<li><a href="o_fe12b1e2a880e0ce-366.html">10.4 Local APIC</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-366.html">10.4.1 The Local APIC Block Diagram</a></li>
<li><a href="o_fe12b1e2a880e0ce-369.html">10.4.2 Presence of the Local APIC</a></li>
<li><a href="o_fe12b1e2a880e0ce-370.html">10.4.3 Enabling or Disabling the Local APIC</a></li>
<li><a href="o_fe12b1e2a880e0ce-370.html">10.4.4 Local APIC Status and Location</a></li>
<li><a href="o_fe12b1e2a880e0ce-371.html">10.4.5 Relocating the Local APIC Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-371.html">10.4.6 Local APIC ID</a></li>
<li><a href="o_fe12b1e2a880e0ce-372.html">10.4.7 Local APIC State</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-372.html">10.4.7.1 Local APIC State After Power-Up or Reset</a></li>
<li><a href="o_fe12b1e2a880e0ce-372.html">10.4.7.2 Local APIC State After It Has Been Software Disabled</a></li>
<li><a href="o_fe12b1e2a880e0ce-372.html">10.4.7.3 Local APIC State After an INIT Reset (“Wait-for-SIPI” State)</a></li>
<li><a href="o_fe12b1e2a880e0ce-373.html">10.4.7.4 Local APIC State After It Receives an INIT-Deassert IPI</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-373.html">10.4.8 Local APIC Version Register</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-373.html">10.5 Handling Local Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-374.html">10.5.1 Local Vector Table</a></li>
<li><a href="o_fe12b1e2a880e0ce-376.html">10.5.2 Valid Interrupt Vectors</a></li>
<li><a href="o_fe12b1e2a880e0ce-376.html">10.5.3 Error Handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-378.html">10.5.4 APIC Timer</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-379.html">10.5.4.1 TSC-Deadline Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-380.html">10.5.5 Local Interrupt Acceptance</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-380.html">10.6 Issuing Interprocessor Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-380.html">10.6.1 Interrupt Command Register (ICR)</a></li>
<li><a href="o_fe12b1e2a880e0ce-384.html">10.6.2 Determining IPI Destination</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-384.html">10.6.2.1 Physical Destination Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-385.html">10.6.2.2 Logical Destination Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-386.html">10.6.2.3 Broadcast/Self Delivery Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-386.html">10.6.2.4 Lowest Priority Delivery Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-387.html">10.6.3 IPI Delivery and Acceptance</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-387.html">10.7 System and APIC Bus Arbitration</a></li>
<li><a href="o_fe12b1e2a880e0ce-388.html">10.8 Handling Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-388.html">10.8.1 Interrupt Handling with the Pentium 4 and Intel Xeon Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-389.html">10.8.2 Interrupt Handling with the P6 Family and Pentium Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-390.html">10.8.3 Interrupt, Task, and Processor Priority</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-390.html">10.8.3.1 Task and Processor Priorities</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-391.html">10.8.4 Interrupt Acceptance for Fixed Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-392.html">10.8.5 Signaling Interrupt Servicing Completion</a></li>
<li><a href="o_fe12b1e2a880e0ce-393.html">10.8.6 Task Priority in IA-32e Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-393.html">10.8.6.1 Interaction of Task Priorities between CR8 and APIC</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-394.html">10.9 Spurious Interrupt</a></li>
<li><a href="o_fe12b1e2a880e0ce-394.html">10.10 APIC Bus Message Passing Mechanism and Protocol (P6 Family, Pentium Processors)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-395.html">10.10.1 Bus Message Formats</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-395.html">10.11 Message Signalled Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-396.html">10.11.1 Message Address Register Format</a></li>
<li><a href="o_fe12b1e2a880e0ce-397.html">10.11.2 Message Data Register Format</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-398.html">10.12 Extended XAPIC (x2APIC)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-398.html">10.12.1 Detecting and Enabling x2APIC Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-399.html">10.12.1.1 Instructions to Access APIC Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-399.html">10.12.1.2 x2APIC Register Address Space</a></li>
<li><a href="o_fe12b1e2a880e0ce-401.html">10.12.1.3 Reserved Bit Checking</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-402.html">10.12.2 x2APIC Register Availability</a></li>
<li><a href="o_fe12b1e2a880e0ce-402.html">10.12.3 MSR Access in x2APIC Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-402.html">10.12.4 VM-Exit Controls for MSRs and x2APIC Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-402.html">10.12.5 x2APIC State Transitions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-402.html">10.12.5.1 x2APIC States</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-403.html">x2APIC After Reset</a></li>
<li><a href="o_fe12b1e2a880e0ce-404.html">x2APIC Transitions From x2APIC Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-404.html">x2APIC Transitions From Disabled Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-404.html">State Changes From xAPIC Mode to x2APIC Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-404.html">10.12.6 Routing of Device Interrupts in x2APIC Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-405.html">10.12.7 Initialization by System Software</a></li>
<li><a href="o_fe12b1e2a880e0ce-405.html">10.12.8 CPUID Extensions And Topology Enumeration</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-405.html">10.12.8.1 Consistency of APIC IDs and CPUID</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-406.html">10.12.9 ICR Operation in x2APIC Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-407.html">10.12.10 Determining IPI Destination in x2APIC Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-407.html">10.12.10.1 Logical Destination Mode in x2APIC Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-407.html">10.12.10.2 Deriving Logical x2APIC ID from the Local x2APIC ID</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-408.html">10.12.11 SELF IPI Register</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-408.html">10.13 APIC Bus Message Formats</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-408.html">10.13.1 Bus Message Formats</a></li>
<li><a href="o_fe12b1e2a880e0ce-409.html">10.13.2 EOI Message</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-409.html">10.13.2.1 Short Message</a></li>
<li><a href="o_fe12b1e2a880e0ce-410.html">10.13.2.2 Non-focused Lowest Priority Message</a></li>
<li><a href="o_fe12b1e2a880e0ce-411.html">10.13.2.3 APIC Bus Status Cycles</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-413.html">Chapter 11 Memory Cache Control</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-413.html">11.1 Internal Caches, TLBs, and Buffers</a></li>
<li><a href="o_fe12b1e2a880e0ce-417.html">11.2 Caching Terminology</a></li>
<li><a href="o_fe12b1e2a880e0ce-418.html">11.3 Methods of Caching Available</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-419.html">11.3.1 Buffering of Write Combining Memory Locations</a></li>
<li><a href="o_fe12b1e2a880e0ce-420.html">11.3.2 Choosing a Memory Type</a></li>
<li><a href="o_fe12b1e2a880e0ce-421.html">11.3.3 Code Fetches in Uncacheable Memory</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-421.html">11.4 Cache Control Protocol</a></li>
<li><a href="o_fe12b1e2a880e0ce-422.html">11.5 Cache Control</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-422.html">11.5.1 Cache Control Registers and Bits</a></li>
<li><a href="o_fe12b1e2a880e0ce-425.html">11.5.2 Precedence of Cache Controls</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-426.html">11.5.2.1 Selecting Memory Types for Pentium Pro and Pentium II Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-427.html">11.5.2.2 Selecting Memory Types for Pentium III and More Recent Processor Families</a></li>
<li><a href="o_fe12b1e2a880e0ce-428.html">11.5.2.3 Writing Values Across Pages with Different Memory Types</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-428.html">11.5.3 Preventing Caching</a></li>
<li><a href="o_fe12b1e2a880e0ce-429.html">11.5.4 Disabling and Enabling the L3 Cache</a></li>
<li><a href="o_fe12b1e2a880e0ce-429.html">11.5.5 Cache Management Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-430.html">11.5.6 L1 Data Cache Context Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-430.html">11.5.6.1 Adaptive Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-430.html">11.5.6.2 Shared Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-430.html">11.6 Self-Modifying Code</a></li>
<li><a href="o_fe12b1e2a880e0ce-431.html">11.7 Implicit Caching (Pentium 4, Intel Xeon, and P6 Family Processors)</a></li>
<li><a href="o_fe12b1e2a880e0ce-431.html">11.8 Explicit Caching</a></li>
<li><a href="o_fe12b1e2a880e0ce-431.html">11.9 Invalidating the Translation Lookaside Buffers (TLBs)</a></li>
<li><a href="o_fe12b1e2a880e0ce-432.html">11.10 Store Buffer</a></li>
<li><a href="o_fe12b1e2a880e0ce-432.html">11.11 Memory Type Range Registers (MTRRs)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-433.html">11.11.1 MTRR Feature Identification</a></li>
<li><a href="o_fe12b1e2a880e0ce-434.html">11.11.2 Setting Memory Ranges with MTRRs</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-434.html">11.11.2.1 IA32_MTRR_DEF_TYPE MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-435.html">11.11.2.2 Fixed Range MTRRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-435.html">11.11.2.3 Variable Range MTRRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-437.html">11.11.2.4 System-Management Range Register Interface</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-438.html">11.11.3 Example Base and Mask Calculations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-439.html">11.11.3.1 Base and Mask Calculations for Greater-Than 36-bit Physical Address Support</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-440.html">11.11.4 Range Size and Alignment Requirement</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-440.html">11.11.4.1 MTRR Precedences</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-441.html">11.11.5 MTRR Initialization</a></li>
<li><a href="o_fe12b1e2a880e0ce-441.html">11.11.6 Remapping Memory Types</a></li>
<li><a href="o_fe12b1e2a880e0ce-441.html">11.11.7 MTRR Maintenance Programming Interface</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-441.html">11.11.7.1 MemTypeGet() Function</a></li>
<li><a href="o_fe12b1e2a880e0ce-443.html">11.11.7.2 MemTypeSet() Function</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-444.html">11.11.8 MTRR Considerations in MP Systems</a></li>
<li><a href="o_fe12b1e2a880e0ce-445.html">11.11.9 Large Page Size Considerations</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-445.html">11.12 Page Attribute Table (PAT)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-446.html">11.12.1 Detecting Support for the PAT Feature</a></li>
<li><a href="o_fe12b1e2a880e0ce-446.html">11.12.2 IA32_PAT MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-447.html">11.12.3 Selecting a Memory Type from the PAT</a></li>
<li><a href="o_fe12b1e2a880e0ce-447.html">11.12.4 Programming the PAT</a></li>
<li><a href="o_fe12b1e2a880e0ce-448.html">11.12.5 PAT Compatibility with Earlier IA-32 Processors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-449.html">Chapter 12 Intel® MMX™ Technology System Programming</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-449.html">12.1 Emulation of the MMX Instruction Set</a></li>
<li><a href="o_fe12b1e2a880e0ce-449.html">12.2 The MMX State and MMX Register Aliasing</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-451.html">12.2.1 Effect of MMX, x87 FPU, FXSAVE, and FXRSTOR Instructions on the x87 FPU Tag Word</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-451.html">12.3 Saving and Restoring the MMX State and Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-452.html">12.4 Saving MMX State on Task or Context Switches</a></li>
<li><a href="o_fe12b1e2a880e0ce-452.html">12.5 EXCEPTIONS That Can Occur When Executing MMX Instructions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-453.html">12.5.1 Effect of MMX Instructions on Pending x87 Floating-Point Exceptions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-453.html">12.6 Debugging MMX Code</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-455.html">Chapter 13 System Programming for Instruction Set Extensions and Processor Extended States</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-455.html">13.1 Providing Operating System Support for SSE Extensions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-456.html">13.1.1 Adding Support to an Operating System for SSE Extensions</a></li>
<li><a href="o_fe12b1e2a880e0ce-456.html">13.1.2 Checking for CPU Support</a></li>
<li><a href="o_fe12b1e2a880e0ce-456.html">13.1.3 Initialization of the SSE Extensions</a></li>
<li><a href="o_fe12b1e2a880e0ce-458.html">13.1.4 Providing Non-Numeric Exception Handlers for Exceptions Generated by the SSE Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-459.html">13.1.5 Providing a Handler for the SIMD Floating-Point Exception (#XM)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-460.html">13.1.5.1 Numeric Error flag and IGNNE#</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-460.html">13.2 Emulation of SSE Extensions</a></li>
<li><a href="o_fe12b1e2a880e0ce-460.html">13.3 Saving and Restoring SSE State</a></li>
<li><a href="o_fe12b1e2a880e0ce-460.html">13.4 Designing OS Facilities for Saving x87 FPU, SSE AND EXTENDED States on Task or Context Switches</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-461.html">13.4.1 Using the TS Flag to Control the Saving of the x87 FPU and SSE State</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-461.html">13.5 The XSAVE Feature Set and Processor Extended State Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-462.html">13.5.1 Checking the Support for XSAVE Feature Set</a></li>
<li><a href="o_fe12b1e2a880e0ce-462.html">13.5.2 Determining the XSAVE Managed Feature States And The Required Buffer Size</a></li>
<li><a href="o_fe12b1e2a880e0ce-463.html">13.5.3 Enable the Use Of XSAVE Feature Set And XSAVE State Components</a></li>
<li><a href="o_fe12b1e2a880e0ce-463.html">13.5.4 Provide an Initialization for the XSAVE State Components</a></li>
<li><a href="o_fe12b1e2a880e0ce-463.html">13.5.5 Providing the Required Exception Handlers</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-463.html">13.6 Interoperability Of The XSAVE Feature Set And FXSAVE/FXRSTOR</a></li>
<li><a href="o_fe12b1e2a880e0ce-464.html">13.7 The XSAVE Feature Set And Processor Supervisor State Management</a></li>
<li><a href="o_fe12b1e2a880e0ce-464.html">13.8 System Programming For XSAVE ManAged Features</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-465.html">13.8.1 Intel® Advanced Vector Extensions (Intel® AVX)</a></li>
<li><a href="o_fe12b1e2a880e0ce-465.html">13.8.2 Intel® Advanced Vector Extensions 512 (Intel® AVX-512)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-467.html">Chapter 14 Power and Thermal Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-467.html">14.1 Enhanced Intel Speedstep® Technology</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-467.html">14.1.1 Software Interface For Initiating Performance State Transitions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-467.html">14.2 P-State Hardware Coordination</a></li>
<li><a href="o_fe12b1e2a880e0ce-469.html">14.3 System Software Considerations and Opportunistic processor Performance operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-469.html">14.3.1 Intel Dynamic Acceleration</a></li>
<li><a href="o_fe12b1e2a880e0ce-469.html">14.3.2 System Software Interfaces for Opportunistic Processor Performance Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-469.html">14.3.2.1 Discover Hardware Support and Enabling of Opportunistic Processor Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-470.html">14.3.2.2 OS Control of Opportunistic Processor Performance Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-470.html">14.3.2.3 Required Changes to OS Power Management P-state Policy</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-471.html">14.3.3 Intel Turbo Boost Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-471.html">14.3.4 Performance and Energy Bias Hint support</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-471.html">14.4 Hardware-Controlled Performance States (HWP)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-472.html">14.4.1 HWP Programming Interfaces</a></li>
<li><a href="o_fe12b1e2a880e0ce-473.html">14.4.2 Enabling HWP</a></li>
<li><a href="o_fe12b1e2a880e0ce-473.html">14.4.3 HWP Performance Range and Dynamic Capabilities</a></li>
<li><a href="o_fe12b1e2a880e0ce-474.html">14.4.4 Managing HWP</a></li>
<li><a href="o_fe12b1e2a880e0ce-475.html">14.4.5 HWP Feedback</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-477.html">14.4.5.1 Non-Architectural HWP Feedback</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-477.html">14.4.6 HWP Notifications</a></li>
<li><a href="o_fe12b1e2a880e0ce-478.html">14.4.7 Recommendations for OS use of HWP Controls</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-479.html">14.5 Hardware Duty Cycling (HDC)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-479.html">14.5.1 Hardware Duty Cycling Programming Interfaces</a></li>
<li><a href="o_fe12b1e2a880e0ce-480.html">14.5.2 Package level Enabling HDC</a></li>
<li><a href="o_fe12b1e2a880e0ce-480.html">14.5.3 Logical-Processor Level HDC Control</a></li>
<li><a href="o_fe12b1e2a880e0ce-481.html">14.5.4 HDC Residency Counters</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-481.html">14.5.4.1 IA32_THREAD_STALL</a></li>
<li><a href="o_fe12b1e2a880e0ce-482.html">14.5.4.2 Non-Architectural HDC Residency Counters</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-484.html">14.5.5 MPERF and APERF Counters Under HDC</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-484.html">14.6 MWAIT Extensions for Advanced Power Management</a></li>
<li><a href="o_fe12b1e2a880e0ce-485.html">14.7 Thermal Monitoring and Protection</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-486.html">14.7.1 Catastrophic Shutdown Detector</a></li>
<li><a href="o_fe12b1e2a880e0ce-486.html">14.7.2 Thermal Monitor</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-486.html">14.7.2.1 Thermal Monitor 1</a></li>
<li><a href="o_fe12b1e2a880e0ce-486.html">14.7.2.2 Thermal Monitor 2</a></li>
<li><a href="o_fe12b1e2a880e0ce-486.html">14.7.2.3 Two Methods for Enabling TM2</a></li>
<li><a href="o_fe12b1e2a880e0ce-487.html">14.7.2.4 Performance State Transitions and Thermal Monitoring</a></li>
<li><a href="o_fe12b1e2a880e0ce-487.html">14.7.2.5 Thermal Status Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-488.html">14.7.2.6 Adaptive Thermal Monitor</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-489.html">14.7.3 Software Controlled Clock Modulation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-490.html">14.7.3.1 Extension of Software Controlled Clock Modulation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-490.html">14.7.4 Detection of Thermal Monitor and Software Controlled Clock Modulation Facilities</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-490.html">14.7.4.1 Detection of Software Controlled Clock Modulation Extension</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-490.html">14.7.5 On Die Digital Thermal Sensors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-491.html">14.7.5.1 Digital Thermal Sensor Enumeration</a></li>
<li><a href="o_fe12b1e2a880e0ce-491.html">14.7.5.2 Reading the Digital Sensor</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-494.html">14.7.6 Power Limit Notification</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-494.html">14.8 Package Level Thermal Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-496.html">14.8.1 Support for Passive and Active cooling</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-497.html">14.9 Platform Specific Power Management Support</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-497.html">14.9.1 RAPL Interfaces</a></li>
<li><a href="o_fe12b1e2a880e0ce-498.html">14.9.2 RAPL Domains and Platform Specificity</a></li>
<li><a href="o_fe12b1e2a880e0ce-499.html">14.9.3 Package RAPL Domain</a></li>
<li><a href="o_fe12b1e2a880e0ce-501.html">14.9.4 PP0/PP1 RAPL Domains</a></li>
<li><a href="o_fe12b1e2a880e0ce-503.html">14.9.5 DRAM RAPL Domain</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-507.html">Chapter 15 Machine-Check Architecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-507.html">15.1 Machine-Check Architecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-507.html">15.2 Compatibility with Pentium Processor</a></li>
<li><a href="o_fe12b1e2a880e0ce-508.html">15.3 Machine-Check MSRs</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-508.html">15.3.1 Machine-Check Global Control MSRs</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-508.html">15.3.1.1 IA32_MCG_CAP MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-510.html">15.3.1.2 IA32_MCG_STATUS MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-510.html">15.3.1.3 IA32_MCG_CTL MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-511.html">15.3.1.4 IA32_MCG_EXT_CTL MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-511.html">15.3.1.5 Enabling Local Machine Check</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-511.html">15.3.2 Error-Reporting Register Banks</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-511.html">15.3.2.1 IA32_MCi_CTL MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-512.html">15.3.2.2 IA32_MCi_STATUS MSRS</a></li>
<li><a href="o_fe12b1e2a880e0ce-515.html">15.3.2.3 IA32_MCi_ADDR MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-515.html">15.3.2.4 IA32_MCi_MISC MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-516.html">15.3.2.5 IA32_MCi_CTL2 MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-517.html">15.3.2.6 IA32_MCG Extended Machine Check State MSRs</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-518.html">15.3.3 Mapping of the Pentium Processor Machine-Check Errors to the Machine-Check Architecture</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-519.html">15.4 Enhanced Cache Error reporting</a></li>
<li><a href="o_fe12b1e2a880e0ce-519.html">15.5 Corrected Machine Check Error Interrupt</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-519.html">15.5.1 CMCI Local APIC Interface</a></li>
<li><a href="o_fe12b1e2a880e0ce-520.html">15.5.2 System Software Recommendation for Managing CMCI and Machine Check Resources</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-520.html">15.5.2.1 CMCI Initialization</a></li>
<li><a href="o_fe12b1e2a880e0ce-521.html">15.5.2.2 CMCI Threshold Management</a></li>
<li><a href="o_fe12b1e2a880e0ce-521.html">15.5.2.3 CMCI Interrupt Handler</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-521.html">15.6 Recovery of Uncorrected Recoverable (UCR) Errors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-522.html">15.6.1 Detection of Software Error Recovery Support</a></li>
<li><a href="o_fe12b1e2a880e0ce-522.html">15.6.2 UCR Error Reporting and Logging</a></li>
<li><a href="o_fe12b1e2a880e0ce-522.html">15.6.3 UCR Error Classification</a></li>
<li><a href="o_fe12b1e2a880e0ce-523.html">15.6.4 UCR Error Overwrite Rules</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-524.html">15.7 Machine-Check Availability</a></li>
<li><a href="o_fe12b1e2a880e0ce-524.html">15.8 Machine-Check Initialization</a></li>
<li><a href="o_fe12b1e2a880e0ce-526.html">15.9 Interpreting the MCA Error Codes</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-526.html">15.9.1 Simple Error Codes</a></li>
<li><a href="o_fe12b1e2a880e0ce-526.html">15.9.2 Compound Error Codes</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-527.html">15.9.2.1 Correction Report Filtering (F) Bit</a></li>
<li><a href="o_fe12b1e2a880e0ce-527.html">15.9.2.2 Transaction Type (TT) Sub-Field</a></li>
<li><a href="o_fe12b1e2a880e0ce-527.html">15.9.2.3 Level (LL) Sub-Field</a></li>
<li><a href="o_fe12b1e2a880e0ce-528.html">15.9.2.4 Request (RRRR) Sub-Field</a></li>
<li><a href="o_fe12b1e2a880e0ce-528.html">15.9.2.5 Bus and Interconnect Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-529.html">15.9.2.6 Memory Controller Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-529.html">15.9.3 Architecturally Defined UCR Errors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-529.html">15.9.3.1 Architecturally Defined SRAO Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-530.html">15.9.3.2 Architecturally Defined SRAR Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-532.html">15.9.4 Multiple MCA Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-532.html">15.9.5 Machine-Check Error Codes Interpretation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-532.html">15.10 Guidelines for Writing Machine-Check Software</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-533.html">15.10.1 Machine-Check Exception Handler</a></li>
<li><a href="o_fe12b1e2a880e0ce-534.html">15.10.2 Pentium Processor Machine-Check Exception Handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-534.html">15.10.3 Logging Correctable Machine-Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-536.html">15.10.4 Machine-Check Software Handler Guidelines for Error Recovery</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-536.html">15.10.4.1 Machine-Check Exception Handler for Error Recovery</a></li>
<li><a href="o_fe12b1e2a880e0ce-540.html">15.10.4.2 Corrected Machine-Check Handler for Error Recovery</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-543.html">Chapter 16 Interpreting Machine-Check Error Codes</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-543.html">16.1 Incremental Decoding Information: Processor Family 06H Machine Error Codes For Machine Check</a></li>
<li><a href="o_fe12b1e2a880e0ce-545.html">16.2 Incremental Decoding Information: Intel Core 2 Processor Family Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-547.html">16.2.1 Model-Specific Machine Check Error Codes for Intel Xeon Processor 7400 Series</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-548.html">16.2.1.1 Processor Machine Check Status Register Incremental MCA Error Code Definition</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-548.html">16.2.2 Intel Xeon Processor 7400 Model Specific Error Code Field</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-548.html">16.2.2.1 Processor Model Specific Error Code Field Type B: Bus and Interconnect Error</a></li>
<li><a href="o_fe12b1e2a880e0ce-549.html">16.2.2.2 Processor Model Specific Error Code Field Type C: Cache Bus Controller Error</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-549.html">16.3 Incremental Decoding Information: Processor Family with CPUID DisplayFamily_DisplayModel Signature 06_1AH, Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-550.html">16.3.1 Intel QPI Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-550.html">16.3.2 Internal Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-551.html">16.3.3 Memory Controller Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-552.html">16.4 Incremental Decoding Information: Processor Family with CPUID DisplayFamily_DisplayModel Signature 06_2DH, Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-552.html">16.4.1 Internal Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-553.html">16.4.2 Intel QPI Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-553.html">16.4.3 Integrated Memory Controller Machine Check Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-555.html">16.5 Incremental Decoding Information: Processor Family with CPUID DisplayFamily_DisplayModel Signature 06_3EH, Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-555.html">16.5.1 Internal Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-556.html">16.5.2 Integrated Memory Controller Machine Check Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-557.html">16.6 Incremental Decoding Information: Processor Family with CPUID DisplayFamily_DisplayModel Signature 06_3FH, Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-558.html">16.6.1 Internal Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-559.html">16.6.2 Intel QPI Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-559.html">16.6.3 Integrated Memory Controller Machine Check Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-561.html">16.7 Incremental Decoding Information: Processor Family with CPUID DisplayFamily_DisplayModel Signature 06_56H, Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-561.html">16.7.1 Internal Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-562.html">16.7.2 Integrated Memory Controller Machine Check Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-563.html">16.8 Incremental Decoding Information: Processor Family with CPUID DisplayFamily_DisplayModel Signature 06_4FH, Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-563.html">16.8.1 Integrated Memory Controller Machine Check Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-564.html">16.9 Incremental Decoding Information: Processor Family with CPUID DisplayFamily_DisplayModel Signature 06_55H, Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-564.html">16.9.1 Internal Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-565.html">16.9.2 Interconnect Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-567.html">16.9.3 Integrated Memory Controller Machine Check Errors</a></li>
<li><a href="o_fe12b1e2a880e0ce-568.html">16.9.4 M2M Machine Check Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-568.html">16.10 Incremental Decoding Information: Processor Family 0FH Machine Error Codes For Machine Check</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-569.html">16.10.1 Model-Specific Machine Check Error Codes for Intel Xeon Processor MP 7100 Series</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-570.html">16.10.1.1 Processor Machine Check Status Register MCA Error Code Definition</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-571.html">16.10.2 Other_Info Field (all MCA Error Types)</a></li>
<li><a href="o_fe12b1e2a880e0ce-572.html">16.10.3 Processor Model Specific Error Code Field</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-572.html">16.10.3.1 MCA Error Type A: L3 Error</a></li>
<li><a href="o_fe12b1e2a880e0ce-572.html">16.10.3.2 Processor Model Specific Error Code Field Type B: Bus and Interconnect Error</a></li>
<li><a href="o_fe12b1e2a880e0ce-573.html">16.10.3.3 Processor Model Specific Error Code Field Type C: Cache Bus Controller Error</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-575.html">Chapter 17 Debug, Branch Profile, TSC, and Resource Monitoring Features</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-575.html">17.1 Overview of Debug Support Facilities</a></li>
<li><a href="o_fe12b1e2a880e0ce-576.html">17.2 Debug Registers</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-577.html">17.2.1 Debug Address Registers (DR0-DR3)</a></li>
<li><a href="o_fe12b1e2a880e0ce-577.html">17.2.2 Debug Registers DR4 and DR5</a></li>
<li><a href="o_fe12b1e2a880e0ce-577.html">17.2.3 Debug Status Register (DR6)</a></li>
<li><a href="o_fe12b1e2a880e0ce-578.html">17.2.4 Debug Control Register (DR7)</a></li>
<li><a href="o_fe12b1e2a880e0ce-579.html">17.2.5 Breakpoint Field Recognition</a></li>
<li><a href="o_fe12b1e2a880e0ce-580.html">17.2.6 Debug Registers and Intel® 64 Processors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-580.html">17.3 Debug Exceptions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-580.html">17.3.1 Debug Exception (#DB)—Interrupt Vector 1</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-582.html">17.3.1.1 Instruction-Breakpoint Exception Condition</a></li>
<li><a href="o_fe12b1e2a880e0ce-583.html">17.3.1.2 Data Memory and I/O Breakpoint Exception Conditions</a></li>
<li><a href="o_fe12b1e2a880e0ce-583.html">17.3.1.3 General-Detect Exception Condition</a></li>
<li><a href="o_fe12b1e2a880e0ce-583.html">17.3.1.4 Single-Step Exception Condition</a></li>
<li><a href="o_fe12b1e2a880e0ce-584.html">17.3.1.5 Task-Switch Exception Condition</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-584.html">17.3.2 Breakpoint Exception (#BP)—Interrupt Vector 3</a></li>
<li><a href="o_fe12b1e2a880e0ce-584.html">17.3.3 Debug Exceptions, Breakpoint Exceptions, and Restricted Transactional Memory (RTM)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-584.html">17.4 Last Branch, Interrupt, and Exception Recording Overview</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-585.html">17.4.1 IA32_DEBUGCTL MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-586.html">17.4.2 Monitoring Branches, Exceptions, and Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-587.html">17.4.3 Single-Stepping on Branches</a></li>
<li><a href="o_fe12b1e2a880e0ce-587.html">17.4.4 Branch Trace Messages</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-587.html">17.4.4.1 Branch Trace Message Visibility</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-587.html">17.4.5 Branch Trace Store (BTS)</a></li>
<li><a href="o_fe12b1e2a880e0ce-588.html">17.4.6 CPL-Qualified Branch Trace Mechanism</a></li>
<li><a href="o_fe12b1e2a880e0ce-588.html">17.4.7 Freezing LBR and Performance Counters on PMI</a></li>
<li><a href="o_fe12b1e2a880e0ce-589.html">17.4.8 LBR Stack</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-590.html">17.4.8.1 LBR Stack and Intel® 64 Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-591.html">17.4.8.2 LBR Stack and IA-32 Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-591.html">17.4.8.3 Last Exception Records and Intel 64 Architecture</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-591.html">17.4.9 BTS and DS Save Area</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-594.html">17.4.9.1 64 Bit Format of the DS Save Area</a></li>
<li><a href="o_fe12b1e2a880e0ce-596.html">17.4.9.2 Setting Up the DS Save Area</a></li>
<li><a href="o_fe12b1e2a880e0ce-597.html">17.4.9.3 Setting Up the BTS Buffer</a></li>
<li><a href="o_fe12b1e2a880e0ce-598.html">17.4.9.4 Setting Up CPL-Qualified BTS</a></li>
<li><a href="o_fe12b1e2a880e0ce-598.html">17.4.9.5 Writing the DS Interrupt Service Routine</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-599.html">17.5 Last Branch, Interrupt, and Exception Recording (Intel® Core™ 2 Duo and Intel® Atom™ Processors)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-599.html">17.5.1 LBR Stack</a></li>
<li><a href="o_fe12b1e2a880e0ce-600.html">17.5.2 LBR Stack in Intel Atom Processors based on the Silvermont Microarchitecture</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-600.html">17.6 Last Branch, Call Stack, Interrupt, and Exception Recording for Processors based on Goldmont Microarchitecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-601.html">17.7 Last Branch, Interrupt, and Exception Recording for Processors based on Intel® Microarchitecture code name Nehalem</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-602.html">17.7.1 LBR Stack</a></li>
<li><a href="o_fe12b1e2a880e0ce-602.html">17.7.2 Filtering of Last Branch Records</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-603.html">17.8 Last Branch, Interrupt, and Exception Recording for Processors based on Intel® Microarchitecture code name Sandy Bridge</a></li>
<li><a href="o_fe12b1e2a880e0ce-603.html">17.9 Last Branch, Call Stack, Interrupt, and Exception Recording for Processors based on Haswell Microarchitecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-604.html">17.9.1 LBR Stack Enhancement</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-605.html">17.10 Last Branch, Call Stack, Interrupt, and Exception Recording for Processors based on Skylake Microarchitecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-605.html">17.10.1 MSR_LBR_INFO_x MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-606.html">17.10.2 Streamlined Freeze_LBRs_On_PMI Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-606.html">17.10.3 LBR Behavior and Deep C-State</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-606.html">17.11 Last Branch, Interrupt, and Exception Recording (Processors based on Intel NetBurst® Microarchitecture)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-607.html">17.11.1 MSR_DEBUGCTLA MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-608.html">17.11.2 LBR Stack for Processors Based on Intel NetBurst® Microarchitecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-609.html">17.11.3 Last Exception Records</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-609.html">17.12 Last Branch, Interrupt, and Exception Recording (Intel® Core™ Solo and Intel® Core™ Duo Processors)</a></li>
<li><a href="o_fe12b1e2a880e0ce-611.html">17.13 Last Branch, Interrupt, and Exception Recording (Pentium M Processors)</a></li>
<li><a href="o_fe12b1e2a880e0ce-612.html">17.14 Last Branch, Interrupt, and Exception Recording (P6 Family Processors)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-612.html">17.14.1 DEBUGCTLMSR Register</a></li>
<li><a href="o_fe12b1e2a880e0ce-613.html">17.14.2 Last Branch and Last Exception MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-613.html">17.14.3 Monitoring Branches, Exceptions, and Interrupts</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-614.html">17.15 Time-Stamp Counter</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-615.html">17.15.1 Invariant TSC</a></li>
<li><a href="o_fe12b1e2a880e0ce-615.html">17.15.2 IA32_TSC_AUX Register and RDTSCP Support</a></li>
<li><a href="o_fe12b1e2a880e0ce-615.html">17.15.3 Time-Stamp Counter Adjustment</a></li>
<li><a href="o_fe12b1e2a880e0ce-616.html">17.15.4 Invariant Time-Keeping</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-616.html">17.16 Intel® Resource Director Technology (Intel® RDT) Monitoring Features</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-617.html">17.16.1 Overview of Cache Monitoring Technology and Memory Bandwidth Monitoring</a></li>
<li><a href="o_fe12b1e2a880e0ce-617.html">17.16.2 Enabling Monitoring: Usage Flow</a></li>
<li><a href="o_fe12b1e2a880e0ce-618.html">17.16.3 Enumeration and Detecting Support of Cache Monitoring Technology and Memory Bandwidth Monitoring</a></li>
<li><a href="o_fe12b1e2a880e0ce-618.html">17.16.4 Monitoring Resource Type and Capability Enumeration</a></li>
<li><a href="o_fe12b1e2a880e0ce-619.html">17.16.5 Feature-Specific Enumeration</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-620.html">17.16.5.1 Cache Monitoring Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-620.html">17.16.5.2 Memory Bandwidth Monitoring</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-620.html">17.16.6 Monitoring Resource RMID Association</a></li>
<li><a href="o_fe12b1e2a880e0ce-621.html">17.16.7 Monitoring Resource Selection and Reporting Infrastructure</a></li>
<li><a href="o_fe12b1e2a880e0ce-622.html">17.16.8 Monitoring Programming Considerations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-623.html">17.16.8.1 Monitoring Dynamic Configuration</a></li>
<li><a href="o_fe12b1e2a880e0ce-623.html">17.16.8.2 Monitoring Operation With Power Saving Features</a></li>
<li><a href="o_fe12b1e2a880e0ce-623.html">17.16.8.3 Monitoring Operation with Other Operating Modes</a></li>
<li><a href="o_fe12b1e2a880e0ce-623.html">17.16.8.4 Monitoring Operation with RAS Features</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-623.html">17.17 Intel® Resource Director Technology (Intel® RDT) Allocation Features</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-624.html">17.17.1 Cache Allocation Technology Architecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-627.html">17.17.2 Code and Data Prioritization (CDP) Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-628.html">17.17.3 Enabling Cache Allocation Technology Usage Flow</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-628.html">17.17.3.1 Enumeration and Detection Support of Cache Allocation Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-629.html">17.17.3.2 Cache Allocation Technology: Resource Type and Capability Enumeration</a></li>
<li><a href="o_fe12b1e2a880e0ce-631.html">17.17.3.3 Cache Allocation Technology: Cache Mask Configuration</a></li>
<li><a href="o_fe12b1e2a880e0ce-632.html">17.17.3.4 Class of Service to Cache Mask Association: Common Across Allocation Features</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-632.html">17.17.4 Code and Data Prioritization (CDP): Enumerating and Enabling L3 CDP Technology</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-633.html">17.17.4.1 Mapping Between L3 CDP Masks and CAT Masks</a></li>
<li><a href="o_fe12b1e2a880e0ce-633.html">17.17.4.2 L3 CAT: Disabling CDP</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-633.html">17.17.5 Cache Allocation Technology Programming Considerations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-633.html">17.17.5.1 Cache Allocation Technology Dynamic Configuration</a></li>
<li><a href="o_fe12b1e2a880e0ce-634.html">17.17.5.2 Cache Allocation Technology Operation With Power Saving Features</a></li>
<li><a href="o_fe12b1e2a880e0ce-634.html">17.17.5.3 Cache Allocation Technology Operation with Other Operating Modes</a></li>
<li><a href="o_fe12b1e2a880e0ce-635.html">17.17.5.4 Associating Threads with CAT/CDP Classes of Service</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-637.html">Chapter 18 Performance Monitoring</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-637.html">18.1 Performance Monitoring Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-638.html">18.2 Architectural Performance Monitoring</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-638.html">18.2.1 Architectural Performance Monitoring Version 1</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-639.html">18.2.1.1 Architectural Performance Monitoring Version 1 Facilities</a></li>
<li><a href="o_fe12b1e2a880e0ce-640.html">18.2.1.2 Pre-defined Architectural Performance Events</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-642.html">18.2.2 Architectural Performance Monitoring Version 2</a></li>
<li><a href="o_fe12b1e2a880e0ce-644.html">18.2.3 Architectural Performance Monitoring Version 3</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-646.html">18.2.3.1 AnyThread Counting and Software Evolution</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-647.html">18.2.4 Architectural Performance Monitoring Version 4</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-647.html">18.2.4.1 Enhancement in IA32_PERF_GLOBAL_STATUS</a></li>
<li><a href="o_fe12b1e2a880e0ce-648.html">18.2.4.2 IA32_PERF_GLOBAL_STATUS_RESET and IA32_PERF_GLOBAL_STATUS_SET MSRS</a></li>
<li><a href="o_fe12b1e2a880e0ce-649.html">18.2.4.3 IA32_PERF_GLOBAL_INUSE MSR</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-650.html">18.2.5 Full-Width Writes to Performance Counter Registers</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-651.html">18.3 Performance Monitoring (Intel® Core™ Solo and Intel® Core™ Duo Processors)</a></li>
<li><a href="o_fe12b1e2a880e0ce-652.html">18.4 Performance Monitoring (Processors Based on Intel® Core™ Microarchitecture)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-653.html">18.4.1 Fixed-function Performance Counters</a></li>
<li><a href="o_fe12b1e2a880e0ce-654.html">18.4.2 Global Counter Control Facilities</a></li>
<li><a href="o_fe12b1e2a880e0ce-656.html">18.4.3 At-Retirement Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-656.html">18.4.4 Processor Event Based Sampling (PEBS)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-657.html">18.4.4.1 Setting up the PEBS Buffer</a></li>
<li><a href="o_fe12b1e2a880e0ce-657.html">18.4.4.2 PEBS Record Format</a></li>
<li><a href="o_fe12b1e2a880e0ce-657.html">18.4.4.3 Writing a PEBS Interrupt Service Routine</a></li>
<li><a href="o_fe12b1e2a880e0ce-658.html">18.4.4.4 Re-configuring PEBS Facilities</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-659.html">18.5 Performance Monitoring (45 nm and 32 nm Intel® Atom™ Processors)</a></li>
<li><a href="o_fe12b1e2a880e0ce-659.html">18.6 Performance Monitoring for Silvermont Microarchitecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-659.html">18.6.1 Enhancements of Performance Monitoring in the Processor Core</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-660.html">18.6.1.1 Processor Event Based Sampling (PEBS)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-661.html">18.6.2 Offcore Response Event</a></li>
<li><a href="o_fe12b1e2a880e0ce-664.html">18.6.3 Average Offcore Request Latency Measurement</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-664.html">18.7 Performance Monitoring for Goldmont Microarchitecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-666.html">18.7.1 Processor Event Based Sampling (PEBS)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-668.html">18.7.1.1 PEBS Data Linear Address Profiling</a></li>
<li><a href="o_fe12b1e2a880e0ce-668.html">18.7.1.2 Reduced Skid PEBS</a></li>
<li><a href="o_fe12b1e2a880e0ce-668.html">18.7.1.3 Enhancements to IA32_PERF_GLOBAL_STATUS.OvfDSBuffer[62]</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-668.html">18.7.2 Offcore Response Event</a></li>
<li><a href="o_fe12b1e2a880e0ce-670.html">18.7.3 Average Offcore Request Latency Measurement</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-670.html">18.8 Performance Monitoring for Processors Based on Intel® Microarchitecture Code Name Nehalem</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-671.html">18.8.1 Enhancements of Performance Monitoring in the Processor Core</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-671.html">18.8.1.1 Processor Event Based Sampling (PEBS)</a></li>
<li><a href="o_fe12b1e2a880e0ce-675.html">18.8.1.2 Load Latency Performance Monitoring Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-677.html">18.8.1.3 Off-core Response Performance Monitoring in the Processor Core</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-678.html">18.8.2 Performance Monitoring Facility in the Uncore</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-678.html">18.8.2.1 Uncore Performance Monitoring Management Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-681.html">18.8.2.2 Uncore Performance Event Configuration Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-682.html">18.8.2.3 Uncore Address/Opcode Match MSR</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-683.html">18.8.3 Intel® Xeon® Processor 7500 Series Performance Monitoring Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-685.html">18.8.4 Performance Monitoring for Processors Based on Intel® Microarchitecture Code Name Westmere</a></li>
<li><a href="o_fe12b1e2a880e0ce-685.html">18.8.5 Intel® Xeon® Processor E7 Family Performance Monitoring Facility</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-686.html">18.9 Performance Monitoring for Processors Based on Intel® Microarchitecture Code Name Sandy Bridge</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-687.html">18.9.1 Global Counter Control Facilities In Intel® Microarchitecture Code Name Sandy Bridge</a></li>
<li><a href="o_fe12b1e2a880e0ce-689.html">18.9.2 Counter Coalescence</a></li>
<li><a href="o_fe12b1e2a880e0ce-689.html">18.9.3 Full Width Writes to Performance Counters</a></li>
<li><a href="o_fe12b1e2a880e0ce-689.html">18.9.4 PEBS Support in Intel® Microarchitecture Code Name Sandy Bridge</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-690.html">18.9.4.1 PEBS Record Format</a></li>
<li><a href="o_fe12b1e2a880e0ce-691.html">18.9.4.2 Load Latency Performance Monitoring Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-692.html">18.9.4.3 Precise Store Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-693.html">18.9.4.4 Precise Distribution of Instructions Retired (PDIR)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-693.html">18.9.5 Off-core Response Performance Monitoring</a></li>
<li><a href="o_fe12b1e2a880e0ce-696.html">18.9.6 Uncore Performance Monitoring Facilities In Intel® Core™ i7-2xxx, Intel® Core™ i5- 2xxx, Intel® Core™ i3-2xxx Processor Series</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-698.html">18.9.6.1 Uncore Performance Monitoring Events</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-698.html">18.9.7 Intel® Xeon® Processor E5 Family Performance Monitoring Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-699.html">18.9.8 Intel® Xeon® Processor E5 Family Uncore Performance Monitoring Facility</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-699.html">18.10 3rd Generation Intel® Core™ Processor Performance Monitoring Facility</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-699.html">18.10.1 Intel® Xeon® Processor E5 v2 and E7 v2 Family Uncore Performance Monitoring Facility</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-700.html">18.11 4th Generation Intel® Core™ Processor Performance Monitoring Facility</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-701.html">18.11.1 Processor Event Based Sampling (PEBS) Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-701.html">18.11.2 PEBS Data Format</a></li>
<li><a href="o_fe12b1e2a880e0ce-702.html">18.11.3 PEBS Data Address Profiling</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-703.html">18.11.3.1 EventingIP Record</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-703.html">18.11.4 Off-core Response Performance Monitoring</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-705.html">18.11.4.1 Off-core Response Performance Monitoring in Intel Xeon Processors E5 v3 Series</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-705.html">18.11.5 Performance Monitoring and Intel® TSX</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-706.html">18.11.5.1 Intel TSX and PEBS Support</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-707.html">18.11.6 Uncore Performance Monitoring Facilities in the 4th Generation Intel® Core™ Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-708.html">18.11.7 Intel® Xeon® Processor E5 v3 Family Uncore Performance Monitoring Facility</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-708.html">18.12 Intel® Core™ M Processor Performance Monitoring Facility</a></li>
<li><a href="o_fe12b1e2a880e0ce-709.html">18.13 6th Generation Intel® Core™ Processor Performance Monitoring Facility</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-710.html">18.13.1 Processor Event Based Sampling (PEBS) Facility</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-711.html">18.13.1.1 PEBS Data Format</a></li>
<li><a href="o_fe12b1e2a880e0ce-712.html">18.13.1.2 PEBS Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-713.html">18.13.1.3 Data Address Profiling</a></li>
<li><a href="o_fe12b1e2a880e0ce-714.html">18.13.1.4 PEBS Facility for Front End Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-715.html">18.13.1.5 FRONTEND_RETIRED</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-715.html">18.13.2 Off-core Response Performance Monitoring</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-717.html">18.14 Intel® Xeon Phi™ Processor 7200/5200/3200 Performance Monitoring</a></li>
<li><a href="o_fe12b1e2a880e0ce-718.html">18.15 Performance Monitoring (Processors Based on Intel NetBurst® Microarchitecture)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-721.html">18.15.1 ESCR MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-722.html">18.15.2 Performance Counters</a></li>
<li><a href="o_fe12b1e2a880e0ce-723.html">18.15.3 CCCR MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-725.html">18.15.4 Debug Store (DS) Mechanism</a></li>
<li><a href="o_fe12b1e2a880e0ce-725.html">18.15.5 Programming the Performance Counters for Non-Retirement Events</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-725.html">18.15.5.1 Selecting Events to Count</a></li>
<li><a href="o_fe12b1e2a880e0ce-727.html">18.15.5.2 Filtering Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-728.html">18.15.5.3 Starting Event Counting</a></li>
<li><a href="o_fe12b1e2a880e0ce-728.html">18.15.5.4 Reading a Performance Counter’s Count</a></li>
<li><a href="o_fe12b1e2a880e0ce-728.html">18.15.5.5 Halting Event Counting</a></li>
<li><a href="o_fe12b1e2a880e0ce-729.html">18.15.5.6 Cascading Counters</a></li>
<li><a href="o_fe12b1e2a880e0ce-730.html">18.15.5.7 EXTENDED CASCADING</a></li>
<li><a href="o_fe12b1e2a880e0ce-731.html">18.15.5.8 Generating an Interrupt on Overflow</a></li>
<li><a href="o_fe12b1e2a880e0ce-731.html">18.15.5.9 Counter Usage Guideline</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-731.html">18.15.6 At-Retirement Counting</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-732.html">18.15.6.1 Using At-Retirement Counting</a></li>
<li><a href="o_fe12b1e2a880e0ce-733.html">18.15.6.2 Tagging Mechanism for Front_end_event</a></li>
<li><a href="o_fe12b1e2a880e0ce-733.html">18.15.6.3 Tagging Mechanism For Execution_event</a></li>
<li><a href="o_fe12b1e2a880e0ce-733.html">18.15.6.4 Tagging Mechanism for Replay_event</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-734.html">18.15.7 Processor Event-Based Sampling (PEBS)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-734.html">18.15.7.1 Detection of the Availability of the PEBS Facilities</a></li>
<li><a href="o_fe12b1e2a880e0ce-734.html">18.15.7.2 Setting Up the DS Save Area</a></li>
<li><a href="o_fe12b1e2a880e0ce-734.html">18.15.7.3 Setting Up the PEBS Buffer</a></li>
<li><a href="o_fe12b1e2a880e0ce-734.html">18.15.7.4 Writing a PEBS Interrupt Service Routine</a></li>
<li><a href="o_fe12b1e2a880e0ce-735.html">18.15.7.5 Other DS Mechanism Implications</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-735.html">18.15.8 Operating System Implications</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-735.html">18.16 Performance Monitoring and Intel Hyper-Threading Technology in Processors Based on Intel NetBurst® Microarchitecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-735.html">18.16.1 ESCR MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-736.html">18.16.2 CCCR MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-738.html">18.16.3 IA32_PEBS_ENABLE MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-738.html">18.16.4 Performance Monitoring Events</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-739.html">18.17 Counting Clocks</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-740.html">18.17.1 Non-Halted Clockticks</a></li>
<li><a href="o_fe12b1e2a880e0ce-740.html">18.17.2 Non-Sleep Clockticks</a></li>
<li><a href="o_fe12b1e2a880e0ce-741.html">18.17.3 Incrementing the Time-Stamp Counter</a></li>
<li><a href="o_fe12b1e2a880e0ce-741.html">18.17.4 Non-Halted Reference Clockticks</a></li>
<li><a href="o_fe12b1e2a880e0ce-741.html">18.17.5 Cycle Counting and Opportunistic Processor Operation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-741.html">18.18 IA32_PERF_CAPABILITIES MSR Enumeration</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-742.html">18.18.1 Filtering of SMM Handler Overhead</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-742.html">18.19 Performance Monitoring and Dual-Core Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-743.html">18.20 Performance Monitoring on 64-bit Intel Xeon Processor MP with Up to 8-MByte L3 Cache</a></li>
<li><a href="o_fe12b1e2a880e0ce-745.html">18.21 Performance Monitoring on L3 and Caching Bus Controller sub-systems</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-747.html">18.21.1 Overview of Performance Monitoring with L3/Caching Bus Controller</a></li>
<li><a href="o_fe12b1e2a880e0ce-748.html">18.21.2 GBSQ Event Interface</a></li>
<li><a href="o_fe12b1e2a880e0ce-749.html">18.21.3 GSNPQ Event Interface</a></li>
<li><a href="o_fe12b1e2a880e0ce-750.html">18.21.4 FSB Event Interface</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-750.html">18.21.4.1 FSB Sub-Event Mask Interface</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-751.html">18.21.5 Common Event Control Interface</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-751.html">18.22 Performance Monitoring (P6 Family Processor)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-752.html">18.22.1 PerfEvtSel0 and PerfEvtSel1 MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-753.html">18.22.2 PerfCtr0 and PerfCtr1 MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-753.html">18.22.3 Starting and Stopping the Performance-Monitoring Counters</a></li>
<li><a href="o_fe12b1e2a880e0ce-754.html">18.22.4 Event and Time-Stamp Monitoring Software</a></li>
<li><a href="o_fe12b1e2a880e0ce-754.html">18.22.5 Monitoring Counter Overflow</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-754.html">18.23 Performance Monitoring (Pentium Processors)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-755.html">18.23.1 Control and Event Select Register (CESR)</a></li>
<li><a href="o_fe12b1e2a880e0ce-756.html">18.23.2 Use of the Performance-Monitoring Pins</a></li>
<li><a href="o_fe12b1e2a880e0ce-756.html">18.23.3 Events Counted</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-757.html">Chapter 19 Performance-Monitoring Events</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-758.html">19.1 Architectural Performance-Monitoring Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-759.html">19.2 Performance Monitoring Events for 6th Generation Intel® Core™ Processor</a></li>
<li><a href="o_fe12b1e2a880e0ce-769.html">19.3 Performance Monitoring Events for the Intel® Core™ M and 5th Generation Intel® Core™ ProcessorS</a></li>
<li><a href="o_fe12b1e2a880e0ce-777.html">19.4 Performance Monitoring Events for the 4th Generation Intel® Core™ ProcessorS</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-789.html">19.4.1 Performance Monitoring Events in the Processor Core of Intel Xeon Processor E5 v3 Family</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-789.html">19.5 Performance Monitoring Events for 3rd Generation Intel® Core™ ProcessorS</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-798.html">19.5.1 Performance Monitoring Events in the Processor Core of Intel Xeon Processor E5 v2 Family and Intel Xeon Processor E7 v2 Family</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-799.html">19.6 Performance Monitoring Events for 2nd Generation Intel® Core™ i7-2xxx, Intel® Core™ i5-2xxx, Intel® Core™ i3-2xxx Processor Series</a></li>
<li><a href="o_fe12b1e2a880e0ce-813.html">19.7 Performance Monitoring Events for Intel® Core™ i7 Processor Family and Intel® Xeon® Processor Family</a></li>
<li><a href="o_fe12b1e2a880e0ce-841.html">19.8 Performance Monitoring Events for processors based on Intel® microarchitecture Code Name Westmere</a></li>
<li><a href="o_fe12b1e2a880e0ce-872.html">19.9 Performance Monitoring Events for Intel® Xeon® Processor 5200, 5400 Series and Intel® Core™2 Extreme Processors QX 9000 Series</a></li>
<li><a href="o_fe12b1e2a880e0ce-873.html">19.10 Performance Monitoring Events for Intel® Xeon® Processor 3000, 3200, 5100, 5300 Series and Intel® Core™2 Duo ProcessorS</a></li>
<li><a href="o_fe12b1e2a880e0ce-899.html">19.11 Performance Monitoring Events for Processors Based on the Goldmont Microarchitecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-905.html">19.12 Performance Monitoring Events for Processors Based on the Silvermont Microarchitecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-909.html">19.12.1 Performance Monitoring Events for Processors Based on the Airmont Microarchitecture</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-910.html">19.13 Performance Monitoring Events for 45 nm and 32 nm Intel® Atom™ Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-924.html">19.14 Performance Monitoring Events for Intel® Core™ Solo and Intel® Core™ Duo Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-929.html">19.15 Pentium® 4 and Intel® Xeon® Processor Performance- Monitoring Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-958.html">19.16 Performance Monitoring Events for Intel® Pentium® M Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-960.html">19.17 P6 Family Processor Performance-Monitoring Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-969.html">19.18 Pentium Processor Performance-Monitoring Events</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-977.html">Chapter 20 8086 Emulation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-977.html">20.1 Real-Address Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-978.html">20.1.1 Address Translation in Real-Address Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-979.html">20.1.2 Registers Supported in Real-Address Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-979.html">20.1.3 Instructions Supported in Real-Address Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-980.html">20.1.4 Interrupt and Exception Handling</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-981.html">20.2 Virtual-8086 Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-982.html">20.2.1 Enabling Virtual-8086 Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-983.html">20.2.2 Structure of a Virtual-8086 Task</a></li>
<li><a href="o_fe12b1e2a880e0ce-983.html">20.2.3 Paging of Virtual-8086 Tasks</a></li>
<li><a href="o_fe12b1e2a880e0ce-984.html">20.2.4 Protection within a Virtual-8086 Task</a></li>
<li><a href="o_fe12b1e2a880e0ce-984.html">20.2.5 Entering Virtual-8086 Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-985.html">20.2.6 Leaving Virtual-8086 Mode</a></li>
<li><a href="o_fe12b1e2a880e0ce-986.html">20.2.7 Sensitive Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-986.html">20.2.8 Virtual-8086 Mode I/O</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-987.html">20.2.8.1 I/O-Port-Mapped I/O</a></li>
<li><a href="o_fe12b1e2a880e0ce-987.html">20.2.8.2 Memory-Mapped I/O</a></li>
<li><a href="o_fe12b1e2a880e0ce-987.html">20.2.8.3 Special I/O Buffers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-987.html">20.3 Interrupt and Exception Handling in Virtual-8086 Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-988.html">20.3.1 Class 1—Hardware Interrupt and Exception Handling in Virtual-8086 Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-988.html">20.3.1.1 Handling an Interrupt or Exception Through a Protected-Mode Trap or Interrupt Gate</a></li>
<li><a href="o_fe12b1e2a880e0ce-990.html">20.3.1.2 Handling an Interrupt or Exception With an 8086 Program Interrupt or Exception Handler</a></li>
<li><a href="o_fe12b1e2a880e0ce-990.html">20.3.1.3 Handling an Interrupt or Exception Through a Task Gate</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-991.html">20.3.2 Class 2—Maskable Hardware Interrupt Handling in Virtual-8086 Mode Using the Virtual Interrupt Mechanism</a></li>
<li><a href="o_fe12b1e2a880e0ce-992.html">20.3.3 Class 3—Software Interrupt Handling in Virtual-8086 Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-994.html">20.3.3.1 Method 1: Software Interrupt Handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-994.html">20.3.3.2 Methods 2 and 3: Software Interrupt Handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-995.html">20.3.3.3 Method 4: Software Interrupt Handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-995.html">20.3.3.4 Method 5: Software Interrupt Handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-995.html">20.3.3.5 Method 6: Software Interrupt Handling</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-996.html">20.4 Protected-Mode Virtual Interrupts</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-997.html">Chapter 21 Mixing 16-Bit and 32-Bit Code</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-997.html">21.1 Defining 16-Bit and 32-Bit Program Modules</a></li>
<li><a href="o_fe12b1e2a880e0ce-998.html">21.2 Mixing 16-Bit and 32-Bit Operations Within a Code Segment</a></li>
<li><a href="o_fe12b1e2a880e0ce-999.html">21.3 Sharing Data Among Mixed-Size Code Segments</a></li>
<li><a href="o_fe12b1e2a880e0ce-999.html">21.4 Transferring Control Among Mixed-Size Code Segments</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1000.html">21.4.1 Code-Segment Pointer Size</a></li>
<li><a href="o_fe12b1e2a880e0ce-1000.html">21.4.2 Stack Management for Control Transfer</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1001.html">21.4.2.1 Controlling the Operand-Size Attribute For a Call</a></li>
<li><a href="o_fe12b1e2a880e0ce-1002.html">21.4.2.2 Passing Parameters With a Gate</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1002.html">21.4.3 Interrupt Control Transfers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1002.html">21.4.4 Parameter Translation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1002.html">21.4.5 Writing Interface Procedures</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1005.html">Chapter 22 Architecture Compatibility</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1005.html">22.1 Processor Families and Categories</a></li>
<li><a href="o_fe12b1e2a880e0ce-1006.html">22.2 Reserved Bits</a></li>
<li><a href="o_fe12b1e2a880e0ce-1006.html">22.3 Enabling New Functions and Modes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1006.html">22.4 Detecting the Presence of New Features Through Software</a></li>
<li><a href="o_fe12b1e2a880e0ce-1006.html">22.5 Intel MMX Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-1007.html">22.6 Streaming SIMD Extensions (SSE)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1007.html">22.7 Streaming SIMD Extensions 2 (SSE2)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1007.html">22.8 Streaming SIMD Extensions 3 (SSE3)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1007.html">22.9 Additional Streaming SIMD Extensions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1007.html">22.10 Intel Hyper-Threading Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-1008.html">22.11 Multi-Core Technology</a></li>
<li><a href="o_fe12b1e2a880e0ce-1008.html">22.12 Specific Features of Dual-Core Processor</a></li>
<li><a href="o_fe12b1e2a880e0ce-1008.html">22.13 New Instructions In the Pentium and Later IA-32 Processors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1008.html">22.13.1 Instructions Added Prior to the Pentium Processor</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1009.html">22.14 Obsolete Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1009.html">22.15 Undefined Opcodes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1009.html">22.16 New Flags in the EFLAGS Register</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1010.html">22.16.1 Using EFLAGS Flags to Distinguish Between 32-Bit IA-32 Processors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1010.html">22.17 Stack Operations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1010.html">22.17.1 PUSH SP</a></li>
<li><a href="o_fe12b1e2a880e0ce-1010.html">22.17.2 EFLAGS Pushed on the Stack</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1010.html">22.18 x87 FPU</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1011.html">22.18.1 Control Register CR0 Flags</a></li>
<li><a href="o_fe12b1e2a880e0ce-1011.html">22.18.2 x87 FPU Status Word</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1011.html">22.18.2.1 Condition Code Flags (C0 through C3)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1012.html">22.18.2.2 Stack Fault Flag</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1012.html">22.18.3 x87 FPU Control Word</a></li>
<li><a href="o_fe12b1e2a880e0ce-1012.html">22.18.4 x87 FPU Tag Word</a></li>
<li><a href="o_fe12b1e2a880e0ce-1012.html">22.18.5 Data Types</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1012.html">22.18.5.1 NaNs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1013.html">22.18.5.2 Pseudo-zero, Pseudo-NaN, Pseudo-infinity, and Unnormal Formats</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1013.html">22.18.6 Floating-Point Exceptions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1013.html">22.18.6.1 Denormal Operand Exception (#D)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1013.html">22.18.6.2 Numeric Overflow Exception (#O)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1014.html">22.18.6.3 Numeric Underflow Exception (#U)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1014.html">22.18.6.4 Exception Precedence</a></li>
<li><a href="o_fe12b1e2a880e0ce-1014.html">22.18.6.5 CS and EIP For FPU Exceptions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1014.html">22.18.6.6 FPU Error Signals</a></li>
<li><a href="o_fe12b1e2a880e0ce-1014.html">22.18.6.7 Assertion of the FERR# Pin</a></li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.6.8 Invalid Operation Exception On Denormals</a></li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.6.9 Alignment Check Exceptions (#AC)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.6.10 Segment Not Present Exception During FLDENV</a></li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.6.11 Device Not Available Exception (#NM)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.6.12 Coprocessor Segment Overrun Exception</a></li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.6.13 General Protection Exception (#GP)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.6.14 Floating-Point Error Exception (#MF)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1015.html">22.18.7 Changes to Floating-Point Instructions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.1 FDIV, FPREM, and FSQRT Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.2 FSCALE Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.3 FPREM1 Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.4 FPREM Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.5 FUCOM, FUCOMP, and FUCOMPP Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.6 FPTAN Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.7 Stack Overflow</a></li>
<li><a href="o_fe12b1e2a880e0ce-1016.html">22.18.7.8 FSIN, FCOS, and FSINCOS Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1017.html">22.18.7.9 FPATAN Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1017.html">22.18.7.10 F2XM1 Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1017.html">22.18.7.11 FLD Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1017.html">22.18.7.12 FXTRACT Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1017.html">22.18.7.13 Load Constant Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1018.html">22.18.7.14 FSETPM Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1018.html">22.18.7.15 FXAM Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1018.html">22.18.7.16 FSAVE and FSTENV Instructions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1018.html">22.18.8 Transcendental Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1018.html">22.18.9 Obsolete Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1018.html">22.18.10 WAIT/FWAIT Prefix Differences</a></li>
<li><a href="o_fe12b1e2a880e0ce-1018.html">22.18.11 Operands Split Across Segments and/or Pages</a></li>
<li><a href="o_fe12b1e2a880e0ce-1019.html">22.18.12 FPU Instruction Synchronization</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1019.html">22.19 Serializing Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1019.html">22.20 FPU and Math Coprocessor Initialization</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1019.html">22.20.1 Intel® 387 and Intel® 287 Math Coprocessor Initialization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1019.html">22.20.2 Intel486 SX Processor and Intel 487 SX Math Coprocessor Initialization</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1020.html">22.21 Control Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1022.html">22.22 Memory Management Facilities</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1022.html">22.22.1 New Memory Management Control Flags</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1022.html">22.22.1.1 Physical Memory Addressing Extension</a></li>
<li><a href="o_fe12b1e2a880e0ce-1022.html">22.22.1.2 Global Pages</a></li>
<li><a href="o_fe12b1e2a880e0ce-1022.html">22.22.1.3 Larger Page Sizes</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1022.html">22.22.2 CD and NW Cache Control Flags</a></li>
<li><a href="o_fe12b1e2a880e0ce-1022.html">22.22.3 Descriptor Types and Contents</a></li>
<li><a href="o_fe12b1e2a880e0ce-1023.html">22.22.4 Changes in Segment Descriptor Loads</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1023.html">22.23 Debug Facilities</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1023.html">22.23.1 Differences in Debug Register DR6</a></li>
<li><a href="o_fe12b1e2a880e0ce-1023.html">22.23.2 Differences in Debug Register DR7</a></li>
<li><a href="o_fe12b1e2a880e0ce-1023.html">22.23.3 Debug Registers DR4 and DR5</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1023.html">22.24 Recognition of Breakpoints</a></li>
<li><a href="o_fe12b1e2a880e0ce-1024.html">22.25 Exceptions and/or Exception Conditions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1025.html">22.25.1 Machine-Check Architecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-1025.html">22.25.2 Priority of Exceptions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1025.html">22.25.3 Exception Conditions of Legacy SIMD Instructions Operating on MMX Registers</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1030.html">22.26 Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1030.html">22.26.1 Interrupt Propagation Delay</a></li>
<li><a href="o_fe12b1e2a880e0ce-1030.html">22.26.2 NMI Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-1030.html">22.26.3 IDT Limit</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1030.html">22.27 Advanced Programmable Interrupt Controller (APIC)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1031.html">22.27.1 Software Visible Differences Between the Local APIC and the 82489DX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1031.html">22.27.2 New Features Incorporated in the Local APIC for the P6 Family and Pentium Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1031.html">22.27.3 New Features Incorporated in the Local APIC of the Pentium 4 and Intel Xeon Processors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1031.html">22.28 Task Switching and TSs</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1032.html">22.28.1 P6 Family and Pentium Processor TSS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1032.html">22.28.2 TSS Selector Writes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1032.html">22.28.3 Order of Reads/Writes to the TSS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1032.html">22.28.4 Using A 16-Bit TSS with 32-Bit Constructs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1032.html">22.28.5 Differences in I/O Map Base Addresses</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1033.html">22.29 Cache Management</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1033.html">22.29.1 Self-Modifying Code with Cache Enabled</a></li>
<li><a href="o_fe12b1e2a880e0ce-1034.html">22.29.2 Disabling the L3 Cache</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1034.html">22.30 Paging</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1034.html">22.30.1 Large Pages</a></li>
<li><a href="o_fe12b1e2a880e0ce-1034.html">22.30.2 PCD and PWT Flags</a></li>
<li><a href="o_fe12b1e2a880e0ce-1035.html">22.30.3 Enabling and Disabling Paging</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1035.html">22.31 Stack Operations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1035.html">22.31.1 Selector Pushes and Pops</a></li>
<li><a href="o_fe12b1e2a880e0ce-1035.html">22.31.2 Error Code Pushes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1036.html">22.31.3 Fault Handling Effects on the Stack</a></li>
<li><a href="o_fe12b1e2a880e0ce-1036.html">22.31.4 Interlevel RET/IRET From a 16-Bit Interrupt or Call Gate</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1036.html">22.32 Mixing 16- and 32-Bit Segments</a></li>
<li><a href="o_fe12b1e2a880e0ce-1036.html">22.33 Segment and Address Wraparound</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1037.html">22.33.1 Segment Wraparound</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1037.html">22.34 Store Buffers and Memory Ordering</a></li>
<li><a href="o_fe12b1e2a880e0ce-1038.html">22.35 Bus Locking</a></li>
<li><a href="o_fe12b1e2a880e0ce-1038.html">22.36 Bus Hold</a></li>
<li><a href="o_fe12b1e2a880e0ce-1038.html">22.37 Model-Specific Extensions to the IA-32</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1039.html">22.37.1 Model-Specific Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1039.html">22.37.2 RDMSR and WRMSR Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1039.html">22.37.3 Memory Type Range Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1039.html">22.37.4 Machine-Check Exception and Architecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-1040.html">22.37.5 Performance-Monitoring Counters</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1040.html">22.38 Two Ways to Run Intel 286 Processor Tasks</a></li>
<li><a href="o_fe12b1e2a880e0ce-1040.html">22.39 Initial State of Pentium, Pentium Pro and Pentium 4 Processors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1043.html">Chapter 23 Introduction to Virtual Machine Extensions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1043.html">23.1 Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1043.html">23.2 Virtual Machine Architecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-1043.html">23.3 Introduction to VMX Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1044.html">23.4 Life Cycle of VMM Software</a></li>
<li><a href="o_fe12b1e2a880e0ce-1044.html">23.5 Virtual-Machine Control Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-1044.html">23.6 Discovering Support for VMX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1045.html">23.7 Enabling and Entering VMX Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1045.html">23.8 Restrictions on VMX Operation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1047.html">Chapter 24 Virtual Machine Control Structures</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1047.html">24.1 Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1048.html">24.2 Format of the VMCS Region</a></li>
<li><a href="o_fe12b1e2a880e0ce-1049.html">24.3 Organization of VMCS Data</a></li>
<li><a href="o_fe12b1e2a880e0ce-1050.html">24.4 Guest-State Area</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1050.html">24.4.1 Guest Register State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1051.html">24.4.2 Guest Non-Register State</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1054.html">24.5 Host-State Area</a></li>
<li><a href="o_fe12b1e2a880e0ce-1054.html">24.6 VM-Execution Control Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1054.html">24.6.1 Pin-Based VM-Execution Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1055.html">24.6.2 Processor-Based VM-Execution Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1058.html">24.6.3 Exception Bitmap</a></li>
<li><a href="o_fe12b1e2a880e0ce-1058.html">24.6.4 I/O-Bitmap Addresses</a></li>
<li><a href="o_fe12b1e2a880e0ce-1058.html">24.6.5 Time-Stamp Counter Offset and Multiplier</a></li>
<li><a href="o_fe12b1e2a880e0ce-1058.html">24.6.6 Guest/Host Masks and Read Shadows for CR0 and CR4</a></li>
<li><a href="o_fe12b1e2a880e0ce-1058.html">24.6.7 CR3-Target Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1059.html">24.6.8 Controls for APIC Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1060.html">24.6.9 MSR-Bitmap Address</a></li>
<li><a href="o_fe12b1e2a880e0ce-1060.html">24.6.10 Executive-VMCS Pointer</a></li>
<li><a href="o_fe12b1e2a880e0ce-1061.html">24.6.11 Extended-Page-Table Pointer (EPTP)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1061.html">24.6.12 Virtual-Processor Identifier (VPID)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1061.html">24.6.13 Controls for PAUSE-Loop Exiting</a></li>
<li><a href="o_fe12b1e2a880e0ce-1062.html">24.6.14 VM-Function Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1062.html">24.6.15 VMCS Shadowing Bitmap Addresses</a></li>
<li><a href="o_fe12b1e2a880e0ce-1062.html">24.6.16 ENCLS-Exiting Bitmap</a></li>
<li><a href="o_fe12b1e2a880e0ce-1062.html">24.6.17 Control Field for Page-Modification Logging</a></li>
<li><a href="o_fe12b1e2a880e0ce-1062.html">24.6.18 Controls for Virtualization Exceptions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1063.html">24.6.19 XSS-Exiting Bitmap</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1063.html">24.7 VM-Exit Control Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1063.html">24.7.1 VM-Exit Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1064.html">24.7.2 VM-Exit Controls for MSRs</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1064.html">24.8 VM-Entry Control Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1065.html">24.8.1 VM-Entry Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1065.html">24.8.2 VM-Entry Controls for MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1066.html">24.8.3 VM-Entry Controls for Event Injection</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1067.html">24.9 VM-Exit Information Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1067.html">24.9.1 Basic VM-Exit Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-1068.html">24.9.2 Information for VM Exits Due to Vectored Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-1068.html">24.9.3 Information for VM Exits That Occur During Event Delivery</a></li>
<li><a href="o_fe12b1e2a880e0ce-1069.html">24.9.4 Information for VM Exits Due to Instruction Execution</a></li>
<li><a href="o_fe12b1e2a880e0ce-1069.html">24.9.5 VM-Instruction Error Field</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1070.html">24.10 VMCS Types: Ordinary and Shadow</a></li>
<li><a href="o_fe12b1e2a880e0ce-1070.html">24.11 Software Use of the VMCS and Related Structures</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1070.html">24.11.1 Software Use of Virtual-Machine Control Structures</a></li>
<li><a href="o_fe12b1e2a880e0ce-1071.html">24.11.2 VMREAD, VMWRITE, and Encodings of VMCS Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1073.html">24.11.3 Initializing a VMCS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1073.html">24.11.4 Software Access to Related Structures</a></li>
<li><a href="o_fe12b1e2a880e0ce-1073.html">24.11.5 VMXON Region</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1075.html">Chapter 25 VMX Non-Root Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1075.html">25.1 Instructions That Cause VM Exits</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1075.html">25.1.1 Relative Priority of Faults and VM Exits</a></li>
<li><a href="o_fe12b1e2a880e0ce-1076.html">25.1.2 Instructions That Cause VM Exits Unconditionally</a></li>
<li><a href="o_fe12b1e2a880e0ce-1076.html">25.1.3 Instructions That Cause VM Exits Conditionally</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1079.html">25.2 Other Causes of VM Exits</a></li>
<li><a href="o_fe12b1e2a880e0ce-1080.html">25.3 Changes to Instruction Behavior in VMX Non-Root Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1084.html">25.4 Other Changes in VMX Non-Root Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1084.html">25.4.1 Event Blocking</a></li>
<li><a href="o_fe12b1e2a880e0ce-1084.html">25.4.2 Treatment of Task Switches</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1085.html">25.5 Features Specific to VMX Non-Root Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1085.html">25.5.1 VMX-Preemption Timer</a></li>
<li><a href="o_fe12b1e2a880e0ce-1086.html">25.5.2 Monitor Trap Flag</a></li>
<li><a href="o_fe12b1e2a880e0ce-1087.html">25.5.3 Translation of Guest-Physical Addresses Using EPT</a></li>
<li><a href="o_fe12b1e2a880e0ce-1087.html">25.5.4 APIC Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1087.html">25.5.5 VM Functions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1087.html">25.5.5.1 Enabling VM Functions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1087.html">25.5.5.2 General Operation of the VMFUNC Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1088.html">25.5.5.3 EPTP Switching</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1089.html">25.5.6 Virtualization Exceptions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1089.html">25.5.6.1 Convertible EPT Violations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1090.html">25.5.6.2 Virtualization-Exception Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-1090.html">25.5.6.3 Delivery of Virtualization Exceptions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1091.html">25.6 Unrestricted Guests</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1093.html">Chapter 26 VM Entries</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1094.html">26.1 Basic VM-Entry Checks</a></li>
<li><a href="o_fe12b1e2a880e0ce-1094.html">26.2 Checks on VMX Controls and Host-State Area</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1094.html">26.2.1 Checks on VMX Controls</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1094.html">26.2.1.1 VM-Execution Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1097.html">26.2.1.2 VM-Exit Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1097.html">26.2.1.3 VM-Entry Control Fields</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1098.html">26.2.2 Checks on Host Control Registers and MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1099.html">26.2.3 Checks on Host Segment and Descriptor-Table Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1099.html">26.2.4 Checks Related to Address-Space Size</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1100.html">26.3 Checking and Loading Guest State</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1100.html">26.3.1 Checks on the Guest State Area</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1100.html">26.3.1.1 Checks on Guest Control Registers, Debug Registers, and MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1101.html">26.3.1.2 Checks on Guest Segment Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1103.html">26.3.1.3 Checks on Guest Descriptor-Table Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1103.html">26.3.1.4 Checks on Guest RIP and RFLAGS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1104.html">26.3.1.5 Checks on Guest Non-Register State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1106.html">26.3.1.6 Checks on Guest Page-Directory-Pointer-Table Entries</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1106.html">26.3.2 Loading Guest State</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1107.html">26.3.2.1 Loading Guest Control Registers, Debug Registers, and MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1108.html">26.3.2.2 Loading Guest Segment Registers and Descriptor-Table Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1108.html">26.3.2.3 Loading Guest RIP, RSP, and RFLAGS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1109.html">26.3.2.4 Loading Page-Directory-Pointer-Table Entries</a></li>
<li><a href="o_fe12b1e2a880e0ce-1109.html">26.3.2.5 Updating Non-Register State</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1109.html">26.3.3 Clearing Address-Range Monitoring</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1109.html">26.4 Loading MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1110.html">26.5 Event Injection</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1110.html">26.5.1 Vectored-Event Injection</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1110.html">26.5.1.1 Details of Vectored-Event Injection</a></li>
<li><a href="o_fe12b1e2a880e0ce-1112.html">26.5.1.2 VM Exits During Event Injection</a></li>
<li><a href="o_fe12b1e2a880e0ce-1112.html">26.5.1.3 Event Injection for VM Entries to Real-Address Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1113.html">26.5.2 Injection of Pending MTF VM Exits</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1113.html">26.6 Special Features of VM Entry</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1113.html">26.6.1 Interruptibility State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1114.html">26.6.2 Activity State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1114.html">26.6.3 Delivery of Pending Debug Exceptions after VM Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1115.html">26.6.4 VMX-Preemption Timer</a></li>
<li><a href="o_fe12b1e2a880e0ce-1115.html">26.6.5 Interrupt-Window Exiting and Virtual-Interrupt Delivery</a></li>
<li><a href="o_fe12b1e2a880e0ce-1115.html">26.6.6 NMI-Window Exiting</a></li>
<li><a href="o_fe12b1e2a880e0ce-1116.html">26.6.7 VM Exits Induced by the TPR Threshold</a></li>
<li><a href="o_fe12b1e2a880e0ce-1116.html">26.6.8 Pending MTF VM Exits</a></li>
<li><a href="o_fe12b1e2a880e0ce-1116.html">26.6.9 VM Entries and Advanced Debugging Features</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1117.html">26.7 VM-Entry Failures During or After Loading Guest State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1117.html">26.8 Machine-Check Events During VM Entry</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1119.html">Chapter 27 VM Exits</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1119.html">27.1 Architectural State Before a VM Exit</a></li>
<li><a href="o_fe12b1e2a880e0ce-1122.html">27.2 Recording VM-Exit Information and Updating VM-Entry Control Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1122.html">27.2.1 Basic VM-Exit Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-1128.html">27.2.2 Information for VM Exits Due to Vectored Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-1129.html">27.2.3 Information for VM Exits During Event Delivery</a></li>
<li><a href="o_fe12b1e2a880e0ce-1130.html">27.2.4 Information for VM Exits Due to Instruction Execution</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1138.html">27.3 Saving Guest State</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1138.html">27.3.1 Saving Control Registers, Debug Registers, and MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1139.html">27.3.2 Saving Segment Registers and Descriptor-Table Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1139.html">27.3.3 Saving RIP, RSP, and RFLAGS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1141.html">27.3.4 Saving Non-Register State</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1142.html">27.4 Saving MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1143.html">27.5 Loading Host State</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1143.html">27.5.1 Loading Host Control Registers, Debug Registers, MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1144.html">27.5.2 Loading Host Segment and Descriptor-Table Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1146.html">27.5.3 Loading Host RIP, RSP, and RFLAGS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1146.html">27.5.4 Checking and Loading Host Page-Directory-Pointer-Table Entries</a></li>
<li><a href="o_fe12b1e2a880e0ce-1146.html">27.5.5 Updating Non-Register State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1146.html">27.5.6 Clearing Address-Range Monitoring</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1147.html">27.6 Loading MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1147.html">27.7 VMX Aborts</a></li>
<li><a href="o_fe12b1e2a880e0ce-1148.html">27.8 Machine-Check Events During VM Exit</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1149.html">Chapter 28 VMX Support for Address Translation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1149.html">28.1 Virtual Processor Identifiers (VPIDs)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1149.html">28.2 The Extended Page Table Mechanism (EPT)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1149.html">28.2.1 EPT Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1151.html">28.2.2 EPT Translation Mechanism</a></li>
<li><a href="o_fe12b1e2a880e0ce-1155.html">28.2.3 EPT-Induced VM Exits</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1155.html">28.2.3.1 EPT Misconfigurations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1156.html">28.2.3.2 EPT Violations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1158.html">28.2.3.3 Prioritization of EPT Misconfigurations and EPT Violations</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1159.html">28.2.4 Accessed and Dirty Flags for EPT</a></li>
<li><a href="o_fe12b1e2a880e0ce-1159.html">28.2.5 Page-Modification Logging</a></li>
<li><a href="o_fe12b1e2a880e0ce-1160.html">28.2.6 EPT and Memory Typing</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1160.html">28.2.6.1 Memory Type Used for Accessing EPT Paging Structures</a></li>
<li><a href="o_fe12b1e2a880e0ce-1160.html">28.2.6.2 Memory Type Used for Translated Guest-Physical Addresses</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1161.html">28.3 Caching Translation Information</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1161.html">28.3.1 Information That May Be Cached</a></li>
<li><a href="o_fe12b1e2a880e0ce-1162.html">28.3.2 Creating and Using Cached Translation Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-1163.html">28.3.3 Invalidating Cached Translation Information</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1163.html">28.3.3.1 Operations that Invalidate Cached Mappings</a></li>
<li><a href="o_fe12b1e2a880e0ce-1164.html">28.3.3.2 Operations that Need Not Invalidate Cached Mappings</a></li>
<li><a href="o_fe12b1e2a880e0ce-1164.html">28.3.3.3 Guidelines for Use of the INVVPID Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1165.html">28.3.3.4 Guidelines for Use of the INVEPT Instruction</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1167.html">Chapter 29 APIC Virtualization and Virtual Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1167.html">29.1 Virtual APIC State</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1167.html">29.1.1 Virtualized APIC Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1168.html">29.1.2 TPR Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1168.html">29.1.3 PPR Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1169.html">29.1.4 EOI Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1169.html">29.1.5 Self-IPI Virtualization</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1169.html">29.2 Evaluation and Delivery of Virtual Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1169.html">29.2.1 Evaluation of Pending Virtual Interrupts</a></li>
<li><a href="o_fe12b1e2a880e0ce-1170.html">29.2.2 Virtual-Interrupt Delivery</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1171.html">29.3 Virtualizing CR8-Based TPR Accesses</a></li>
<li><a href="o_fe12b1e2a880e0ce-1171.html">29.4 Virtualizing Memory-Mapped APIC Accesses</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1172.html">29.4.1 Priority of APIC-Access VM Exits</a></li>
<li><a href="o_fe12b1e2a880e0ce-1172.html">29.4.2 Virtualizing Reads from the APIC-Access Page</a></li>
<li><a href="o_fe12b1e2a880e0ce-1173.html">29.4.3 Virtualizing Writes to the APIC-Access Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1173.html">29.4.3.1 Determining Whether a Write Access is Virtualized</a></li>
<li><a href="o_fe12b1e2a880e0ce-1174.html">29.4.3.2 APIC-Write Emulation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1175.html">29.4.3.3 APIC-Write VM Exits</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1175.html">29.4.4 Instruction-Specific Considerations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1176.html">29.4.5 Issues Pertaining to Page Size and TLB Management</a></li>
<li><a href="o_fe12b1e2a880e0ce-1176.html">29.4.6 APIC Accesses Not Directly Resulting From Linear Addresses</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1177.html">29.4.6.1 Guest-Physical Accesses to the APIC-Access Page</a></li>
<li><a href="o_fe12b1e2a880e0ce-1177.html">29.4.6.2 Physical Accesses to the APIC-Access Page</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1178.html">29.5 Virtualizing MSR-Based APIC Accesses</a></li>
<li><a href="o_fe12b1e2a880e0ce-1179.html">29.6 Posted-Interrupt Processing</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1181.html">Chapter 30 VMX Instruction Reference</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1181.html">30.1 Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1182.html">30.2 Conventions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1182.html">30.3 VMX Instructions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1183.html">INVEPT— Invalidate Translations Derived from EPT</a></li>
<li><a href="o_fe12b1e2a880e0ce-1186.html">INVVPID— Invalidate Translations Based on VPID</a></li>
<li><a href="o_fe12b1e2a880e0ce-1189.html">VMCALL—Call to VM Monitor</a></li>
<li><a href="o_fe12b1e2a880e0ce-1191.html">VMCLEAR—Clear Virtual-Machine Control Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-1193.html">VMFUNC—Invoke VM function</a></li>
<li><a href="o_fe12b1e2a880e0ce-1194.html">VMLAUNCH/VMRESUME—Launch/Resume Virtual Machine</a></li>
<li><a href="o_fe12b1e2a880e0ce-1196.html">VMPTRLD—Load Pointer to Virtual-Machine Control Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-1198.html">VMPTRST—Store Pointer to Virtual-Machine Control Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-1200.html">VMREAD—Read Field from Virtual-Machine Control Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-1202.html">VMRESUME—Resume Virtual Machine</a></li>
<li><a href="o_fe12b1e2a880e0ce-1203.html">VMWRITE—Write Field to Virtual-Machine Control Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-1205.html">VMXOFF—Leave VMX Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1207.html">VMXON—Enter VMX Operation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1209.html">30.4 VM Instruction Error Numbers</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1211.html">Chapter 31 Virtual-Machine Monitor Programming Considerations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1211.html">31.1 VMX System Programming Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1211.html">31.2 Supporting Processor Operating Modes in Guest Environments</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1211.html">31.2.1 Using Unrestricted Guest Mode</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1212.html">31.3 Managing VMCS Regions and Pointers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1212.html">31.4 Using VMX Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1214.html">31.5 VMM Setup &amp; Tear Down</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1215.html">31.5.1 Algorithms for Determining VMX Capabilities</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1216.html">31.6 Preparation and Launching a Virtual Machine</a></li>
<li><a href="o_fe12b1e2a880e0ce-1217.html">31.7 Handling of VM Exits</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1218.html">31.7.1 Handling VM Exits Due to Exceptions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1218.html">31.7.1.1 Reflecting Exceptions to Guest Software</a></li>
<li><a href="o_fe12b1e2a880e0ce-1219.html">31.7.1.2 Resuming Guest Software after Handling an Exception</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1220.html">31.8 Multi-Processor Considerations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1221.html">31.8.1 Initialization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1221.html">31.8.2 Moving a VMCS Between Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1221.html">31.8.3 Paired Index-Data Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1221.html">31.8.4 External Data Structures</a></li>
<li><a href="o_fe12b1e2a880e0ce-1222.html">31.8.5 CPUID Emulation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1222.html">31.9 32-Bit and 64-Bit Guest Environments</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1222.html">31.9.1 Operating Modes of Guest Environments</a></li>
<li><a href="o_fe12b1e2a880e0ce-1222.html">31.9.2 Handling Widths of VMCS Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1223.html">31.9.2.1 Natural-Width VMCS Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1223.html">31.9.2.2 64-Bit VMCS Fields</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1223.html">31.9.3 IA-32e Mode Hosts</a></li>
<li><a href="o_fe12b1e2a880e0ce-1223.html">31.9.4 IA-32e Mode Guests</a></li>
<li><a href="o_fe12b1e2a880e0ce-1224.html">31.9.5 32-Bit Guests</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1224.html">31.10 Handling Model Specific Registers</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1224.html">31.10.1 Using VM-Execution Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1225.html">31.10.2 Using VM-Exit Controls for MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1225.html">31.10.3 Using VM-Entry Controls for MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1225.html">31.10.4 Handling Special-Case MSRs and Instructions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1226.html">31.10.4.1 Handling IA32_EFER MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-1226.html">31.10.4.2 Handling the SYSENTER and SYSEXIT Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1226.html">31.10.4.3 Handling the SYSCALL and SYSRET Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1226.html">31.10.4.4 Handling the SWAPGS Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1226.html">31.10.4.5 Implementation Specific Behavior on Writing to Certain MSRs</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1227.html">31.10.5 Handling Accesses to Reserved MSR Addresses</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1227.html">31.11 Handling Accesses to Control Registers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1227.html">31.12 Performance Considerations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1227.html">31.13 Use of The VMX-Preemption Timer</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1229.html">Chapter 32 Virtualization of System Resources</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1229.html">32.1 Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1229.html">32.2 Virtualization Support for Debugging Facilities</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1229.html">32.2.1 Debug Exceptions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1230.html">32.3 Memory Virtualization</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1230.html">32.3.1 Processor Operating Modes &amp; Memory Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1230.html">32.3.2 Guest &amp; Host Physical Address Spaces</a></li>
<li><a href="o_fe12b1e2a880e0ce-1231.html">32.3.3 Virtualizing Virtual Memory by Brute Force</a></li>
<li><a href="o_fe12b1e2a880e0ce-1231.html">32.3.4 Alternate Approach to Memory Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1232.html">32.3.5 Details of Virtual TLB Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1233.html">32.3.5.1 Initialization of Virtual TLB</a></li>
<li><a href="o_fe12b1e2a880e0ce-1233.html">32.3.5.2 Response to Page Faults</a></li>
<li><a href="o_fe12b1e2a880e0ce-1235.html">32.3.5.3 Response to Uses of INVLPG</a></li>
<li><a href="o_fe12b1e2a880e0ce-1236.html">32.3.5.4 Response to CR3 Writes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1236.html">32.4 Microcode Update Facility</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1236.html">32.4.1 Early Load of Microcode Updates</a></li>
<li><a href="o_fe12b1e2a880e0ce-1236.html">32.4.2 Late Load of Microcode Updates</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1239.html">Chapter 33 Handling Boundary Conditions in a Virtual Machine Monitor</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1239.html">33.1 Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1239.html">33.2 Interrupt Handling in VMX Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1240.html">33.3 External Interrupt Virtualization</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1241.html">33.3.1 Virtualization of Interrupt Vector Space</a></li>
<li><a href="o_fe12b1e2a880e0ce-1242.html">33.3.2 Control of Platform Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1242.html">33.3.2.1 PIC Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1243.html">33.3.2.2 xAPIC Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1243.html">33.3.2.3 Local APIC Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1244.html">33.3.2.4 I/O APIC Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1244.html">33.3.2.5 Virtualization of Message Signaled Interrupts</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1244.html">33.3.3 Examples of Handling of External Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1244.html">33.3.3.1 Guest Setup</a></li>
<li><a href="o_fe12b1e2a880e0ce-1244.html">33.3.3.2 Processor Treatment of External Interrupt</a></li>
<li><a href="o_fe12b1e2a880e0ce-1245.html">33.3.3.3 Processing of External Interrupts by VMM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1245.html">33.3.3.4 Generation of Virtual Interrupt Events by VMM</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1246.html">33.4 Error Handling by VMM</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1246.html">33.4.1 VM-Exit Failures</a></li>
<li><a href="o_fe12b1e2a880e0ce-1246.html">33.4.2 Machine-Check Considerations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1247.html">33.4.3 MCA Error Handling Guidelines for VMM</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1248.html">33.4.3.1 VMM Error Handling Strategies</a></li>
<li><a href="o_fe12b1e2a880e0ce-1248.html">33.4.3.2 Basic VMM MCA error recovery handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-1248.html">33.4.3.3 Implementation Considerations for the Basic Model</a></li>
<li><a href="o_fe12b1e2a880e0ce-1248.html">33.4.3.4 MCA Virtualization</a></li>
<li><a href="o_fe12b1e2a880e0ce-1249.html">33.4.3.5 Implementation Considerations for the MCA Virtualization Model</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1249.html">33.5 Handling Activity States by VMM</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1251.html">Chapter 34 System Management Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1251.html">34.1 System Management Mode Overview</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1251.html">34.1.1 System Management Mode and VMX Operation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1252.html">34.2 System Management Interrupt (SMI)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1252.html">34.3 Switching Between SMM and the Other Processor Operating Modes</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1252.html">34.3.1 Entering SMM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1253.html">34.3.2 Exiting From SMM</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1253.html">34.4 SMRAM</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1254.html">34.4.1 SMRAM State Save Map</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1256.html">34.4.1.1 SMRAM State Save Map and Intel 64 Architecture</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1258.html">34.4.2 SMRAM Caching</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1259.html">34.4.2.1 System Management Range Registers (SMRR)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1259.html">34.5 SMI Handler Execution Environment</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1259.html">34.5.1 Initial SMM Execution Environment</a></li>
<li><a href="o_fe12b1e2a880e0ce-1260.html">34.5.2 SMI Handler Operating Mode Switching</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1260.html">34.6 Exceptions and Interrupts Within SMM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1261.html">34.7 Managing Synchronous and Asynchronous System Management Interrupts</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1262.html">34.7.1 I/O State Implementation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1263.html">34.8 NMI Handling While in SMM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1263.html">34.9 SMM Revision Identifier</a></li>
<li><a href="o_fe12b1e2a880e0ce-1263.html">34.10 Auto HALT Restart</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1264.html">34.10.1 Executing the HLT Instruction in SMM</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1264.html">34.11 SMBASE Relocation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1265.html">34.12 I/O Instruction Restart</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1266.html">34.12.1 Back-to-Back SMI Interrupts When I/O Instruction Restart Is Being Used</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1266.html">34.13 SMM Multiple-Processor Considerations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1266.html">34.14 Default Treatment of SMIs and SMM with VMX Operation and SMX Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1266.html">34.14.1 Default Treatment of SMI Delivery</a></li>
<li><a href="o_fe12b1e2a880e0ce-1267.html">34.14.2 Default Treatment of RSM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1268.html">34.14.3 Protection of CR4.VMXE in SMM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1268.html">34.14.4 VMXOFF and SMI Unblocking</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1269.html">34.15 Dual-Monitor Treatment of SMIs and SMM</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1269.html">34.15.1 Dual-Monitor Treatment Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1269.html">34.15.2 SMM VM Exits</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1270.html">34.15.2.1 Architectural State Before a VM Exit</a></li>
<li><a href="o_fe12b1e2a880e0ce-1270.html">34.15.2.2 Updating the Current-VMCS and Executive-VMCS Pointers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1270.html">34.15.2.3 Recording VM-Exit Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-1271.html">34.15.2.4 Saving Guest State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1271.html">34.15.2.5 Updating Non-Register State</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1271.html">34.15.3 Operation of the SMM-Transfer Monitor</a></li>
<li><a href="o_fe12b1e2a880e0ce-1272.html">34.15.4 VM Entries that Return from SMM</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1272.html">34.15.4.1 Checks on the Executive-VMCS Pointer Field</a></li>
<li><a href="o_fe12b1e2a880e0ce-1272.html">34.15.4.2 Checks on VM-Execution Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1272.html">34.15.4.3 Checks on VM-Entry Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1273.html">34.15.4.4 Checks on the Guest State Area</a></li>
<li><a href="o_fe12b1e2a880e0ce-1273.html">34.15.4.5 Loading Guest State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1273.html">34.15.4.6 VMX-Preemption Timer</a></li>
<li><a href="o_fe12b1e2a880e0ce-1273.html">34.15.4.7 Updating the Current-VMCS and SMM-Transfer VMCS Pointers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1274.html">34.15.4.8 VM Exits Induced by VM Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1274.html">34.15.4.9 SMI Blocking</a></li>
<li><a href="o_fe12b1e2a880e0ce-1274.html">34.15.4.10 Failures of VM Entries That Return from SMM</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1274.html">34.15.5 Enabling the Dual-Monitor Treatment</a></li>
<li><a href="o_fe12b1e2a880e0ce-1276.html">34.15.6 Activating the Dual-Monitor Treatment</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1276.html">34.15.6.1 Initial Checks</a></li>
<li><a href="o_fe12b1e2a880e0ce-1276.html">34.15.6.2 MSEG Checking</a></li>
<li><a href="o_fe12b1e2a880e0ce-1277.html">34.15.6.3 Updating the Current-VMCS and Executive-VMCS Pointers</a></li>
<li><a href="o_fe12b1e2a880e0ce-1277.html">34.15.6.4 Saving Guest State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1277.html">34.15.6.5 Saving MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1277.html">34.15.6.6 Loading Host State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1279.html">34.15.6.7 Loading MSRs</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1279.html">34.15.7 Deactivating the Dual-Monitor Treatment</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1279.html">34.16 SMI and Processor Extended State Management</a></li>
<li><a href="o_fe12b1e2a880e0ce-1279.html">34.17 Model-Specific System Management Enhancement</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1279.html">34.17.1 SMM Handler Code Access Control</a></li>
<li><a href="o_fe12b1e2a880e0ce-1280.html">34.17.2 SMI Delivery Delay Reporting</a></li>
<li><a href="o_fe12b1e2a880e0ce-1280.html">34.17.3 Blocked SMI Reporting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1281.html">Chapter 35 Model-Specific Registers (MSRs)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1282.html">35.1 Architectural MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1323.html">35.2 MSRs In the Intel® Core™ 2 Processor Family</a></li>
<li><a href="o_fe12b1e2a880e0ce-1337.html">35.3 MSRs In the 45 nm and 32 nm Intel® Atom™ Processor Family</a></li>
<li><a href="o_fe12b1e2a880e0ce-1348.html">35.4 MSRs In Intel Processors Based on Silvermont Microarchitecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1360.html">35.4.1 MSRs with Model-Specific Behavior in the Silvermont Microarchitecture</a></li>
<li><a href="o_fe12b1e2a880e0ce-1363.html">35.4.2 MSRs In Intel Atom Processors Based on Airmont Microarchitecture</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1365.html">35.5 MSRs In Next Generation Intel Atom Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1386.html">35.6 MSRs In the Intel® Microarchitecture Code Name Nehalem</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1404.html">35.6.1 Additional MSRs in the Intel® Xeon® Processor 5500 and 3400 Series</a></li>
<li><a href="o_fe12b1e2a880e0ce-1405.html">35.6.2 Additional MSRs in the Intel® Xeon® Processor 7500 Series</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1420.html">35.7 MSRs In the Intel® Xeon® Processor 5600 Series (Based on Intel® Microarchitecture Code Name Westmere)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1421.html">35.8 MSRs In the Intel® Xeon® Processor E7 Family (Based on Intel® Microarchitecture Code Name Westmere)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1422.html">35.9 MSRs In Intel® Processor Family Based on Intel® Microarchitecture Code Name Sandy Bridge</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1441.html">35.9.1 MSRs In 2nd Generation Intel® Core™ Processor Family (Based on Intel® Microarchitecture Code Name Sandy Bridge)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1446.html">35.9.2 MSRs In Intel® Xeon® Processor E5 Family (Based on Intel® Microarchitecture Code Name Sandy Bridge)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1449.html">35.9.3 Additional Uncore PMU MSRs in the Intel® Xeon® Processor E5 Family</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1452.html">35.10 MSRs In the 3rd Generation Intel® Core™ Processor Family (Based on Intel® microarchitecture code name Ivy Bridge)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1456.html">35.10.1 MSRs In Intel® Xeon® Processor E5 v2 Product Family (Based on Ivy Bridge-E Microarchitecture)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1463.html">35.10.2 Additional MSRs Supported by Intel® Xeon® Processor E7 v2 Family</a></li>
<li><a href="o_fe12b1e2a880e0ce-1466.html">35.10.3 Additional Uncore PMU MSRs in the Intel® Xeon® Processor E5 v2 and E7 v2 Families</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1468.html">35.11 MSRs In the 4th Generation Intel® Core™ Processors (Based on Haswell Microarchitecture)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1473.html">35.11.1 MSRs in 4th Generation Intel® Core™ Processor Family (based on Haswell Microarchitecture)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1484.html">35.11.2 Additional Residency MSRs Supported in 4th Generation Intel® Core™ Processors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1486.html">35.12 MSRs In Intel® Xeon® Processor E5 v3 and E7 v3 Product Family</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1495.html">35.12.1 Additional Uncore PMU MSRs in the Intel® Xeon® Processor E5 v3 Family</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1503.html">35.13 MSRs In Intel® Core™ M Processors and 5th Generation Intel Core Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1506.html">35.14 MSRs In Intel® Xeon® Processors E5 v4 Family</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1516.html">35.14.1 Additional MSRs Supported in the Intel® Xeon® Processor D Product Family</a></li>
<li><a href="o_fe12b1e2a880e0ce-1518.html">35.14.2 Additional MSRs Supported in Intel® Xeon® Processors E5 v4 and E7 v4 Families</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1521.html">35.15 MSRs In the 6th Generation Intel® Core™ Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1541.html">35.16 MSRs In Future Intel® Xeon® Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1544.html">35.17 MSRs In Intel® Xeon Phi™ Processor 3200/5200/7200 Series</a></li>
<li><a href="o_fe12b1e2a880e0ce-1557.html">35.18 MSRs In the Pentium® 4 and Intel® Xeon® Processors</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1582.html">35.18.1 MSRs Unique to Intel® Xeon® Processor MP with L3 Cache</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1584.html">35.19 MSRs In Intel® Core™ Solo and Intel® Core™ Duo Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1593.html">35.20 MSRs In the Pentium M Processor</a></li>
<li><a href="o_fe12b1e2a880e0ce-1599.html">35.21 MSRs In the P6 Family Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1608.html">35.22 MSRs in Pentium Processors</a></li>
<li><a href="o_fe12b1e2a880e0ce-1608.html">35.23 MSR Index</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1685.html">Chapter 36 Intel® Processor Trace</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1685.html">36.1 Overview</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1685.html">36.1.1 Features and Capabilities</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1685.html">36.1.1.1 Packet Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1686.html">36.2 Intel® Processor Trace Operational Model</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1686.html">36.2.1 Change of Flow Instruction (COFI) Tracing</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1687.html">36.2.1.1 Direct Transfer COFI</a></li>
<li><a href="o_fe12b1e2a880e0ce-1687.html">36.2.1.2 Indirect Transfer COFI</a></li>
<li><a href="o_fe12b1e2a880e0ce-1688.html">36.2.1.3 Far Transfer COFI</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1688.html">36.2.2 Software Trace Instrumentation with PTWRITE</a></li>
<li><a href="o_fe12b1e2a880e0ce-1688.html">36.2.3 Power Event Tracing</a></li>
<li><a href="o_fe12b1e2a880e0ce-1688.html">36.2.4 Trace Filtering</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1688.html">36.2.4.1 Filtering by Current Privilege Level (CPL)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1689.html">36.2.4.2 Filtering by CR3</a></li>
<li><a href="o_fe12b1e2a880e0ce-1689.html">36.2.4.3 Filtering by IP</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1690.html">36.2.5 Packet Generation Enable Controls</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1691.html">36.2.5.1 Packet Enable (PacketEn)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1691.html">36.2.5.2 Trigger Enable (TriggerEn)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1691.html">36.2.5.3 Context Enable (ContextEn)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1691.html">36.2.5.4 Branch Enable (BranchEn)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1692.html">36.2.5.5 Filter Enable (FilterEn)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1692.html">36.2.6 Trace Output</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1692.html">36.2.6.1 Single Range Output</a></li>
<li><a href="o_fe12b1e2a880e0ce-1693.html">36.2.6.2 Table of Physical Addresses (ToPA)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1695.html">Single Output Region ToPA Implementation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1695.html">ToPA Table Entry Format</a></li>
<li><a href="o_fe12b1e2a880e0ce-1696.html">ToPA STOP</a></li>
<li><a href="o_fe12b1e2a880e0ce-1696.html">ToPA PMI</a></li>
<li><a href="o_fe12b1e2a880e0ce-1697.html">ToPA PMI and Single Output Region ToPA Implementation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1697.html">ToPA PMI and XSAVES/XRSTORS State Handling</a></li>
<li><a href="o_fe12b1e2a880e0ce-1698.html">ToPA Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1699.html">36.2.6.3 Trace Transport Subsystem</a></li>
<li><a href="o_fe12b1e2a880e0ce-1699.html">36.2.6.4 Restricted Memory Access</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1699.html">Modifications to Restricted Memory Regions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1699.html">36.2.7 Enabling and Configuration MSRs</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1699.html">36.2.7.1 General Considerations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1700.html">36.2.7.2 IA32_RTIT_CTL MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-1703.html">36.2.7.3 Enabling and Disabling Packet Generation with TraceEn</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1703.html">Disabling Packet Generation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1703.html">Other Writes to IA32_RTIT_CTL</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1703.html">36.2.7.4 IA32_RTIT_STATUS MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-1704.html">36.2.7.5 IA32_RTIT_ADDRn_A and IA32_RTIT_ADDRn_B MSRs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1705.html">36.2.7.6 IA32_RTIT_CR3_MATCH MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-1705.html">36.2.7.7 IA32_RTIT_OUTPUT_BASE MSR</a></li>
<li><a href="o_fe12b1e2a880e0ce-1706.html">36.2.7.8 IA32_RTIT_OUTPUT_MASK_PTRS MSR</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1707.html">36.2.8 Interaction of Intel® Processor Trace and Other Processor Features</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1707.html">36.2.8.1 Intel® Transactional Synchronization Extensions (Intel® TSX)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1708.html">36.2.8.2 Virtual-Machine Extensions (VMX)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1708.html">36.2.8.3 Intel Software Guard Extensions (SGX)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1709.html">36.2.8.4 SENTER/ENTERACCS and ACM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1709.html">36.2.8.5 Intel® Memory Protection Extensions (Intel® MPX)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1709.html">36.3 Configuration and programming Guideline</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1709.html">36.3.1 Detection of Intel Processor Trace and Capability Enumeration</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1713.html">36.3.1.1 Packet Decoding of RIP versus LIP</a></li>
<li><a href="o_fe12b1e2a880e0ce-1713.html">36.3.1.2 Model Specific Capability Restrictions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1713.html">36.3.2 Enabling and Configuration of Trace Packet Generation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1713.html">36.3.2.1 Enabling Packet Generation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1714.html">36.3.2.2 Disabling Packet Generation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1714.html">36.3.3 Flushing Trace Output</a></li>
<li><a href="o_fe12b1e2a880e0ce-1714.html">36.3.4 Warm Reset</a></li>
<li><a href="o_fe12b1e2a880e0ce-1714.html">36.3.5 Context Switch Consideration</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1714.html">36.3.5.1 Manual Trace Configuration Context Switch</a></li>
<li><a href="o_fe12b1e2a880e0ce-1715.html">36.3.5.2 Trace Configuration Context Switch Using XSAVES/XRSTORS</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1715.html">36.3.6 Cycle-Accurate Mode</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1716.html">36.3.6.1 Cycle Counter</a></li>
<li><a href="o_fe12b1e2a880e0ce-1716.html">36.3.6.2 Cycle Packet Semantics</a></li>
<li><a href="o_fe12b1e2a880e0ce-1717.html">36.3.6.3 Cycle Thresholds</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1717.html">36.3.7 Decoder Synchronization (PSB+)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1718.html">36.3.8 Internal Buffer Overflow</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1718.html">36.3.8.1 Overflow Impact on Enables</a></li>
<li><a href="o_fe12b1e2a880e0ce-1718.html">36.3.8.2 Overflow Impact on Timing Packets</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1719.html">36.3.9 Operational Errors</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1719.html">36.4 Trace Packets and Data Types</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1719.html">36.4.1 Packet Relationships and Ordering</a></li>
<li><a href="o_fe12b1e2a880e0ce-1720.html">36.4.2 Packet Definitions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1720.html">36.4.2.1 Taken/Not-taken (TNT) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1722.html">36.4.2.2 Target IP (TIP) Packet</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1722.html">IP Compression</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1724.html">36.4.2.3 Deferred TIPs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1725.html">36.4.2.4 Packet Generation Enable (TIP.PGE)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1726.html">36.4.2.5 Packet Generation Disable (TIP.PGD)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1727.html">36.4.2.6 Flow Update (FUP) Packet</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1728.html">FUP IP Payload</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1729.html">36.4.2.7 Paging Information (PIP) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1730.html">36.4.2.8 MODE Packets</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1730.html">MODE.Exec Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1731.html">MODE.TSX Packet</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1732.html">36.4.2.9 TraceStop Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1732.html">36.4.2.10 Core:Bus Ratio (CBR) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1733.html">36.4.2.11 Timestamp Counter (TSC) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1734.html">36.4.2.12 Mini Time Counter (MTC) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1735.html">36.4.2.13 TSC/MTC Alignment (TMA) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1736.html">36.4.2.14 Cycle Count Packet (CYC) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1737.html">36.4.2.15 VMCS Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1738.html">36.4.2.16 Overflow (OVF) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1738.html">36.4.2.17 Packet Stream Boundary (PSB) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1739.html">36.4.2.18 PSBEND Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1740.html">36.4.2.19 Maintenance (MNT) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1740.html">36.4.2.20 PAD Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1741.html">36.4.2.21 PTWRITE Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1742.html">36.4.2.22 Execution Stop (EXSTOP) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1743.html">36.4.2.23 MWAIT Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1744.html">36.4.2.24 Power Entry (PWRE) Packet</a></li>
<li><a href="o_fe12b1e2a880e0ce-1745.html">36.4.2.25 Power Exit (PWRX) Packet</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1745.html">36.5 Tracing in VMX Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1746.html">36.5.1 VMX-Specific Packets and VMCS Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1747.html">36.5.2 Managing Trace Packet Generation Across VMX Transitions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1747.html">36.5.2.1 System-Wide Tracing</a></li>
<li><a href="o_fe12b1e2a880e0ce-1747.html">36.5.2.2 Host-Only Tracing</a></li>
<li><a href="o_fe12b1e2a880e0ce-1748.html">36.5.2.3 Guest-Only Tracing</a></li>
<li><a href="o_fe12b1e2a880e0ce-1748.html">36.5.2.4 Virtualization of Guest Output Packet Streams</a></li>
<li><a href="o_fe12b1e2a880e0ce-1748.html">36.5.2.5 Emulation of Intel PT Traced State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1748.html">36.5.2.6 TSC Scaling</a></li>
<li><a href="o_fe12b1e2a880e0ce-1749.html">36.5.2.7 Failed VM Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1749.html">36.5.2.8 VMX Abort</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1749.html">36.6 Tracing and SMM Transfer Monitor (STM)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1749.html">36.7 Packet Generation Scenarios</a></li>
<li><a href="o_fe12b1e2a880e0ce-1762.html">36.8 Software Considerations</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1762.html">36.8.1 Tracing SMM Code</a></li>
<li><a href="o_fe12b1e2a880e0ce-1762.html">36.8.2 Cooperative Transition of Multiple Trace Collection Agents</a></li>
<li><a href="o_fe12b1e2a880e0ce-1763.html">36.8.3 Tracking Time</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1763.html">36.8.3.1 Time Domain Relationships</a></li>
<li><a href="o_fe12b1e2a880e0ce-1763.html">36.8.3.2 Estimating TSC within Intel PT</a></li>
<li><a href="o_fe12b1e2a880e0ce-1764.html">36.8.3.3 VMX TSC Manipulation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1764.html">36.8.3.4 Calculating Frequency with Intel PT</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1765.html">Chapter 37 Introduction to Intel® Software Guard Extensions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1765.html">37.1 Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1765.html">37.2 Enclave Interaction and Protection</a></li>
<li><a href="o_fe12b1e2a880e0ce-1766.html">37.3 Enclave Life Cycle</a></li>
<li><a href="o_fe12b1e2a880e0ce-1766.html">37.4 Data Structures and Enclave Operation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1766.html">37.5 Enclave Page Cache</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1767.html">37.5.1 Enclave Page Cache Map (EPCM)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1767.html">37.6 Enclave Instructions and Intel® SGX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1768.html">37.7 Discovering Support for Intel® SGX and enabling Enclave Instructions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1768.html">37.7.1 Intel® SGX Opt-In Configuration</a></li>
<li><a href="o_fe12b1e2a880e0ce-1769.html">37.7.2 Intel® SGX Resource Enumeration Leaves</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1771.html">Chapter 38 Enclave Access Control and Data Structures</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1771.html">38.1 Overview of Enclave Execution Environment</a></li>
<li><a href="o_fe12b1e2a880e0ce-1771.html">38.2 Terminology</a></li>
<li><a href="o_fe12b1e2a880e0ce-1771.html">38.3 Access-control Requirements</a></li>
<li><a href="o_fe12b1e2a880e0ce-1772.html">38.4 Segment-based Access Control</a></li>
<li><a href="o_fe12b1e2a880e0ce-1772.html">38.5 Page-based Access Control</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1772.html">38.5.1 Access-control for Accesses that Originate from non-SGX Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1772.html">38.5.2 Memory Accesses that Split across ELRANGE</a></li>
<li><a href="o_fe12b1e2a880e0ce-1772.html">38.5.3 Implicit vs. Explicit Accesses</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1772.html">38.5.3.1 Explicit Accesses</a></li>
<li><a href="o_fe12b1e2a880e0ce-1773.html">38.5.3.2 Implicit Accesses</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1774.html">38.6 Intel® SGX Data Structures Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1774.html">38.7 SGX Enclave Control Structure (SECS)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1775.html">38.7.1 ATTRIBUTES</a></li>
<li><a href="o_fe12b1e2a880e0ce-1775.html">38.7.2 SECS.MISCSELECT Field</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1776.html">38.8 Thread Control Structure (TCS)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1776.html">38.8.1 TCS.FLAGS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1776.html">38.8.2 State Save Area Offset (OSSA)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1777.html">38.8.3 Current State Save Area Frame (CSSA)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1777.html">38.8.4 Number of State Save Area Frames (NSSA)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1777.html">38.9 State Save Area (SSA) Frame</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1778.html">38.9.1 GPRSGX Region</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1778.html">38.9.1.1 EXITINFO</a></li>
<li><a href="o_fe12b1e2a880e0ce-1779.html">38.9.1.2 VECTOR Field Definition</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1779.html">38.9.2 MISC Region</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1780.html">38.9.2.1 EXINFO Structure</a></li>
<li><a href="o_fe12b1e2a880e0ce-1780.html">38.9.2.2 Page Fault Error Codes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1780.html">38.10 Page Information (PAGEINFO)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1781.html">38.11 Security Information (SECINFO)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1781.html">38.11.1 SECINFO.FLAGS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1782.html">38.11.2 PAGE_TYPE Field Definition</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1782.html">38.12 Paging Crypto MetaData (PCMD)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1782.html">38.13 Enclave Signature Structure (SIGSTRUCT)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1783.html">38.14 EINIT Token Structure (EINITTOKEN)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1784.html">38.15 Report (REPORT)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1785.html">38.15.1 REPORTDATA</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1785.html">38.16 Report Target Info (TARGETINFO)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1785.html">38.17 Key Request (KEYREQUEST)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1786.html">38.17.1 KEY REQUEST KeyNames</a></li>
<li><a href="o_fe12b1e2a880e0ce-1786.html">38.17.2 Key Request Policy Structure</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1786.html">38.18 Version Array (VA)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1786.html">38.19 Enclave Page Cache Map (EPCM)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1789.html">Chapter 39 Enclave Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1789.html">39.1 Constructing an Enclave</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1789.html">1. The application hands over the enclave content along with additional information required by the enclave creation API to the enclave creation service running at privilege level 0.</a></li>
<li><a href="o_fe12b1e2a880e0ce-1790.html">39.1.1 ECREATE</a></li>
<li><a href="o_fe12b1e2a880e0ce-1790.html">39.1.2 EADD and EEXTEND Interaction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1790.html">39.1.3 EINIT Interaction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1791.html">39.1.4 Intel® SGX Launch Control Configuration</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1791.html">39.2 Enclave Entry and Exiting</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1791.html">39.2.1 Controlled Entry and Exit</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1792.html">1. Check that TCS is not busy and flush all cached linear-to-physical mappings.</a></li>
<li><a href="o_fe12b1e2a880e0ce-1792.html">1. Clear enclave mode and flush all cached linear-to-physical mappings.</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1792.html">39.2.2 Asynchronous Enclave Exit (AEX)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1792.html">39.2.3 Resuming Execution after AEX</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1793.html">39.2.3.1 ERESUME Interaction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1793.html">39.3 Calling Enclave Procedures</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1793.html">39.3.1 Calling Convention</a></li>
<li><a href="o_fe12b1e2a880e0ce-1793.html">39.3.2 Register Preservation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1793.html">39.3.3 Returning to Caller</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1793.html">39.4 Intel® SGX Key and Attestation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1793.html">39.4.1 Enclave Measurement</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1794.html">39.4.1.1 MRENCLAVE</a></li>
<li><a href="o_fe12b1e2a880e0ce-1794.html">39.4.1.2 MRSIGNER</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1795.html">39.4.2 Security Version Numbers (SVN)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1795.html">39.4.2.1 Enclave Security Version</a></li>
<li><a href="o_fe12b1e2a880e0ce-1795.html">39.4.2.2 Hardware Security Version</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1795.html">39.4.3 Keys</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1796.html">39.4.3.1 Sealing Enclave Data</a></li>
<li><a href="o_fe12b1e2a880e0ce-1796.html">39.4.3.2 Using REPORTs for Local Attestation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1796.html">1. The source enclave determines the identity of the target enclave to populate TARGETINFO.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1797.html">39.5 EPC and Management of EPC Pages</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1797.html">39.5.1 EPC Implementation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1797.html">39.5.2 OS Management of EPC Pages</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1797.html">39.5.2.1 Enhancement to Managing EPC Pages</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1797.html">39.5.3 Eviction of Enclave Pages</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1797.html">1. For each page to be evicted from the EPC:</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1797.html">a. Select an empty slot in a Version Array (VA) page.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1798.html">39.5.4 Loading an Enclave Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1798.html">1. Execute ELDB/ELDU (depending on the desired BLOCKED state for the page), passing as parameters: the EPC page linear address, the VA slot, the encrypted page, and the page metadata.</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1798.html">39.5.5 Eviction of an SECS Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1798.html">1. Ensure all pages are evicted from enclave.</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1799.html">39.5.6 Eviction of a Version Array Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1799.html">1. Select a slot in a Version Array page other than the page being evicted.</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1799.html">39.5.7 Allocating a Regular Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1799.html">1. Enclave requests additional memory from OS when the current allocation becomes insufficient.</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1799.html">a. EAUG may only be called on a free EPC page.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1799.html">39.5.8 Allocating a TCS Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1799.html">1. Enclave requests an additional page from the OS.</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1799.html">a. EAUG may only be called on a free EPC page.</a></li>
<li><a href="o_fe12b1e2a880e0ce-1799.html">a. The parameters to EMODT indicate that the regular page should be converted into a TCS.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1800.html">39.5.9 Trimming a Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1800.html">1. Enclave signals OS that a particular page is no longer in use.</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1800.html">a. SECS and VA pages cannot be trimmed in this way, so the initial type of the page must be PT_REG or PT_TCS.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1800.html">39.5.10 Restricting the EPCM Permissions of a Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1800.html">1. Enclave requests that the OS to restrict the permissions of an EPC page.</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1800.html">a. Invokes the EMODPR leaf function to restrict permissions (EMODPR may only be called on VALID pages).</a></li>
<li><a href="o_fe12b1e2a880e0ce-1800.html">a. Enclave may access the page throughout the entire process.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1801.html">39.5.11 Extending the EPCM Permissions of a Page</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1801.html">1. Enclave invokes EMODPE to extend the EPCM permissions associated with an EPC page (EMODPE may only be called on VALID pages).</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1801.html">a. If cached linear-address to physical-address translations are present to the more restrictive permissions, the enclave thread will page fault. The SGX2-aware OS will see that the page tables permit the access and resume the thread, which can now s...</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1801.html">39.6 Changes to Instruction Behavior Inside an Enclave</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1801.html">39.6.1 Illegal Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1802.html">39.6.2 RDRAND and RDSEED Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1802.html">39.6.3 PAUSE Instruction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1802.html">39.6.4 INT 3 Behavior Inside an Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1802.html">39.6.5 INVD Handling when Enclaves Are Enabled</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1803.html">Chapter 40 Enclave Exiting Events</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1803.html">40.1 Compatible Switch to the Exiting Stack of AEX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1804.html">40.2 State Saving by AEX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1805.html">40.3 Synthetic State on Asynchronous Enclave Exit</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1805.html">40.3.1 Processor Synthetic State on Asynchronous Enclave Exit</a></li>
<li><a href="o_fe12b1e2a880e0ce-1805.html">40.3.2 Synthetic State for Extended Features</a></li>
<li><a href="o_fe12b1e2a880e0ce-1806.html">40.3.3 Synthetic State for MISC Features</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1806.html">40.4 AEX Flow</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1806.html">1. The exact processor state saved into the current SSA frame depends on whether the enclave is a 32-bit or a 64- bit enclave. In 32-bit mode (IA32_EFER.LMA = 0 || CS.L = 0), the low 32 bits of the legacy registers (EAX, EBX, ECX, EDX, ESP, EBP, ESI,...</a></li>
<li><a href="o_fe12b1e2a880e0ce-1807.html">40.4.1 AEX Operational Detail</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1811.html">Chapter 41 SGX Instruction References</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1811.html">41.1 Intel® SGX InstructIon Syntax and Operation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1811.html">41.1.1 ENCLS Register Usage Summary</a></li>
<li><a href="o_fe12b1e2a880e0ce-1811.html">41.1.2 ENCLU Register Usage Summary</a></li>
<li><a href="o_fe12b1e2a880e0ce-1812.html">41.1.3 Information and Error Codes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1813.html">41.1.4 Internal CREGs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1813.html">41.1.5 Concurrent Operation Restrictions</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1814.html">41.1.5.1 Concurrency Tables of Intel® SGX Instructions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1814.html">41.2 Intel® SGX InstructIon Reference</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1815.html">ENCLS—Execute an Enclave System Function of Specified Leaf Number</a></li>
<li><a href="o_fe12b1e2a880e0ce-1817.html">ENCLU—Execute an Enclave User Function of Specified Leaf Number</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1820.html">41.3 Intel® SGX System Leaf Function Reference</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1821.html">EADD—Add a Page to an Uninitialized Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1825.html">EAUG—Add a Page to an Initialized Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1828.html">EBLOCK—Mark a page in EPC as Blocked</a></li>
<li><a href="o_fe12b1e2a880e0ce-1831.html">ECREATE—Create an SECS page in the Enclave Page Cache</a></li>
<li><a href="o_fe12b1e2a880e0ce-1835.html">EDBGRD—Read From a Debug Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1838.html">EDBGWR—Write to a Debug Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1841.html">EEXTEND—Extend Uninitialized Enclave Measurement by 256 Bytes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1844.html">EINIT—Initialize an Enclave for Execution</a></li>
<li><a href="o_fe12b1e2a880e0ce-1851.html">ELDB/ELDU—Load an EPC page and Marked its State</a></li>
<li><a href="o_fe12b1e2a880e0ce-1856.html">EMODPR—Restrict the Permissions of an EPC Page</a></li>
<li><a href="o_fe12b1e2a880e0ce-1859.html">EMODT—Change the Type of an EPC Page</a></li>
<li><a href="o_fe12b1e2a880e0ce-1862.html">EPA—Add Version Array</a></li>
<li><a href="o_fe12b1e2a880e0ce-1864.html">EREMOVE—Remove a page from the EPC</a></li>
<li><a href="o_fe12b1e2a880e0ce-1867.html">ETRACK—Activates EBLOCK Checks</a></li>
<li><a href="o_fe12b1e2a880e0ce-1869.html">EWB—Invalidate an EPC Page and Write out to Main Memory</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1874.html">41.4 Intel® SGX User Leaf Function Reference</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1874.html">41.4.1 Instruction Column in the Instruction Summary Table</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1875.html">EACCEPT—Accept Changes to an EPC Page</a></li>
<li><a href="o_fe12b1e2a880e0ce-1879.html">EACCEPTCOPY—Initialize a Pending Page</a></li>
<li><a href="o_fe12b1e2a880e0ce-1883.html">EENTER—Enters an Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1891.html">EEXIT—Exits an Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1894.html">EGETKEY—Retrieves a Cryptographic Key</a></li>
<li><a href="o_fe12b1e2a880e0ce-1902.html">EMODPE—Extend an EPC Page Permissions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1905.html">EREPORT—Create a Cryptographic Report of the Enclave</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1905.html">1. Validate the 3 operands (RBX, RCX, RDX) are inside the enclave.</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1909.html">ERESUME—Re-Enters an Enclave</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1919.html">Chapter 42 Intel® SGX Interactions with IA32 and Intel® 64 Architecture</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1919.html">42.1 Intel® SGX Availability in Various Processor Modes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1919.html">42.2 IA32_FEATURE_CONTROL</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1919.html">42.2.1 Availability of Intel SGX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1919.html">42.2.2 Intel SGX Launch Control Configuration</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1919.html">42.3 Interactions with Segmentation</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1919.html">42.3.1 Scope of Interaction</a></li>
<li><a href="o_fe12b1e2a880e0ce-1920.html">42.3.2 Interactions of Intel® SGX Instructions with Segment, Operand, and Addressing Prefixes</a></li>
<li><a href="o_fe12b1e2a880e0ce-1920.html">42.3.3 Interaction of Intel® SGX Instructions with Segmentation</a></li>
<li><a href="o_fe12b1e2a880e0ce-1920.html">42.3.4 Interactions of Enclave Execution with Segmentation</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1920.html">42.4 Interactions with Paging</a></li>
<li><a href="o_fe12b1e2a880e0ce-1921.html">42.5 Interactions with VMX</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1921.html">42.5.1 VMM Controls to Configure Guest Support of Intel® SGX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1921.html">42.5.2 Interactions with the Extended Page Table Mechanism (EPT)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1922.html">42.5.3 Interactions with APIC Virtualization</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1922.html">42.6 Intel® SGX Interactions with Architecturally-visible Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-1922.html">42.7 Interactions with the Processor Extended State and Miscellaneous State</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1922.html">42.7.1 Requirements and Architecture Overview</a></li>
<li><a href="o_fe12b1e2a880e0ce-1923.html">42.7.2 Relevant Fields in Various Data Structures</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1923.html">42.7.2.1 SECS.ATTRIBUTES.XFRM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1924.html">42.7.2.2 SECS.SSAFRAMESIZE</a></li>
<li><a href="o_fe12b1e2a880e0ce-1924.html">42.7.2.3 XSAVE Area in SSA</a></li>
<li><a href="o_fe12b1e2a880e0ce-1924.html">42.7.2.4 MISC Area in SSA</a></li>
<li><a href="o_fe12b1e2a880e0ce-1924.html">42.7.2.5 SIGSTRUCT Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1925.html">42.7.2.6 REPORT.ATTRIBUTES.XFRM and REPORT.MISCSELECT</a></li>
<li><a href="o_fe12b1e2a880e0ce-1925.html">42.7.2.7 KEYREQUEST</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1925.html">42.7.3 Processor Extended States and ENCLS[ECREATE]</a></li>
<li><a href="o_fe12b1e2a880e0ce-1925.html">42.7.4 Processor Extended States and ENCLU[EENTER]</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1925.html">42.7.4.1 Fault Checking</a></li>
<li><a href="o_fe12b1e2a880e0ce-1925.html">42.7.4.2 State Loading</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1926.html">42.7.5 Processor Extended States and AEX</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1926.html">42.7.5.1 State Saving</a></li>
<li><a href="o_fe12b1e2a880e0ce-1926.html">42.7.5.2 State Synthesis</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1926.html">42.7.6 Processor Extended States and ENCLU[ERESUME]</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1926.html">42.7.6.1 Fault Checking</a></li>
<li><a href="o_fe12b1e2a880e0ce-1926.html">42.7.6.2 State Loading</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1926.html">42.7.7 Processor Extended States and ENCLU[EEXIT]</a></li>
<li><a href="o_fe12b1e2a880e0ce-1927.html">42.7.8 Processor Extended States and ENCLU[EREPORT]</a></li>
<li><a href="o_fe12b1e2a880e0ce-1927.html">42.7.9 Processor Extended States and ENCLU[EGETKEY]</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1927.html">42.8 Interactions with SMM</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1927.html">42.8.1 Availability of Intel® SGX instructions in SMM</a></li>
<li><a href="o_fe12b1e2a880e0ce-1927.html">42.8.2 SMI while Inside an Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1927.html">42.8.3 SMRAM Synthetic State of AEX Triggered by SMI</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1928.html">42.9 Interactions of INIT, SIPI, and Wait-for-SIPI with Intel® SGX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1928.html">42.10 Interactions with DMA</a></li>
<li><a href="o_fe12b1e2a880e0ce-1928.html">42.11 Interactions with TXT</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1928.html">42.11.1 Enclaves Created Prior to Execution of GETSEC</a></li>
<li><a href="o_fe12b1e2a880e0ce-1928.html">42.11.2 Interaction of GETSEC with Intel® SGX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1929.html">42.11.3 Interactions with Authenticated Code Modules (ACMs)</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1929.html">42.12 Interactions with Caching of Linear-address Translations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1929.html">42.13 Interactions with Intel® Transactional Synchronization Extensions (Intel® TSX)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1930.html">42.13.1 HLE and RTM Debug</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1930.html">42.14 Intel® SGX Interactions with S states</a></li>
<li><a href="o_fe12b1e2a880e0ce-1930.html">42.15 Intel® SGX Interactions with Machine Check Architecture (MCA)</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1930.html">42.15.1 Interactions with MCA Events</a></li>
<li><a href="o_fe12b1e2a880e0ce-1930.html">42.15.2 Machine Check Enables (IA32_MCi_CTL)</a></li>
<li><a href="o_fe12b1e2a880e0ce-1930.html">42.15.3 CR4.MCE</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1931.html">42.16 Intel® SGX INTERACTIONS WITH PROTECTED MODE VIRTUAL INTERRUPTS</a></li>
<li><a href="o_fe12b1e2a880e0ce-1931.html">42.17 Intel SGX Interaction with Protection Keys</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1933.html">Chapter 43 Enclave Code Debug and Profiling</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1933.html">43.1 Configuration and Controls</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1933.html">43.1.1 Debug Enclave vs. Production Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1933.html">43.1.2 Tool-Chain Opt-in</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1933.html">43.2 Single Step Debug</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1933.html">43.2.1 Single Stepping ENCLS Instruction Leafs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1933.html">43.2.2 Single Stepping ENCLU Instruction Leafs</a></li>
<li><a href="o_fe12b1e2a880e0ce-1934.html">43.2.3 Single-Stepping Enclave Entry with Opt-out Entry</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1934.html">43.2.3.1 Single Stepping without AEX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1934.html">43.2.3.2 Single Step Preempted by AEX Due to Non-SMI Event</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1935.html">43.2.4 RFLAGS.TF Treatment on AEX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1935.html">43.2.5 Restriction on Setting of TF after an Opt-Out Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1935.html">43.2.6 Trampoline Code Considerations</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1935.html">43.3 Code and Data Breakpoints</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1935.html">43.3.1 Breakpoint Suppression</a></li>
<li><a href="o_fe12b1e2a880e0ce-1936.html">43.3.2 Reporting of Instruction Breakpoint on Next Instruction on a Debug Trap</a></li>
<li><a href="o_fe12b1e2a880e0ce-1936.html">43.3.3 RF Treatment on AEX</a></li>
<li><a href="o_fe12b1e2a880e0ce-1936.html">43.3.4 Breakpoint Matching in Intel® SGX Instruction Flows</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1936.html">43.4 INT3 Consideration</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1936.html">43.4.1 Behavior of INT3 Inside an Enclave</a></li>
<li><a href="o_fe12b1e2a880e0ce-1936.html">43.4.2 Debugger Considerations</a></li>
<li><a href="o_fe12b1e2a880e0ce-1936.html">43.4.3 VMM Considerations</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1937.html">43.5 Branch Tracing</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1937.html">43.5.1 BTF Treatment</a></li>
<li><a href="o_fe12b1e2a880e0ce-1937.html">43.5.2 LBR Treatment</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1937.html">43.5.2.1 LBR Stack on Opt-in Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1938.html">43.5.2.2 LBR Stack on Opt-out Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1939.html">43.5.2.3 Mispredict Bit, Record Type, and Filtering</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1939.html">43.6 Interaction with Performance Monitoring</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1939.html">43.6.1 IA32_PERF_GLOBAL_STATUS Enhancement</a></li>
<li><a href="o_fe12b1e2a880e0ce-1939.html">43.6.2 Performance Monitoring with Opt-in Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1940.html">43.6.3 Performance Monitoring with Opt-out Entry</a></li>
<li><a href="o_fe12b1e2a880e0ce-1940.html">43.6.4 Enclave Exit and Performance Monitoring</a></li>
<li><a href="o_fe12b1e2a880e0ce-1940.html">43.6.5 PEBS Record Generation on Intel® SGX Instructions</a></li>
<li><a href="o_fe12b1e2a880e0ce-1940.html">43.6.6 Exception-Handling on PEBS/BTS Loads/Stores after AEX</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1941.html">43.6.6.1 Other Interactions with Performance Monitoring</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1943.html">Appendix A VMX Capability Reporting Facility</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1943.html">A.1 Basic VMX Information</a></li>
<li><a href="o_fe12b1e2a880e0ce-1944.html">A.2 Reserved Controls and Default Settings</a></li>
<li><a href="o_fe12b1e2a880e0ce-1944.html">A.3 VM-Execution Controls</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1945.html">A.3.1 Pin-Based VM-Execution Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1945.html">A.3.2 Primary Processor-Based VM-Execution Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1946.html">A.3.3 Secondary Processor-Based VM-Execution Controls</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1946.html">A.4 VM-Exit Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1947.html">A.5 VM-Entry Controls</a></li>
<li><a href="o_fe12b1e2a880e0ce-1947.html">A.6 Miscellaneous Data</a></li>
<li><a href="o_fe12b1e2a880e0ce-1948.html">A.7 VMX-Fixed Bits in CR0</a></li>
<li><a href="o_fe12b1e2a880e0ce-1948.html">A.8 VMX-Fixed Bits in CR4</a></li>
<li><a href="o_fe12b1e2a880e0ce-1949.html">A.9 VMCS Enumeration</a></li>
<li><a href="o_fe12b1e2a880e0ce-1949.html">A.10 VPID and EPT Capabilities</a></li>
<li><a href="o_fe12b1e2a880e0ce-1950.html">A.11 VM Functions</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1951.html">Appendix B Field Encoding in VMCS</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1951.html">B.1 16-Bit Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1951.html">B.1.1 16-Bit Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1951.html">B.1.2 16-Bit Guest-State Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1952.html">B.1.3 16-Bit Host-State Fields</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1952.html">B.2 64-Bit Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1952.html">B.2.1 64-Bit Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1954.html">B.2.2 64-Bit Read-Only Data Field</a></li>
<li><a href="o_fe12b1e2a880e0ce-1954.html">B.2.3 64-Bit Guest-State Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1955.html">B.2.4 64-Bit Host-State Fields</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1956.html">B.3 32-Bit Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1956.html">B.3.1 32-Bit Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1957.html">B.3.2 32-Bit Read-Only Data Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1957.html">B.3.3 32-Bit Guest-State Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1958.html">B.3.4 32-Bit Host-State Field</a></li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1958.html">B.4 Natural-Width Fields</a>
<ul>
<li><a href="o_fe12b1e2a880e0ce-1958.html">B.4.1 Natural-Width Control Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1959.html">B.4.2 Natural-Width Read-Only Data Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1959.html">B.4.3 Natural-Width Guest-State Fields</a></li>
<li><a href="o_fe12b1e2a880e0ce-1960.html">B.4.4 Natural-Width Host-State Fields</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_fe12b1e2a880e0ce-1961.html">Appendix C VMX Basic Exit Reasons</a></li>
</ul>
</body>
</html>
