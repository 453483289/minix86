<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 101</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:14px;font-family:Times;color:#0860a8;}
	.ft04{font-size:16px;font-family:Times;color:#0860a8;}
	.ft05{font-size:11px;font-family:Times;color:#000000;}
	.ft06{font-size:8px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft09{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft010{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page101-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_7281d5ea06a5b67a101.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:775px;white-space:nowrap" class="ft00">Vol. 1&#160;4-17</p>
<p style="position:absolute;top:47px;left:764px;white-space:nowrap" class="ft01">DATA&#160;TYPES</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft07">the element. Then, if an&#160;application program attempts to access an element that it has not initialized, it can use the&#160;<br/>NaN placed&#160;there&#160;by&#160;the compiler. If&#160;the invalid operation&#160;exception is&#160;unmasked, an interrupt will occur,&#160;and the&#160;<br/>exception handler&#160;will&#160;be&#160;invoked. The exception&#160;handler can&#160;determine&#160;which&#160;element&#160;has&#160;been accessed, since&#160;<br/>the operand address field of the exception pointer&#160;will point to the NaN, and the NaN&#160;will contain the index number&#160;<br/>of the&#160;array element.<br/>Quiet&#160;NaNs are often used to&#160;speed up&#160;debugging.&#160;In&#160;its&#160;early testing phase,&#160;a program often&#160;contains&#160;multiple&#160;<br/>errors. An&#160;exception handler can&#160;be&#160;written to&#160;save&#160;diagnostic information in memory whenever it is invoked. After&#160;<br/>storing the&#160;diagnostic&#160;data, it&#160;can supply a quiet NaN&#160;as the&#160;result&#160;of&#160;the erroneous&#160;instruction,&#160;and that NaN&#160;can&#160;<br/>point to its associated diagnostic area in memory. The&#160;program will then&#160;continue,&#160;creating a different NaN for each&#160;<br/>error.&#160;When the&#160;program&#160;ends, the&#160;NaN results&#160;can be used to&#160;access&#160;the diagnostic data saved at&#160;the&#160;time&#160;the&#160;<br/>errors occurred.&#160;Many&#160;errors can thus&#160;be&#160;diagnosed and&#160;corrected in one&#160;test&#160;run.<br/>In&#160;embedded&#160;applications that use computed&#160;results in further&#160;computations, an&#160;undetected QNaN&#160;can invalidate&#160;<br/>all&#160;subsequent results. Such&#160;applications should&#160;therefore&#160;periodically&#160;check for QNaNs&#160;and provide a&#160;recovery&#160;<br/>mechanism&#160;to be used if a&#160;QNaN result&#160;is&#160;detected.&#160;</p>
<p style="position:absolute;top:374px;left:69px;white-space:nowrap" class="ft03">4.8.3.7&#160;&#160;</p>
<p style="position:absolute;top:374px;left:153px;white-space:nowrap" class="ft03">QNaN&#160;Floating-Point&#160;Indefinite</p>
<p style="position:absolute;top:403px;left:69px;white-space:nowrap" class="ft07">For the&#160;floating-point data type encodings (single-precision, double-precision, and double-extended-precision),&#160;<br/>one unique&#160;encoding&#160;(a QNaN)&#160;is reserved&#160;for representing&#160;the&#160;special&#160;value&#160;QNaN&#160;floating-point indefinite.&#160;The&#160;<br/>x87&#160;FPU and&#160;the SSE/SSE2/SSE3/SSE4.1/AVX&#160;extensions&#160;return&#160;these indefinite values&#160;as responses to&#160;some&#160;<br/>masked&#160;floating-point exceptio<a href="o_7281d5ea06a5b67a-89.html">ns. Table&#160;4-3&#160;shows the&#160;</a>encoding used for the&#160;QNaN floating-point&#160;indefinite.</p>
<p style="position:absolute;top:496px;left:69px;white-space:nowrap" class="ft03">4.8.3.8 &#160;</p>
<p style="position:absolute;top:496px;left:153px;white-space:nowrap" class="ft03">Half-Precision&#160;Floating-Point&#160;Operation</p>
<p style="position:absolute;top:525px;left:69px;white-space:nowrap" class="ft08">Half-precision floating-point&#160;values are not used by the&#160;processor directly for arithmetic&#160;operations. Two&#160;instruc-<br/>tions, VCVTPH2PS,&#160;VCVTPS2PH,&#160;provide&#160;conversion only&#160;between half-precision and&#160;single-precision floating-point&#160;<br/>values.<br/>The SIMD&#160;floating-point&#160;exception&#160;behavior of VCVTPH2PS and&#160;VCVTPS2PH are&#160;described&#160;<a href="o_7281d5ea06a5b67a-348.html">in Section 14.4.1.</a></p>
<p style="position:absolute;top:632px;left:69px;white-space:nowrap" class="ft04">4.8.4 Rounding</p>
<p style="position:absolute;top:663px;left:69px;white-space:nowrap" class="ft08">When&#160;performing floating-point operations,&#160;the processor produces&#160;an&#160;infinitely precise floating-point result&#160;in the&#160;<br/>destination format&#160;(single-precision, double-precision,&#160;or double&#160;extended-precision&#160;floating-point)&#160;whenever&#160;<br/>possible. However,&#160;because&#160;only a&#160;subset of&#160;the numbers&#160;in&#160;the real number continuum can&#160;be represented in&#160;IEEE&#160;<br/>Standard&#160;754 floating-point formats,&#160;it&#160;is often&#160;the case that&#160;an infinitely precise result cannot be&#160;encoded exactly&#160;<br/>in&#160;the format of&#160;the&#160;destination&#160;operand.<br/>For example,&#160;the following&#160;value (<i>a</i>) has&#160;a 24-bit fraction. The&#160;least-significant bit&#160;of this fraction&#160;(the underlined&#160;<br/>bit) cannot be encoded&#160;exactly&#160;in&#160;the&#160;single-precision&#160;format (which&#160;has only a&#160;23-bit fraction):<br/>(<i>a</i>) 1.0001&#160;0000&#160;1000&#160;0011 1001&#160;0111E</p>
<p style="position:absolute;top:800px;left:343px;white-space:nowrap" class="ft06">2</p>
<p style="position:absolute;top:793px;left:350px;white-space:nowrap" class="ft02">&#160;101</p>
<p style="position:absolute;top:817px;left:69px;white-space:nowrap" class="ft08">To&#160;round&#160;this result (<i>a</i>), the&#160;processor first&#160;selects two representable fractions&#160;<i>b&#160;</i>and&#160;<i>c</i>&#160;that most closely&#160;bracket&#160;<i>a&#160;<br/></i>in value (<i>b&#160;</i>&lt;&#160;<i>a&#160;</i>&lt;&#160;<i>c</i>).<br/>(<i>b</i>) 1.0001 0000&#160;1000&#160;0011 1001&#160;011E</p>
<p style="position:absolute;top:864px;left:335px;white-space:nowrap" class="ft06">2</p>
<p style="position:absolute;top:858px;left:341px;white-space:nowrap" class="ft02">&#160;101</p>
<p style="position:absolute;top:882px;left:69px;white-space:nowrap" class="ft02">(<i>c</i>) 1.0001&#160;0000&#160;1000&#160;0011 1001&#160;100E</p>
<p style="position:absolute;top:888px;left:333px;white-space:nowrap" class="ft06">2</p>
<p style="position:absolute;top:882px;left:340px;white-space:nowrap" class="ft02">&#160;101</p>
<p style="position:absolute;top:906px;left:69px;white-space:nowrap" class="ft07">The processor then&#160;sets the&#160;result&#160;to&#160;<i>b&#160;</i>or to&#160;<i>c</i>&#160;according to&#160;the selected rounding&#160;mode.&#160;Rounding introduces&#160;an&#160;<br/>error&#160;in a&#160;result that&#160;is less than one&#160;unit&#160;in the&#160;last place (the&#160;least significant&#160;bit&#160;position of the floating-point&#160;<br/>value)&#160;to&#160;which the&#160;result is&#160;rounded.<br/>The IEEE Standard 754 defines four rounding modes (see<a href="o_7281d5ea06a5b67a-102.html">&#160;Table&#160;4-8): round&#160;</a>to nearest, round up, round down,&#160;and&#160;<br/>round toward&#160;zero. The default rounding&#160;mode (for&#160;the Intel&#160;64&#160;and IA-32 architectures) is&#160;round to&#160;nearest.&#160;This&#160;<br/>mode&#160;provides&#160;the&#160;most accurate and&#160;statistically unbiased&#160;estimate of&#160;the&#160;true result&#160;and&#160;is suitable for most&#160;<br/>applications.&#160;</p>
</div>
</body>
</html>
