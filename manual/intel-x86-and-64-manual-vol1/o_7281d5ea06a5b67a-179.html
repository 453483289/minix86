<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 179</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:18px;font-family:Times;color:#000000;}
	.ft05{font-size:14px;font-family:Times;color:#0860a8;}
	.ft06{font-size:11px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
	.ft09{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page179-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_7281d5ea06a5b67a179.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:775px;white-space:nowrap" class="ft00">Vol. 1&#160;7-15</p>
<p style="position:absolute;top:47px;left:510px;white-space:nowrap" class="ft01">PROGRAMMING WITH GENERAL-PURPOSE INSTRUCTIONS</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft09"><b>Jump instruction —</b>&#160;The JMP&#160;(jump) instruction&#160;unconditionally transfers program control to&#160;a destination&#160;<br/>instruction. The&#160;transfer&#160;is one-way;&#160;that is, a&#160;return&#160;address&#160;is not saved. A destination&#160;operand specifies&#160;the&#160;<br/>address&#160;(the instruction&#160;pointer) of the&#160;destination&#160;instruction. The address&#160;can&#160;be&#160;a&#160;<b>relative&#160;address</b>&#160;or an&#160;<br/><b>absolute address</b>.<br/>A&#160;<b>relative address</b>&#160;is a&#160;displacement (offset)&#160;with respect&#160;to the&#160;address in&#160;the&#160;EIP&#160;register. The&#160;destination&#160;<br/>address (a near&#160;pointer) is&#160;formed&#160;by adding the&#160;displacement to the&#160;address in the EIP register. The&#160;displacement&#160;<br/>is&#160;specified with a&#160;signed&#160;integer,&#160;allowing&#160;jumps either&#160;forward or&#160;backward&#160;in&#160;the&#160;instruction&#160;stream.<br/>An&#160;<b>absolute address</b>&#160;is a&#160;offset from&#160;address 0 of a&#160;segment. It&#160;can&#160;be&#160;specified in either of the&#160;following&#160;ways:</p>
<p style="position:absolute;top:253px;left:69px;white-space:nowrap" class="ft04">•</p>
<p style="position:absolute;top:253px;left:95px;white-space:nowrap" class="ft07"><b>An address in&#160;a general-purpose register —</b>&#160;This address is&#160;treated as a near pointer,&#160;which is copied into&#160;<br/>the EIP&#160;register. Program execution&#160;then&#160;continues&#160;at&#160;the&#160;new address&#160;within the&#160;current code segment.</p>
<p style="position:absolute;top:292px;left:69px;white-space:nowrap" class="ft04">•</p>
<p style="position:absolute;top:292px;left:95px;white-space:nowrap" class="ft07"><b>An address specified&#160;using&#160;the&#160;standard&#160;addressing&#160;modes&#160;of the processor —</b>&#160;Here, the address can&#160;<br/>be a&#160;near pointer or&#160;a far pointer.&#160;If&#160;the address&#160;is for a&#160;near pointer,&#160;the&#160;address is&#160;translated into&#160;an&#160;offset and&#160;<br/>copied&#160;into the EIP register. If&#160;the&#160;address is for a far&#160;pointer,&#160;the address is translated into&#160;a segment selector&#160;<br/>(which&#160;is copied&#160;into the&#160;CS register) and an offset&#160;(which is&#160;copied into&#160;the&#160;EIP&#160;register).</p>
<p style="position:absolute;top:366px;left:69px;white-space:nowrap" class="ft07">In&#160;protected mode,&#160;the JMP instruction also&#160;allows&#160;jumps to&#160;a call&#160;gate, a&#160;task gate,&#160;and a&#160;task-state segment.<br/><b>Call and&#160;return&#160;instructions —</b>&#160;The&#160;CALL&#160;(call&#160;procedure)&#160;and&#160;RET (return from&#160;procedure) instructions allow a&#160;<br/>jump from one procedure (or&#160;subroutine) to another and a&#160;subsequent jump&#160;back (return)&#160;to the calling procedure.<br/>The CALL&#160;instruction&#160;transfers program control from&#160;the&#160;current (or&#160;calling) procedure&#160;to another procedure&#160;(the&#160;<br/>called&#160;procedure). To&#160;allow a&#160;subsequent&#160;return to&#160;the&#160;calling procedure, the&#160;CALL instruction saves the&#160;current&#160;<br/>contents&#160;of&#160;the EIP&#160;register on&#160;the stack before jumping&#160;to the&#160;called&#160;procedure.&#160;The&#160;EIP register&#160;(prior to&#160;trans-<br/>ferring program control) contains the address of the instruction&#160;following the&#160;CALL instruction. When this&#160;address&#160;<br/>is&#160;pushed&#160;on&#160;the&#160;stack,&#160;it&#160;is&#160;referred&#160;to&#160;as&#160;the&#160;<b>return instruction pointer</b>&#160;or&#160;<b>return address</b>.<br/>The address&#160;of&#160;the called procedure&#160;(the&#160;address of the&#160;first instruction in the&#160;procedure&#160;being jumped&#160;to)&#160;is spec-<br/>ified&#160;in a CALL&#160;instruction&#160;the same&#160;way as it&#160;is&#160;in&#160;a&#160;JMP instruction (see “Jump instruction”&#160;on<a href="o_7281d5ea06a5b67a-179.html">&#160;page&#160;7-15).&#160;</a>The&#160;<br/>address can be specified&#160;as a relative&#160;address or an&#160;absolute&#160;address. If an absolute&#160;address is specified, it can be&#160;<br/>either a&#160;near or&#160;a far pointer.<br/>The RET instruction&#160;transfers program control from&#160;the&#160;procedure currently being executed (the called&#160;procedure)&#160;<br/>back to&#160;the procedure&#160;that called it&#160;(the calling procedure). Transfer of control&#160;is accomplished by copying&#160;the&#160;<br/>return instruction pointer from&#160;the stack&#160;into&#160;the EIP register. Program execution&#160;then continues with&#160;the&#160;instruc-<br/>tion pointed to&#160;by&#160;the EIP&#160;register.<br/>The RET&#160;instruction&#160;has an&#160;optional operand, the value&#160;of&#160;which is&#160;added&#160;to the&#160;contents of&#160;the ESP register&#160;as part&#160;<br/>of&#160;the return&#160;operation.&#160;This operand allows&#160;the stack pointer to&#160;be&#160;incremented&#160;to remove&#160;parameters&#160;from the&#160;<br/>stack that were&#160;pushed on the&#160;stack by the&#160;calling&#160;procedure.<br/>Se<a href="o_7281d5ea06a5b67a-148.html">e Section&#160;6.3,&#160;“Calling&#160;Procedures&#160;Using CALL and RET,” for more informatio</a>n&#160;on the mechanics of making&#160;proce-<br/>dure&#160;calls with the&#160;CALL and&#160;RET instructions.<br/><b>Return&#160;from&#160;interrupt instruction —</b>&#160;When the processor services an interrupt, it performs an&#160;implicit call to an&#160;<br/>interrupt-handling procedure.&#160;The IRET&#160;(return&#160;from&#160;interrupt) instruction&#160;returns&#160;program&#160;control from&#160;an inter-<br/>rupt handler to the&#160;interrupted procedure (that&#160;is,&#160;the procedure&#160;that&#160;was&#160;executing when&#160;the&#160;interrupt occurred).&#160;<br/>The IRET instruction performs a similar operation to the RE<a href="o_7281d5ea06a5b67a-179.html">T instruction (see “Call and return instructions” on page&#160;<br/>7-15) except&#160;</a>that&#160;it&#160;also restores&#160;the&#160;EFLAGS&#160;register&#160;from the&#160;stack.&#160;The&#160;contents of the&#160;EFLAGS&#160;register&#160;are&#160;<br/>automatically stored on&#160;the stack along&#160;with&#160;the return&#160;instruction pointer when&#160;the processor services an&#160;inter-<br/>rupt.</p>
<p style="position:absolute;top:908px;left:69px;white-space:nowrap" class="ft05">7.3.8.2 &#160;</p>
<p style="position:absolute;top:908px;left:153px;white-space:nowrap" class="ft05">Conditional&#160;Transfer&#160;Instructions</p>
<p style="position:absolute;top:937px;left:69px;white-space:nowrap" class="ft07">The conditional&#160;transfer&#160;instructions&#160;execute jumps or&#160;loops&#160;that transfer&#160;program control&#160;to another&#160;instruction&#160;in&#160;<br/>the instruction stream&#160;if specified conditions are met. The&#160;conditions&#160;for control transfer are&#160;specified&#160;with a set of&#160;<br/>condition&#160;codes&#160;that define various states&#160;of the&#160;status flags&#160;(CF,&#160;ZF, OF, PF, and&#160;SF)&#160;in the&#160;EFLAGS register.<br/><b>Conditional jump&#160;instructions —</b>&#160;The&#160;J<i>cc</i>&#160;(conditional)&#160;jump&#160;instructions&#160;transfer program control to&#160;a destina-<br/>tion instruction if the conditions specified with the condition code (<i>cc</i>) associated with the instruction are satisfied&#160;<br/>(see&#160;<a href="o_7281d5ea06a5b67a-180.html">Table&#160;7-4). If&#160;</a>the condition&#160;is not satisfied,&#160;execution continues&#160;with&#160;the instruction following the&#160;J<i>cc</i>&#160;instruc-<br/>tion.&#160;As&#160;with the JMP instruction,&#160;the transfer&#160;is one-way; that is, a&#160;return address&#160;is not saved.</p>
</div>
</body>
</html>
