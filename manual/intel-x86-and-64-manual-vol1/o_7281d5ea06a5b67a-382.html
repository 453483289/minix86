<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 382</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:16px;font-family:Times;color:#0860a8;}
	.ft05{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:22px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page382-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_7281d5ea06a5b67a382.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">16-2&#160;Vol. 1</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">PROGRAMMING WITH INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS</p>
<p style="position:absolute;top:100px;left:68px;white-space:nowrap" class="ft05">Programmers&#160;who would like to run Intel&#160;TSX-enabled software&#160;on&#160;legacy hardware would use the HLE&#160;interface to&#160;<br/>implement lock elision. On the other&#160;hand, programmers who do not&#160;have&#160;legacy hardware requirements and who&#160;<br/>deal&#160;with&#160;more&#160;complex&#160;locking primitives would use&#160;the&#160;RTM&#160;software interface of&#160;Intel&#160;TSX&#160;to implement&#160;lock&#160;<br/>elision.&#160;In&#160;the latter case when using&#160;new&#160;instructions,&#160;the programmer must always&#160;provide a&#160;non-transactional&#160;<br/>path (which would have code to&#160;eventually&#160;acquire&#160;the&#160;lock&#160;being elided) to&#160;execute following a&#160;transactional abort&#160;<br/>and must&#160;not&#160;rely on the&#160;transactional&#160;execution alone.<br/>In addition,&#160;Intel TSX also&#160;provides&#160;the XTEST instruction&#160;to test&#160;whether a&#160;logical processor is&#160;executing&#160;transac-<br/>tionally, and&#160;the XABORT&#160;instruction to&#160;abort&#160;a transactional&#160;region.<br/>A processor can&#160;perform&#160;a&#160;transactional&#160;abort for numerous&#160;reasons. A primary cause&#160;is due&#160;to conflicting&#160;accesses&#160;<br/>between&#160;the&#160;transactionally executing logical processor and&#160;another logical&#160;processor.&#160;Such&#160;conflicting accesses&#160;<br/>may prevent&#160;a successful&#160;transactional&#160;execution. Memory addresses read from within&#160;a transactional&#160;region&#160;<br/>constitute the&#160;<b>read-set</b>&#160;of the transactional region and addresses written to within&#160;the transactional region consti-<br/>tute the&#160;<b>write-set</b>&#160;of the transactional region. Intel TSX maintains the read- and write-sets at the granularity of a&#160;<br/>cache line.&#160;<br/>A&#160;conflicting&#160;data&#160;access occurs&#160;if&#160;another&#160;logical&#160;processor either reads a location&#160;that&#160;is part of the transactional&#160;<br/>region’s&#160;write-set or&#160;writes&#160;a location&#160;that&#160;is a&#160;part&#160;of&#160;either the&#160;read-&#160;or write-set&#160;of&#160;the transactional region. We&#160;<br/>refer to&#160;this&#160;as a&#160;<b>data conflict</b>. Since Intel TSX&#160;detects data conflicts at&#160;the&#160;granularity of a&#160;cache&#160;line,&#160;unrelated&#160;<br/>data locations&#160;placed&#160;in the&#160;same cache line&#160;will&#160;be&#160;detected&#160;as conflicts. Transactional aborts&#160;may&#160;also occur&#160;due&#160;<br/>to limited transactional&#160;resources. For example, the&#160;amount of data accessed&#160;in the&#160;region&#160;may exceed&#160;an&#160;imple-<br/>mentation-specific capacity.&#160;Additionally, some&#160;instructions and system events&#160;may cause&#160;transactional&#160;aborts.&#160;</p>
<p style="position:absolute;top:482px;left:68px;white-space:nowrap" class="ft04">16.2.1&#160;</p>
<p style="position:absolute;top:482px;left:148px;white-space:nowrap" class="ft04">HLE Software&#160;Interface</p>
<p style="position:absolute;top:511px;left:68px;white-space:nowrap" class="ft05">HLE provides two new instruction prefix hints:&#160;XACQUIRE and&#160;XRELEASE.&#160;<br/>The programmer uses&#160;the XACQUIRE&#160;prefix&#160;in&#160;front&#160;of&#160;the instruction that&#160;is used to&#160;acquire&#160;the lock that&#160;is&#160;<br/>protecting the&#160;critical section. The processor treats the&#160;indication as&#160;a hint to&#160;elide the&#160;write associated with the&#160;<br/>lock acquire&#160;operation.&#160;Even though the&#160;lock acquire&#160;has an&#160;associated&#160;write&#160;operation to&#160;the lock,&#160;the processor&#160;<br/>does&#160;not add the&#160;address of the&#160;lock to the transactional&#160;region’s&#160;write-set nor&#160;does&#160;it issue&#160;any write&#160;requests&#160;to&#160;<br/>the lock. Instead,&#160;the address&#160;of&#160;the lock is&#160;added&#160;to the&#160;read-set.&#160;The logical processor enters&#160;transactional execu-<br/>tion. If&#160;the lock was available&#160;before&#160;the&#160;XACQUIRE&#160;prefixed&#160;instruction,&#160;all other&#160;processors&#160;will continue&#160;to see&#160;it&#160;<br/>as available&#160;afterwards.&#160;Since&#160;the transactionally&#160;executing&#160;logical processor neither added&#160;the address&#160;of the&#160;lock&#160;<br/>to&#160;its write-set&#160;nor performed externally visible write&#160;operations to&#160;it,&#160;other logical processors can read the&#160;lock&#160;<br/>without causing&#160;a data&#160;conflict. This&#160;allows&#160;other logical processors&#160;to also enter and&#160;concurrently execute the&#160;crit-<br/>ical section protected&#160;by&#160;the lock.&#160;The&#160;processor&#160;automatically detects&#160;any data conflicts that&#160;occur&#160;during&#160;the&#160;<br/>transactional execution and&#160;will&#160;perform a&#160;transactional abort&#160;if necessary.<br/>Even though the&#160;eliding&#160;processor did not perform&#160;any external write operations to the lock, the&#160;hardware ensures&#160;<br/>program&#160;order of operations&#160;on&#160;the lock.&#160;If&#160;the&#160;eliding processor itself&#160;reads&#160;the&#160;value&#160;of the&#160;lock in the&#160;critical&#160;<br/>section, it&#160;will&#160;appear as&#160;if&#160;the processor had acquired the&#160;lock, i.e. the&#160;read&#160;will return&#160;the&#160;non-elided&#160;value. This&#160;<br/>behavior makes&#160;an HLE execution&#160;functionally equivalent to&#160;an&#160;execution without the&#160;HLE&#160;prefixes.<br/>The programmer uses&#160;the XRELEASE&#160;prefix in front&#160;of&#160;the&#160;instruction&#160;that is used to release the&#160;lock&#160;protecting the&#160;<br/>critical section. This&#160;involves&#160;a write to&#160;the lock. If the&#160;instruction&#160;is restoring the&#160;value of the&#160;lock&#160;to&#160;the&#160;value it&#160;<br/>had prior to the&#160;XACQUIRE prefixed&#160;lock&#160;acquire&#160;operation&#160;on&#160;the&#160;same lock, then&#160;the&#160;processor&#160;elides the&#160;external&#160;<br/>write request associated with&#160;the&#160;release of the lock and does not add the address of&#160;the lock to the write-set.&#160;The&#160;<br/>processor then&#160;attempts&#160;to commit the&#160;transactional execution.&#160;<br/>With&#160;HLE, if&#160;multiple threads execute critical sections&#160;protected&#160;by the&#160;same&#160;lock but they do&#160;not perform&#160;any&#160;<br/>conflicting&#160;operations on each other’s data, then&#160;the threads can&#160;execute&#160;concurrently&#160;and without&#160;serialization.&#160;<br/>Even though the&#160;software&#160;uses lock acquisition&#160;operations&#160;on&#160;a common lock, the hardware recognizes&#160;this,&#160;elides&#160;<br/>the lock,&#160;and&#160;executes&#160;the critical sections&#160;on the&#160;two threads without requiring any&#160;communication through the&#160;<br/>lock — if such&#160;communication was&#160;dynamically&#160;unnecessary.<br/>If the&#160;processor&#160;is unable&#160;to execute the&#160;region&#160;transactionally,&#160;it will execute the&#160;region&#160;non-transactionally&#160;and&#160;<br/>without&#160;elision. HLE enabled&#160;software has&#160;the same&#160;forward&#160;progress&#160;guarantees as&#160;the underlying non-HLE&#160;lock-<br/>based execution. For successful HLE execution, the lock&#160;and&#160;the critical section code must&#160;follow&#160;certain guidelines&#160;<br/>(discussed&#160;<a href="o_7281d5ea06a5b67a-384.html">in Section 16.3.3&#160;</a><a href="o_7281d5ea06a5b67a-386.html">and Section 16.3.8).</a>&#160;These&#160;guidelines only affect performance;&#160;not following these&#160;<br/>guidelines will not&#160;cause a&#160;functional&#160;failure.</p>
</div>
</body>
</html>
