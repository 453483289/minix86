<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1985</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:18px;font-family:Times;color:#000000;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft05{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1985-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_b5573232dd8f14811985.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">GETSEC[ENTERACCS] - Execute Authenticated Chipset Code</p>
<p style="position:absolute;top:47px;left:615px;white-space:nowrap" class="ft01">SAFER&#160;MODE&#160;EXTENSIONS&#160;REFERENCE</p>
<p style="position:absolute;top:1103px;left:770px;white-space:nowrap" class="ft00">Vol. 2D&#160;6-11</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft02">•</p>
<p style="position:absolute;top:100px;left:95px;white-space:nowrap" class="ft03">Begin&#160;execution in&#160;the authenticated code module&#160;at the defined entry point.</p>
<p style="position:absolute;top:124px;left:69px;white-space:nowrap" class="ft04">The GETSEC[ENTERACCS] function&#160;requires two additional input&#160;parameters in&#160;the general&#160;purpose&#160;registers EBX&#160;<br/>and ECX. EBX holds the authenticated code (AC) module&#160;physical base&#160;address (the&#160;AC module&#160;must reside below&#160;<br/>4 GBytes in&#160;physical&#160;address space) and&#160;ECX holds&#160;the AC&#160;module&#160;size (in&#160;bytes). The physical base address&#160;and&#160;<br/>size are&#160;used to retrieve&#160;the&#160;code&#160;module&#160;from system&#160;memory and&#160;load&#160;it into the&#160;internal authenticated code&#160;<br/>execution area.&#160;The base&#160;physical&#160;address is&#160;checked&#160;to verify it&#160;is on a&#160;modulo-4096 byte&#160;boundary.&#160;The size&#160;is&#160;<br/>verified&#160;to&#160;be&#160;a&#160;multiple&#160;of&#160;64,&#160;that&#160;it&#160;does&#160;not&#160;exceed&#160;the internal authenticated code execution&#160;area capacity&#160;(as&#160;<br/>reported&#160;by&#160;GETSEC[CAPABILITIES]),&#160;and that the top&#160;address of&#160;the AC module does not exceed&#160;32 bits.&#160;An error&#160;<br/>condition&#160;results in&#160;an abort&#160;of&#160;the authenticated code execution launch and&#160;the signaling of a&#160;general protection&#160;<br/>exception.<br/>As an&#160;integrity check&#160;for&#160;proper processor hardware&#160;operation,&#160;execution of GETSEC[ENTERACCS] will&#160;also&#160;check&#160;<br/>the contents&#160;of&#160;all the&#160;machine check&#160;status registers (as&#160;reported&#160;by&#160;the MSRs&#160;IA32_MCi_STATUS) for&#160;any valid&#160;<br/>uncorrectable&#160;error condition. In&#160;addition, the&#160;global&#160;machine&#160;check status&#160;register IA32_MCG_STATUS&#160;MCIP&#160;bit&#160;<br/>must be cleared&#160;and&#160;the IERR&#160;processor package&#160;pin (or&#160;its equivalent)&#160;must not be asserted, indicating that&#160;no&#160;<br/>machine&#160;check&#160;exception processing&#160;is currently in&#160;progress. These checks&#160;are&#160;performed&#160;prior to&#160;initiating the&#160;<br/>load of the authenticated code module. Any outstanding&#160;valid uncorrectable machine check error condition present&#160;<br/>in these&#160;status registers&#160;at this&#160;point will result in the&#160;processor&#160;signaling&#160;a general&#160;protection&#160;violation.<br/>The ILP masks the response&#160;to the assertion of the external signals INIT#,&#160;A20M, NMI#, and SMI#. This masking&#160;<br/>remains&#160;active&#160;until optionally&#160;unmasked by&#160;GETSEC[EXITAC]&#160;(this&#160;defined&#160;unmasking&#160;behavior assumes&#160;<br/>GETSEC[ENTERACCS]&#160;was not&#160;executed&#160;by a&#160;prior GETSEC[SENTER]). The&#160;purpose&#160;of&#160;this&#160;masking control is&#160;to&#160;<br/>prevent exposure to existing external&#160;event handlers that&#160;may not be under the control of the authenticated code&#160;<br/>module.&#160;<br/>The ILP sets an&#160;internal flag&#160;to&#160;indicate it&#160;has&#160;entered authenticated code execution&#160;mode. The state&#160;of&#160;the&#160;A20M&#160;<br/>pin is likewise masked&#160;and forced internally to a de-asserted&#160;state so that any external assertion is not recognized&#160;<br/>during authenticated code execution&#160;mode.&#160;<br/>To&#160;prevent other (logical) processors from interfering with&#160;the ILP operating in authenticated&#160;code execution mode,&#160;<br/>memory (excluding implicit write-back&#160;transactions) access and&#160;I/O originating&#160;from&#160;other processor agents are&#160;<br/>blocked. This protection&#160;starts when&#160;the ILP enters into&#160;authenticated code execution mode.&#160;Only memory and I/O&#160;<br/>transactions initiated from the&#160;ILP are&#160;allowed to&#160;proceed.&#160;Exiting authenticated code&#160;execution&#160;mode is&#160;done&#160;by&#160;<br/>executing&#160;GETSEC[EXITAC].&#160;The&#160;protection of memory&#160;and&#160;I/O activities&#160;remains in effect&#160;until the&#160;ILP&#160;executes&#160;<br/>GETSEC[EXITAC].<br/>Prior&#160;to launching&#160;the authenticated execution&#160;module using&#160;GETSEC[ENTERACCS]&#160;or GETSEC[SENTER], the&#160;<br/>processor’s MTRRs&#160;(Memory&#160;Type Range Registers) must first&#160;be&#160;initialized to&#160;map out&#160;the authenticated RAM&#160;<br/>addresses&#160;as WB (writeback). Failure&#160;to do&#160;so may affect&#160;the ability for the&#160;processor&#160;to maintain&#160;isolation&#160;of&#160;the&#160;<br/>loaded authenticated code&#160;module. If&#160;the&#160;processor detected&#160;this requirement is&#160;not&#160;met,&#160;it will signal an&#160;Intel®&#160;<br/>TXT&#160;reset&#160;condition&#160;with an&#160;error code during&#160;the loading of&#160;the authenticated code module.<br/>While physical addresses within&#160;the&#160;load&#160;module must be&#160;mapped as WB, the memory type&#160;for locations outside of&#160;<br/>the module&#160;boundaries&#160;must be&#160;mapped&#160;to one&#160;of&#160;the&#160;supported memory&#160;types as&#160;returned by GETSEC[PARAME-<br/>TERS] (or&#160;UC as&#160;default).<br/>To&#160;conform to the minimum granularity of MTRR&#160;MSRs&#160;for&#160;specifying&#160;the memory&#160;type, authenticated code RAM&#160;<br/>(ACRAM) is allocated to the processor&#160;in&#160;4096&#160;byte&#160;granular blocks.&#160;If an&#160;AC module&#160;size as specified in ECX is not&#160;<br/>a multiple of 4096 then the processor will&#160;allocate&#160;up&#160;to the next 4096&#160;byte boundary for mapping&#160;as&#160;ACRAM with&#160;<br/>indeterminate data. This pad area&#160;will not be visible to the&#160;authenticated code&#160;module as external memory nor can&#160;<br/>it depend on the&#160;value&#160;of the&#160;data&#160;used&#160;to fill the&#160;pad area.<br/>At&#160;the successful completion of GETSEC[ENTERACCS], the architectural state of&#160;the&#160;processor is partially initialized&#160;<br/>from contents&#160;held in&#160;the header&#160;of&#160;the authenticated code module. The processor GDTR, CS,&#160;and&#160;DS&#160;selectors are&#160;<br/>initialized from fields within the authenticated code module.&#160;Since the authenticated code module must&#160;be relocat-<br/>able, all address&#160;references must&#160;be relative&#160;to the authenticated&#160;code module base address in&#160;EBX. The processor&#160;<br/>GDTR base value&#160;is initialized&#160;to&#160;the&#160;AC module header&#160;field GDTBasePtr + module&#160;base&#160;address held in&#160;EBX and&#160;<br/>the GDTR limit&#160;is set&#160;to the&#160;value&#160;in the&#160;GDTLimit field.&#160;The CS&#160;selector&#160;is initialized&#160;to&#160;the AC&#160;module header&#160;<br/>SegSel&#160;field, while the&#160;DS selector is&#160;initialized to CS + 8.&#160;The&#160;segment descriptor fields are&#160;implicitly initialized to&#160;<br/>BASE=0, LIMIT=FFFFFh, G=1, D=1, P=1,&#160;S=1, read/write access for DS,&#160;and execute/read&#160;access&#160;for&#160;CS. The&#160;<br/>processor begins&#160;the authenticated code module&#160;execution&#160;with the&#160;EIP set to&#160;the AC&#160;module header EntryPoint&#160;<br/>field + module base address&#160;(EBX).&#160;The AC&#160;module based&#160;fields&#160;used&#160;for initializing&#160;the processor state are checked&#160;<br/>for consistency&#160;and any&#160;failure results&#160;in a&#160;shutdown condition.</p>
</div>
</body>
</html>
