<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 616</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:11px;font-family:Times;color:#000000;}
	.ft05{font-size:18px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page616-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_b5573232dd8f1481616.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:784px;white-space:nowrap" class="ft00">JMPâ€”Jump</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">INSTRUCTION SET REFERENCE, A-L</p>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">3-488&#160;Vol. 2A</p>
<p style="position:absolute;top:100px;left:68px;white-space:nowrap" class="ft06">value&#160;of the instruction pointer in&#160;the EIP&#160;register). A near jump&#160;to&#160;a&#160;relative&#160;offset&#160;of 8-bits&#160;(<i>rel8</i>) is referred&#160;to as&#160;<br/>a short&#160;jump. The CS&#160;register&#160;is&#160;not&#160;changed on near&#160;and short&#160;jumps.<br/>An absolute&#160;offset&#160;is specified indirectly in a&#160;general-purpose register or a memory location (<i>r/m16</i>&#160;or&#160;<i>r/m32</i>). The&#160;<br/>operand-size attribute determines&#160;the size&#160;of&#160;the target&#160;operand&#160;(16 or 32&#160;bits).&#160;Absolute offsets&#160;are loaded&#160;<br/>directly into the&#160;EIP&#160;register. If the&#160;operand-size attribute&#160;is 16,&#160;the upper two bytes&#160;of&#160;the EIP&#160;register are&#160;cleared,&#160;<br/>resulting&#160;in a maximum&#160;instruction&#160;pointer&#160;size&#160;of 16&#160;bits.<br/>A&#160;relative&#160;offset (<i>rel8, rel16</i>, or&#160;<i>rel32</i>)&#160;is generally&#160;specified as&#160;a label in&#160;assembly&#160;code, but at&#160;the&#160;machine code&#160;<br/>level, it&#160;is encoded&#160;as a&#160;signed 8-, 16-,&#160;or 32-bit&#160;immediate&#160;value.&#160;This&#160;value&#160;is added to&#160;the&#160;value in&#160;the EIP&#160;<br/>register.&#160;(Here,&#160;the&#160;EIP register&#160;contains the&#160;address of&#160;the&#160;instruction&#160;following&#160;the JMP instruction). When using&#160;<br/>relative offsets, the&#160;opcode&#160;(for short vs.&#160;near jumps)&#160;and the&#160;operand-size&#160;attribute (for near&#160;relative&#160;jumps)&#160;<br/>determines&#160;the&#160;size of the&#160;target&#160;operand (8,&#160;16,&#160;or&#160;32&#160;bits).</p>
<p style="position:absolute;top:308px;left:68px;white-space:nowrap" class="ft04"><b>Far Jumps in&#160;Real-Address&#160;or&#160;Virtual-8086 Mode.</b></p>
<p style="position:absolute;top:304px;left:379px;white-space:nowrap" class="ft02">&#160;When&#160;executing&#160;a far jump in&#160;real-address&#160;or virtual-8086 mode,&#160;</p>
<p style="position:absolute;top:321px;left:68px;white-space:nowrap" class="ft06">the processor jumps to&#160;the code segment and&#160;offset&#160;specified&#160;with&#160;the target operand. Here&#160;the target operand&#160;<br/>specifies an absolute far&#160;address either&#160;directly&#160;with&#160;a pointer&#160;(<i>ptr16:16</i>&#160;or&#160;<i>ptr16:32</i>) or indirectly with&#160;a memory&#160;<br/>location (<i>m16:16</i>&#160;or&#160;<i>m16:32</i>). With&#160;the pointer method, the&#160;segment&#160;and&#160;address of the&#160;called&#160;procedure&#160;is&#160;<br/>encoded in&#160;the&#160;instruction,&#160;using a 4-byte (16-bit operand size) or 6-byte (32-bit operand&#160;size) far address imme-<br/>diate. With&#160;the indirect method, the&#160;target&#160;operand specifies a&#160;memory location&#160;that&#160;contains a&#160;4-byte (16-bit&#160;<br/>operand&#160;size)&#160;or 6-byte&#160;(32-bit operand&#160;size) far address.&#160;The far address&#160;is loaded&#160;directly&#160;into the&#160;CS&#160;and&#160;EIP&#160;<br/>registers.&#160;If the&#160;operand-size&#160;attribute&#160;is&#160;16,&#160;the upper two bytes&#160;of&#160;the&#160;EIP register&#160;are cleared.</p>
<p style="position:absolute;top:448px;left:68px;white-space:nowrap" class="ft04"><b>Far Jumps in&#160;Protected&#160;Mode.</b></p>
<p style="position:absolute;top:444px;left:258px;white-space:nowrap" class="ft02">&#160;When&#160;the processor is&#160;operating in&#160;protected mode,&#160;the JMP instruction&#160;can&#160;be&#160;used&#160;</p>
<p style="position:absolute;top:460px;left:68px;white-space:nowrap" class="ft02">to perform&#160;the following three&#160;types&#160;of far jumps:</p>
<p style="position:absolute;top:482px;left:68px;white-space:nowrap" class="ft05">â€¢</p>
<p style="position:absolute;top:483px;left:93px;white-space:nowrap" class="ft02">A far jump&#160;to&#160;a conforming&#160;or non-conforming&#160;code&#160;segment.</p>
<p style="position:absolute;top:505px;left:68px;white-space:nowrap" class="ft05">â€¢</p>
<p style="position:absolute;top:505px;left:93px;white-space:nowrap" class="ft02">A far jump&#160;through a&#160;call gate.</p>
<p style="position:absolute;top:527px;left:68px;white-space:nowrap" class="ft05">â€¢</p>
<p style="position:absolute;top:528px;left:93px;white-space:nowrap" class="ft02">A task switch.</p>
<p style="position:absolute;top:552px;left:68px;white-space:nowrap" class="ft06">(The JMP instruction&#160;cannot&#160;be&#160;used&#160;to&#160;perform inter-privilege-level far&#160;jumps.)<br/>In&#160;protected mode,&#160;the processor always uses&#160;the segment&#160;selector part&#160;of&#160;the far&#160;address to access the&#160;corre-<br/>sponding descriptor in&#160;the GDT or LDT.&#160;The descriptor type&#160;(code&#160;segment, call gate, task gate, or&#160;TSS) and access&#160;<br/>rights&#160;determine&#160;the type of jump to&#160;be&#160;performed.<br/>If the&#160;selected&#160;descriptor&#160;is for a&#160;code&#160;segment, a&#160;far&#160;jump&#160;to&#160;a code segment at&#160;the same privilege level&#160;is&#160;<br/>performed. (If&#160;the selected&#160;code segment is at a different privilege&#160;level and the code&#160;segment is non-conforming,&#160;<br/>a&#160;general-protection&#160;exception is&#160;generated.) A far jump&#160;to the&#160;same&#160;privilege&#160;level in protected mode&#160;is very&#160;<br/>similar to&#160;one carried out in&#160;real-address or virtual-8086 mode. The target operand&#160;specifies&#160;an absolute far&#160;<br/>address&#160;either directly&#160;with&#160;a pointer (<i>ptr16:16</i>&#160;or&#160;<i>ptr16:32</i>)&#160;or&#160;indirectly&#160;with&#160;a&#160;memory&#160;location&#160;(<i>m16:16</i>&#160;or&#160;<br/><i>m16:32</i>).&#160;The&#160;operand-size&#160;attribute&#160;determines&#160;the size&#160;of the&#160;offset (16&#160;or 32&#160;bits)&#160;in&#160;the far address.&#160;The new&#160;<br/>code&#160;segment&#160;selector and its descriptor&#160;are&#160;loaded into&#160;CS&#160;register, and the&#160;offset&#160;from the instruction is&#160;loaded&#160;<br/>into the EIP&#160;register. Note&#160;that a call&#160;gate&#160;(described&#160;in&#160;the&#160;next paragraph) can also&#160;be used&#160;to&#160;perform far&#160;call&#160;to&#160;<br/>a code&#160;segment&#160;at&#160;the&#160;same&#160;privilege&#160;level. Using this&#160;mechanism provides&#160;an&#160;extra level of&#160;indirection and&#160;is the&#160;<br/>preferred&#160;method&#160;of&#160;making&#160;jumps&#160;between 16-bit&#160;and&#160;32-bit code&#160;segments.<br/>When executing&#160;a far&#160;jump through a call gate, the&#160;segment&#160;selector specified by the target operand identifies&#160;the&#160;<br/>call gate. (The&#160;offset&#160;part&#160;of the&#160;target&#160;operand is&#160;ignored.) The&#160;processor then jumps to&#160;the code segment speci-<br/>fied in the&#160;call gate descriptor and begins executing the&#160;instruction at the&#160;offset specified in the&#160;call&#160;gate.&#160;No stack&#160;<br/>switch&#160;occurs.&#160;Here&#160;again,&#160;the&#160;target&#160;operand can&#160;specify&#160;the far address&#160;of&#160;the&#160;call gate either directly&#160;with&#160;a&#160;<br/>pointer (<i>ptr16:16</i>&#160;or&#160;<i>ptr16:32</i>)&#160;or indirectly&#160;with&#160;a memory location (<i>m16:16</i>&#160;or&#160;<i>m16:32</i>).<br/>Executing a task switch with the JMP&#160;instruction is somewhat similar to executing a jump through a call gate. Here&#160;<br/>the&#160;target operand specifies&#160;the segment selector of the task gate for the&#160;task being switched to&#160;(and the&#160;offset&#160;<br/>part&#160;of&#160;the target operand&#160;is ignored).&#160;The&#160;task gate&#160;in&#160;turn&#160;points to&#160;the TSS for the task,&#160;which contains&#160;the&#160;<br/>segment selectors for the taskâ€™s&#160;code and stack segments.&#160;The&#160;TSS also contains&#160;the EIP value for the next instruc-<br/>tion that was to be executed&#160;before&#160;the task&#160;was suspended. This instruction pointer&#160;value&#160;is&#160;loaded into the&#160;EIP&#160;<br/>register&#160;so that&#160;the task begins&#160;executing&#160;again at&#160;this next instruction.&#160;<br/>The&#160;JMP&#160;instruction&#160;can&#160;also specify the segment selector of&#160;the&#160;TSS&#160;directly, which&#160;eliminates the&#160;indirection of the&#160;<br/>task gate.&#160;<a href="þÿ">See Chapter 7 in&#160;<i>IntelÂ®&#160;64&#160;and IA-32&#160;Architectures&#160;Software Developerâ€™s Manual, Volume&#160;3A</i>, for&#160;<br/></a>detailed&#160;information on the&#160;mechanics of a&#160;task switch.</p>
</div>
</body>
</html>
