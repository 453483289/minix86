<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1220</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:18px;font-family:Times;color:#000000;}
	.ft04{font-size:16px;font-family:Times;color:#000000;}
	.ft05{font-size:18px;font-family:Times;color:#0860a8;}
	.ft06{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1220-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce1220.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">31-10&#160;Vol. 3C</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">VIRTUAL-MACHINE MONITOR PROGRAMMING CONSIDERATIONS</p>
<p style="position:absolute;top:100px;left:93px;white-space:nowrap" class="ft06">should&#160;set bit&#160;3&#160;(blocking&#160;by NMI)&#160;in the&#160;interruptibility-state field&#160;(using&#160;VMREAD&#160;and VMWRITE)&#160;before&#160;<br/>resuming guest software.&#160;</p>
<p style="position:absolute;top:139px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:139px;left:93px;white-space:nowrap" class="ft07">Bit&#160;31&#160;(valid) of the&#160;IDT-vectoring&#160;information field&#160;indicates,&#160;if&#160;set, that the exception causing the&#160;VM&#160;exit&#160;<br/>occurred while&#160;another event&#160;was being delivered&#160;to guest software. The VMM should&#160;ensure&#160;that&#160;the other&#160;<br/>event is&#160;delivered&#160;when guest software&#160;is resumed.&#160;It&#160;can&#160;do&#160;so using&#160;the VM-entry&#160;event injection described&#160;<br/><a href="o_fe12b1e2a880e0ce-1110.html">in Section 26.5&#160;</a>and&#160;detailed in&#160;the following paragraphs:<br/>—&#160;The VMM&#160;can copy (using&#160;VMREAD&#160;and VMWRITE)&#160;the contents&#160;of the&#160;IDT-vectoring information&#160;field&#160;</p>
<p style="position:absolute;top:229px;left:119px;white-space:nowrap" class="ft06">(which&#160;is presumed&#160;valid) to&#160;the VM-entry interruption-information field (which, if&#160;valid,&#160;will&#160;cause the&#160;<br/>exception&#160;to be&#160;delivered&#160;as part of the&#160;next&#160;VM&#160;entry).</p>
<p style="position:absolute;top:271px;left:119px;white-space:nowrap" class="ft04">•</p>
<p style="position:absolute;top:270px;left:144px;white-space:nowrap" class="ft02">The VMM should ensure that reserved&#160;bits 30:12 in&#160;the VM-entry interruption-information field are 0. In&#160;</p>
<p style="position:absolute;top:286px;left:143px;white-space:nowrap" class="ft06">particular, the value of bit 12&#160;in the IDT-vectoring&#160;information field is undefined after all&#160;VM&#160;exits.&#160;If&#160;this&#160;<br/>bit&#160;is copied&#160;as 1&#160;into the VM-entry interruption-information field,&#160;the&#160;next VM&#160;entry will fail because the&#160;<br/>bit&#160;should&#160;be&#160;0.</p>
<p style="position:absolute;top:345px;left:119px;white-space:nowrap" class="ft04">•</p>
<p style="position:absolute;top:343px;left:144px;white-space:nowrap" class="ft02">If the “virtual NMIs”&#160;VM-execution control is 1 and&#160;the&#160;value of bits&#160;10:8&#160;(interruption type)&#160;in the IDT-</p>
<p style="position:absolute;top:360px;left:143px;white-space:nowrap" class="ft06">vectoring information field is 2 (indicating NMI), the&#160;VM&#160;exit occurred&#160;during delivery of an NMI that had&#160;<br/>been injected as part of the&#160;previous VM&#160;entry.&#160;In&#160;this case, bit&#160;3&#160;(blocking by NMI) will be&#160;1 in the inter-<br/>ruptibility-state field in&#160;the VMCS. The VMM&#160;should clear this bit; otherwise, the&#160;next VM&#160;entry&#160;will&#160;fail&#160;<br/>(see<a href="o_fe12b1e2a880e0ce-1104.html">&#160;Section 26.3.1.5).</a></p>
<p style="position:absolute;top:433px;left:93px;white-space:nowrap" class="ft02">—&#160;The&#160;VMM can&#160;also copy the&#160;contents of the&#160;IDT-vectoring&#160;error-code field to&#160;the&#160;VM-entry&#160;exception&#160;error-</p>
<p style="position:absolute;top:450px;left:119px;white-space:nowrap" class="ft02">code field.&#160;This need not&#160;be&#160;done if&#160;bit 11 (error&#160;code&#160;valid) is&#160;clear in&#160;the IDT-vectoring&#160;information field.</p>
<p style="position:absolute;top:474px;left:93px;white-space:nowrap" class="ft02">—&#160;The&#160;VMM can&#160;also copy the&#160;contents of the&#160;VM-exit&#160;instruction-length&#160;field to&#160;the VM-entry instruction-</p>
<p style="position:absolute;top:490px;left:119px;white-space:nowrap" class="ft06">length field.&#160;This need&#160;be&#160;done only if&#160;bits 10:8&#160;(interruption type) in&#160;the&#160;IDT-vectoring&#160;information field&#160;<br/>indicate either&#160;software interrupt,&#160;privileged&#160;software exception, or&#160;software&#160;exception.</p>
<p style="position:absolute;top:562px;left:68px;white-space:nowrap" class="ft05">31.8 MULTI-PROCESSOR&#160;</p>
<p style="position:absolute;top:562px;left:330px;white-space:nowrap" class="ft05">CONSIDERATIONS</p>
<p style="position:absolute;top:598px;left:68px;white-space:nowrap" class="ft07">The&#160;most&#160;common&#160;VMM design will be the&#160;symmetric VMM.&#160;This&#160;type&#160;of&#160;VMM runs the&#160;same&#160;VMM binary on&#160;all&#160;<br/>logical&#160;processors. Like&#160;a symmetric operating&#160;system, the&#160;symmetric VMM&#160;is written to&#160;ensure all&#160;critical&#160;data is&#160;<br/>updated by&#160;only&#160;one&#160;processor&#160;at a&#160;time,&#160;IO devices&#160;are accessed&#160;sequentially, and&#160;so forth.&#160;Asymmetric VMM&#160;<br/>designs&#160;are possible. For example,&#160;an&#160;asymmetric VMM&#160;may run its&#160;scheduler&#160;on one&#160;processor&#160;and run just&#160;<br/>enough of the VMM on&#160;other processors&#160;to allow the&#160;correct&#160;execution&#160;of guest VMs. The&#160;remainder of this section&#160;<br/>focuses on the&#160;multi-processor&#160;considerations&#160;for&#160;a symmetric VMM.<br/>A symmetric VMM&#160;design does not preclude&#160;asymmetry&#160;in its&#160;operations.&#160;For example,&#160;a symmetric VMM&#160;can&#160;<br/>support asymmetric allocation of logical processor resources to&#160;guests. Multiple logical processors can be&#160;brought&#160;<br/>into&#160;a single guest environment to&#160;support&#160;an&#160;MP-aware&#160;guest&#160;OS. Because an active&#160;VMCS&#160;can not control&#160;more&#160;<br/>than&#160;one logical processor simultaneously, a symmetric VMM&#160;must make&#160;copies&#160;of its&#160;VMCS to&#160;control&#160;the&#160;VM&#160;allo-<br/>cated to support an MP-aware guest OS. Care must be taken&#160;when accessing data structures shared between these&#160;<br/>VMCSs.&#160;See<a href="o_fe12b1e2a880e0ce-1221.html">&#160;Section 31.8.4</a>.<br/>Although it may be easier to&#160;develop a VMM&#160;that assumes&#160;a fully-symmetric view&#160;of&#160;hardware&#160;capabilities (with all&#160;<br/>processors&#160;supporting&#160;the&#160;same processor feature sets,&#160;including the same&#160;revision of&#160;VMX), there are&#160;advantages&#160;<br/>in developing a&#160;VMM that&#160;comprehends&#160;different levels&#160;of&#160;VMX capability&#160;(reported&#160;by VMX&#160;capability MSRs). One&#160;<br/>possible advantage of such&#160;an&#160;approach&#160;could be that&#160;an&#160;existing software&#160;installation (VMM&#160;and guest software&#160;<br/>stack) could&#160;continue to run without requiring software&#160;upgrades to&#160;the VMM,&#160;when the&#160;software installation&#160;is&#160;<br/>upgraded to run on hardware&#160;with enhancements in the&#160;processor’s&#160;VMX capabilities. Another advantage could be&#160;<br/>that a single software&#160;installation image, consisting&#160;of&#160;a VMM&#160;and&#160;guests, could&#160;be&#160;deployed&#160;to multiple&#160;hardware&#160;<br/>platforms with varying VMX&#160;capabilities. In such&#160;cases,&#160;the&#160;VMM could&#160;fall&#160;back to&#160;a common subset&#160;of VMX&#160;<br/>features&#160;supported by all&#160;VMX revisions, or choose&#160;to understand&#160;the&#160;asymmetry of the&#160;VMX capabilities&#160;and assign&#160;<br/>VMs accordingly.&#160;<br/>This section outlines&#160;some&#160;of the&#160;considerations&#160;to&#160;keep&#160;in&#160;mind&#160;when&#160;developing&#160;an&#160;MP-aware&#160;VMM.</p>
</div>
</body>
</html>
