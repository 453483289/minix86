<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1689</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:14px;font-family:Times;color:#0860a8;}
	.ft04{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft05{font-size:11px;line-height:22px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1689-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce1689.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:769px;white-space:nowrap" class="ft00">Vol. 3C&#160;36-5</p>
<p style="position:absolute;top:47px;left:685px;white-space:nowrap" class="ft01">INTEL®&#160;PROCESSOR TRACE</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft05">CPL&#160;filtering ensures&#160;that no&#160;IPs or&#160;other architectural state&#160;information associated&#160;with&#160;the&#160;filtered&#160;CPL can be&#160;<br/>seen in&#160;the log. For example,&#160;if&#160;the processor is&#160;configured&#160;to trace only when&#160;CPL&#160;&gt;&#160;0,&#160;and&#160;software executes&#160;<br/>SYSCALL (changing&#160;the CPL to 0),&#160;the&#160;destination&#160;IP of the&#160;SYSCALL will be&#160;suppressed&#160;from the&#160;generated packet&#160;<br/>(see&#160;the discussion of TIP.PGD&#160;<a href="o_fe12b1e2a880e0ce-1726.html">in Section 36.4.2.5).<br/></a>It should&#160;be&#160;noted&#160;that&#160;CPL&#160;is always 0&#160;in real-address&#160;mode&#160;and&#160;that CPL&#160;is&#160;always&#160;3&#160;in&#160;virtual-8086&#160;mode.&#160;To&#160;<br/>trace&#160;code&#160;in these&#160;modes, filtering&#160;should be configured&#160;accordingly.<br/>When software&#160;is executing in&#160;a non-enabled CPL,&#160;ContextEn&#160;is cleared.&#160;See&#160;<a href="o_fe12b1e2a880e0ce-1691.html">Section&#160;36.2.5.1</a>&#160;for details.</p>
<p style="position:absolute;top:256px;left:69px;white-space:nowrap" class="ft03">36.2.4.2 &#160;&#160;Filtering by&#160;CR3</p>
<p style="position:absolute;top:283px;left:69px;white-space:nowrap" class="ft04">Intel PT supports a&#160;CR3-filtering mechanism by&#160;which the generation of packets containing architectural&#160;states can&#160;<br/>be&#160;enabled or&#160;disabled&#160;based&#160;on the&#160;value&#160;of CR3.&#160;A&#160;debugger&#160;can use&#160;CR3 filtering&#160;to trace only&#160;a&#160;single&#160;applica-<br/>tion&#160;without context switching&#160;the state of&#160;the&#160;RTIT&#160;MSRs. For the&#160;reconstruction of&#160;traces from software&#160;with&#160;<br/>multiple threads,&#160;debug software&#160;may wish to&#160;context-switch&#160;for&#160;the state of the RTIT&#160;MSRs (if the operating&#160;<br/>system does&#160;not provide context-switch support)&#160;to separate the&#160;output for the&#160;<a href="o_fe12b1e2a880e0ce-1714.html">different threads (see Section&#160;<br/>36.3.5,&#160;“Context Switch Consideration”).<br/></a>To&#160;trace&#160;for&#160;only&#160;a single&#160;CR3 value,&#160;software&#160;can write that&#160;value&#160;to the&#160;IA32_RTIT_CR3_MATCH&#160;MSR,&#160;and set&#160;<br/>IA32_RTIT_CTL.CR3Filter. When CR3 value does not match IA32_RTIT_CR3_MATCH and IA32_RTIT_CTL.CR3Filter&#160;<br/>is 1,&#160;ContextEn&#160;is forced&#160;to 0,&#160;and packets&#160;containing&#160;architectural&#160;states&#160;will&#160;not be generated.&#160;Some&#160;other&#160;<br/>packets&#160;can be generated when ContextEn&#160;is&#160;0;&#160;see<a href="o_fe12b1e2a880e0ce-1691.html">&#160;Section&#160;36.2.5.3 for details.&#160;</a>When&#160;CR3&#160;does&#160;match&#160;<br/>IA32_RTIT_CR3_MATCH&#160;(or&#160;when&#160;IA32_RTIT_CTL.CR3Filter&#160;is&#160;0),&#160;CR3 filtering does not force&#160;ContextEn&#160;to 0&#160;<br/>(although it&#160;could be 0 due&#160;to other&#160;filters or&#160;modes).<br/>CR3&#160;matches&#160;IA32_RTIT_CR3_MATCH&#160;if&#160;the&#160;two registers&#160;are&#160;identical for bits 63:12,&#160;or&#160;63:5&#160;when&#160;in PAE&#160;paging&#160;<br/>mode;&#160;the&#160;lower 5&#160;bits&#160;of CR3 and&#160;IA32_RTIT_CR3_MATCH&#160;are ignored.&#160;CR3 filtering&#160;is&#160;independent of the&#160;value&#160;<br/>of CR0.PG.&#160;<br/>When CR3&#160;filtering is&#160;in use, PIP&#160;packets&#160;may&#160;still be seen&#160;in the&#160;log if&#160;the processor is&#160;configured to&#160;trace&#160;when&#160;<br/>CPL&#160;=&#160;0 (IA32_RTIT_CTL.OS&#160;=&#160;1). If&#160;not, no PIP&#160;packets&#160;will be seen.</p>
<p style="position:absolute;top:609px;left:69px;white-space:nowrap" class="ft03">36.2.4.3 &#160;&#160;Filtering by&#160;IP</p>
<p style="position:absolute;top:636px;left:69px;white-space:nowrap" class="ft04">Trace packet&#160;generation with configurable filtering by&#160;IP&#160;is&#160;supported&#160;if CPUID.(EAX=14H, ECX=0):EBX[bit 2] = 1.&#160;<br/>Intel&#160;PT can&#160;be configured to&#160;enable&#160;the generation&#160;of&#160;packets containing&#160;architectural states only&#160;when the&#160;<br/>processor&#160;is executing code within certain&#160;IP&#160;ranges. If&#160;the IP&#160;is outside of&#160;these ranges, generation of&#160;some&#160;<br/>packets is&#160;blocked.<br/>IP&#160;filtering is&#160;enabled using the&#160;ADDRn_CFG fields in&#160;the&#160;IA32_RTIT_CTL&#160;MS<a href="o_fe12b1e2a880e0ce-1700.html">R (Section 36.2.7.2</a>),&#160;where&#160;the&#160;digit&#160;<br/>'n' is&#160;a zero-based&#160;number that&#160;selects which&#160;address range&#160;is&#160;being configured.&#160;Each&#160;ADDRn_CFG field configures&#160;<br/>the use&#160;of the&#160;register&#160;pair&#160;IA32_RTIT_ADDRn_A&#160;and&#160;IA32_RTIT_ADDRn_B&#160;<a href="o_fe12b1e2a880e0ce-1704.html">(Section&#160;36.2.7.5).&#160;<br/></a>IA32_RTIT_ADDRn_A&#160;defines the base&#160;and IA32_RTIT_ADDRn_B&#160;specifies&#160;the&#160;limit of the range&#160;in which tracing is&#160;<br/>enabled. Thus&#160;each&#160;range, referred to&#160;as the&#160;ADDRn&#160;range, is&#160;defined by&#160;[IA32_RTIT_ADDRn_A.&#160;<br/>IA32_RTIT_ADDRn_B].&#160;There can&#160;be&#160;multiple such&#160;ranges, software&#160;can query&#160;<a href="o_fe12b1e2a880e0ce-1709.html">CPUID (Section 36.3.1)&#160;</a>for the&#160;<br/>number of ranges&#160;supported on a&#160;processor.&#160;<br/>Default behavior&#160;(ADDRn_CFG=0)&#160;defines no&#160;IP filter&#160;range, meaning&#160;FilterEn&#160;is&#160;always set. In&#160;this case&#160;code&#160;at&#160;<br/>any IP can be&#160;traced, though&#160;other filters, such as&#160;CR3&#160;or CPL,&#160;could limit tracing.&#160;When ADDRn_CFG&#160;is set to&#160;<br/>enable&#160;IP filtering (s<a href="o_fe12b1e2a880e0ce-1709.html">ee Section 36.3.1), tr</a>acing will commence when&#160;a&#160;taken branch or event is seen whose&#160;target&#160;<br/>address&#160;is in&#160;the ADDRn range.<br/>While&#160;inside&#160;a tracing region&#160;and with FilterEn&#160;is set, leaving the tracing region&#160;may only be&#160;detected once&#160;a taken&#160;<br/>branch or event with a&#160;target outside the range is retired.&#160;If an&#160;ADDRn range is entered or exited by executing the&#160;<br/>next sequential&#160;instruction, rather&#160;than by&#160;a control&#160;flow&#160;transfer,&#160;FilterEn&#160;may not&#160;toggle immediately.&#160;S<a href="o_fe12b1e2a880e0ce-1692.html">ee Section&#160;<br/>36.2.5.5&#160;for more&#160;</a>details&#160;on FilterEn.&#160;<br/>Note that these address&#160;range&#160;base and&#160;limit values are inclusive, such that&#160;the&#160;range includes&#160;the&#160;first and&#160;last&#160;<br/>instruction whose first&#160;instruction byte&#160;is in the&#160;ADDRn&#160;range.<br/>Depending upon&#160;processor implementation, IP filtering may&#160;be&#160;based&#160;on linear or effective address. This can cause&#160;<br/>different&#160;behavior between implementations&#160;if CSbase is&#160;not equal&#160;to zero&#160;or in real mode. See&#160;<a href="o_fe12b1e2a880e0ce-1713.html">Section&#160;36.3.1.1&#160;<br/></a>for&#160;details. Software&#160;can query CPUID to determine filters&#160;are based on linear&#160;or effective&#160;addre<a href="o_fe12b1e2a880e0ce-1709.html">ss (Section&#160;36.3.1</a>).</p>
</div>
</body>
</html>
