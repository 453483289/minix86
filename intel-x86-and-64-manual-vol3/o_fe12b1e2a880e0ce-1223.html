<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1223</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:14px;font-family:Times;color:#0860a8;}
	.ft04{font-size:16px;font-family:Times;color:#0860a8;}
	.ft05{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1223-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce1223.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:761px;white-space:nowrap" class="ft00">Vol. 3C&#160;31-13</p>
<p style="position:absolute;top:47px;left:475px;white-space:nowrap" class="ft01">VIRTUAL-MACHINE&#160;MONITOR PROGRAMMING CONSIDERATIONS</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft05">Many&#160;VMCS fields are&#160;architected to&#160;extend&#160;transparently&#160;on&#160;processors&#160;supporting&#160;Intel 64 architecture (64 bits&#160;<br/>on&#160;processors that&#160;support Intel 64 architecture, 32 bits&#160;on processors&#160;that do not). Some&#160;VMCS fields&#160;are&#160;64-bits&#160;<br/>wide&#160;regardless of whether the&#160;processor supports&#160;Intel 64 architecture&#160;or is&#160;in IA-32e mode.</p>
<p style="position:absolute;top:178px;left:69px;white-space:nowrap" class="ft03">31.9.2.1 &#160;&#160;Natural-Width VMCS Fields</p>
<p style="position:absolute;top:206px;left:69px;white-space:nowrap" class="ft05">Many&#160;VMCS&#160;fields operate using&#160;natural width.&#160;Such&#160;fields&#160;return&#160;(on reads) and&#160;set&#160;(on writes)&#160;32-bits when oper-<br/>ating in 32-bit mode and&#160;64-bits when&#160;operating in 64-bit&#160;mode. For the most&#160;part, these fields return&#160;the naturally&#160;<br/>expected&#160;data widths.&#160;The&#160;“Guest RIP” field&#160;in the&#160;VMCS&#160;guest-state area is&#160;an example&#160;of this type of field.</p>
<p style="position:absolute;top:283px;left:69px;white-space:nowrap" class="ft03">31.9.2.2 &#160;&#160;64-Bit&#160;VMCS Fields</p>
<p style="position:absolute;top:312px;left:69px;white-space:nowrap" class="ft05">Unlike natural&#160;width&#160;fields,&#160;these fields&#160;are&#160;fixed&#160;to 64-bit&#160;width&#160;on&#160;all processors.&#160;When in&#160;64-bit mode,&#160;reads&#160;of&#160;<br/>these fields&#160;return 64-bit wide&#160;data and writes to these fields write 64-bits.&#160;When outside of 64-bit mode,&#160;reads&#160;of&#160;<br/>these fields return&#160;the&#160;low&#160;32-bits and writes to&#160;these&#160;fields&#160;write the&#160;low&#160;32-bits and&#160;zero the&#160;upper 32-bits.&#160;<br/>Should a&#160;non-IA-32e mode&#160;host require access to&#160;the upper&#160;32-bits of these fields,&#160;a separate&#160;VMCS&#160;encoding&#160;is&#160;<br/>used when issuing&#160;VMREAD/VMWRITE&#160;instructions.<br/>The VMCS control&#160;field “MSR&#160;bitmap address”&#160;(which&#160;contains the&#160;physical&#160;address of a&#160;region of&#160;memory which&#160;<br/>specifies&#160;which&#160;MSR&#160;accesses&#160;should generate VM-exits) is&#160;an&#160;example of&#160;this&#160;type&#160;of field.&#160;Specifying&#160;encoding&#160;<br/>00002004H&#160;to VMREAD&#160;returns&#160;the&#160;lower 32-bits&#160;to non-IA-32e mode&#160;hosts and&#160;returns 64-bits&#160;to 64-bit&#160;hosts.&#160;<br/>The&#160;separate encoding 00002005H returns&#160;only&#160;the upper&#160;32-bits.&#160;</p>
<p style="position:absolute;top:502px;left:69px;white-space:nowrap" class="ft04">31.9.3&#160;</p>
<p style="position:absolute;top:502px;left:149px;white-space:nowrap" class="ft04">IA-32e Mode Hosts</p>
<p style="position:absolute;top:532px;left:69px;white-space:nowrap" class="ft07">An&#160;IA-32e&#160;mode&#160;host&#160;is&#160;required&#160;to&#160;support&#160;64-bit&#160;guest environments. Because activating IA-32e mode&#160;currently&#160;<br/>requires&#160;that paging be&#160;disabled&#160;temporarily and&#160;VMX entry&#160;requires&#160;paging&#160;to be&#160;enabled,&#160;IA-32e&#160;mode must be&#160;<br/>enabled&#160;before entering VMX operation.&#160;For&#160;this reason, it&#160;is not&#160;possible&#160;to&#160;toggle&#160;in&#160;and out&#160;of&#160;IA-32e&#160;mode&#160;in&#160;a&#160;<br/>VMM.<br/><a href="o_fe12b1e2a880e0ce-1214.html">Section&#160;31.5&#160;</a>describes the&#160;steps required&#160;to launch a&#160;VMM.&#160;An&#160;IA-32e mode host is&#160;also&#160;required to set the&#160;“host&#160;<br/>address-space&#160;size” VMCS VM-exit&#160;control to&#160;1.&#160;The value&#160;of&#160;this&#160;control is&#160;then loaded&#160;in the IA32_EFER.LME/LMA&#160;<br/>and CS.L bits on each&#160;VM exit. This&#160;establishes&#160;a 64-bit&#160;host environment as execution transfers to the VMM entry&#160;<br/>point. At&#160;a minimum, the&#160;entry point&#160;is required&#160;to be in&#160;a&#160;64-bit code segment.&#160;Subsequently,&#160;the&#160;VMM can,&#160;if it&#160;<br/>chooses, switch&#160;to&#160;32-bit compatibility mode&#160;on a&#160;code-s<a href="o_fe12b1e2a880e0ce-1222.html">egment basis (see Section 31.9.1</a>). Note,&#160;however,&#160;that&#160;<br/>VMX instructions other&#160;than&#160;VMCALL&#160;and VMFUNC&#160;are not&#160;supported in compatibility mode; they generate&#160;an&#160;<br/>invalid&#160;opcode&#160;exception if&#160;used.&#160;<br/>The following&#160;VMCS controls determine&#160;the value&#160;of&#160;IA32_EFER when&#160;a VM&#160;exit occurs:&#160;the “host address-space&#160;<br/>size” control (described&#160;above),&#160;the&#160;“load&#160;IA32_EFER”&#160;VM-exit control,&#160;the&#160;“VM-exit MSR-load&#160;count,”&#160;and&#160;the&#160;“VM-<br/>exit&#160;MSR-load addres<a href="o_fe12b1e2a880e0ce-1138.html">s” (see Section 27.3).<br/></a>If&#160;the&#160;“load&#160;IA32_EFER”&#160;VM-exit&#160;control&#160;is&#160;1,&#160;the value of&#160;the&#160;LME and&#160;LMA bits in the&#160;IA32_EFER field&#160;in the host-<br/>state&#160;area must be&#160;the&#160;value of&#160;the&#160;“host address-space size”&#160;VM-exit&#160;control.<br/>The&#160;loading&#160;of&#160;IA32_EFER.LME/LMA&#160;and&#160;CS.L&#160;bits&#160;established by&#160;the “host address-space&#160;size”&#160;control precede any&#160;<br/>loading&#160;of the&#160;IA32_EFER&#160;MSR due&#160;from&#160;the&#160;VM-exit MSR-load&#160;area. If IA32_EFER is specified in&#160;the&#160;VM-exit MSR-<br/>load&#160;area,&#160;the value&#160;of&#160;the LME bit in the&#160;load&#160;image&#160;of&#160;IA32_EFER&#160;should match the&#160;setting&#160;of the&#160;“host address-<br/>space&#160;size”&#160;control.&#160;Otherwise&#160;the&#160;attempt to&#160;modify&#160;the&#160;LME&#160;bit (while paging is enabled)&#160;will lead&#160;to a VMX-abort.&#160;<br/>However,&#160;IA32_EFER.LMA&#160;is&#160;always set&#160;by the&#160;processor to&#160;equal IA32_EFER.LME&#160;&amp;&#160;CR0.PG;&#160;the value&#160;specified&#160;<br/>for LMA in the&#160;load&#160;image of&#160;the IA32_EFER&#160;MSR is ignored. For these and performance reasons, VMM writers&#160;may&#160;<br/>choose&#160;to not use the&#160;VM-exit/entry&#160;MSR-load/save areas for IA32_EFER.<br/>On&#160;a&#160;VMM teardown, VMX operation should&#160;be&#160;exited before&#160;deactivating IA-32e&#160;mode if the&#160;latter&#160;is required.</p>
<p style="position:absolute;top:1000px;left:69px;white-space:nowrap" class="ft04">31.9.4&#160;</p>
<p style="position:absolute;top:1000px;left:149px;white-space:nowrap" class="ft04">IA-32e Mode Guests</p>
<p style="position:absolute;top:1030px;left:69px;white-space:nowrap" class="ft05">A 32-bit guest can be launched by either IA-32e-mode hosts or non-IA-32e-mode&#160;hosts. A 64-bit guests can only&#160;<br/>be launched&#160;by&#160;a&#160;IA-32e-mode host.</p>
</div>
</body>
</html>
