<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 430</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:16px;font-family:Times;color:#0860a8;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:14px;font-family:Times;color:#0860a8;}
	.ft05{font-size:18px;font-family:Times;color:#000000;}
	.ft06{font-size:18px;font-family:Times;color:#0860a8;}
	.ft07{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft09{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page430-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce430.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">11-18&#160;Vol. 3A</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">MEMORY&#160;CACHE CONTROL</p>
<p style="position:absolute;top:98px;left:68px;white-space:nowrap" class="ft02">11.5.6&#160;</p>
<p style="position:absolute;top:98px;left:148px;white-space:nowrap" class="ft02">L1 Data Cache Context Mode</p>
<p style="position:absolute;top:129px;left:68px;white-space:nowrap" class="ft08">L1&#160;data&#160;cache context mode&#160;is a&#160;feature&#160;of processors&#160;based on the&#160;Intel NetBurst microarchitecture that support&#160;<br/>Intel&#160;Hyper-Threading Technology. When&#160;CPUID.1:ECX[bit&#160;10]&#160;=&#160;1,&#160;the&#160;processor supports setting&#160;L1 data cache&#160;<br/>context&#160;mode using&#160;the L1&#160;data cache context mode flag&#160;( IA32_MISC_ENABLE[bit&#160;24] ). Selectable&#160;modes are&#160;<br/>adaptive&#160;mode&#160;(default)&#160;and shared mode.<br/>The&#160;BIOS is&#160;responsible for configuring&#160;the L1&#160;data cache&#160;context mode.</p>
<p style="position:absolute;top:247px;left:68px;white-space:nowrap" class="ft04">11.5.6.1 &#160;&#160;Adaptive&#160;Mode</p>
<p style="position:absolute;top:275px;left:68px;white-space:nowrap" class="ft07">Adaptive&#160;mode facilitates L1 data cache&#160;sharing between logical processors.&#160;When&#160;running&#160;in adaptive&#160;mode, the&#160;<br/>L1&#160;data&#160;cache&#160;is shared across logical processors in&#160;the same&#160;core&#160;if:</p>
<p style="position:absolute;top:313px;left:68px;white-space:nowrap" class="ft05">•</p>
<p style="position:absolute;top:314px;left:93px;white-space:nowrap" class="ft03">CR3&#160;control&#160;registers for logical processors sharing&#160;the cache&#160;are&#160;identical.</p>
<p style="position:absolute;top:336px;left:68px;white-space:nowrap" class="ft05">•</p>
<p style="position:absolute;top:337px;left:93px;white-space:nowrap" class="ft03">The&#160;same&#160;paging&#160;mode&#160;is used by logical processors sharing&#160;the cache.</p>
<p style="position:absolute;top:361px;left:68px;white-space:nowrap" class="ft07">In&#160;this situation,&#160;the entire L1 data cache&#160;is&#160;available&#160;to&#160;each logical processor (instead of being&#160;competitively&#160;<br/>shared).<br/>If CR3 values are different for the logical processors sharing&#160;an&#160;L1 data cache or the logical processors use different&#160;<br/>paging&#160;modes, processors&#160;compete for cache&#160;resources. This&#160;reduces the effective size of the&#160;cache for each logical&#160;<br/>processor.&#160;Aliasing of the&#160;cache&#160;is not allowed (which&#160;prevents data thrashing).</p>
<p style="position:absolute;top:478px;left:68px;white-space:nowrap" class="ft04">11.5.6.2 &#160;&#160;Shared Mode</p>
<p style="position:absolute;top:507px;left:68px;white-space:nowrap" class="ft07">In shared&#160;mode,&#160;the&#160;L1&#160;data&#160;cache&#160;is competitively shared&#160;between logical processors.&#160;This is&#160;true even&#160;if&#160;the&#160;<br/>logical processors use&#160;identical&#160;CR3 registers&#160;and paging&#160;modes.<br/>In shared&#160;mode,&#160;linear addresses&#160;in the L1 data&#160;cache can&#160;be aliased,&#160;meaning that one linear&#160;address in the cache&#160;<br/>can&#160;point to&#160;different physical locations. The mechanism&#160;for&#160;resolving aliasing can lead&#160;to&#160;thrashing. For this&#160;<br/>reason,&#160;IA32_MISC_ENABLE[bit&#160;24]&#160;=&#160;0 is&#160;the preferred&#160;configuration for processors based&#160;on the&#160;Intel NetBurst&#160;<br/>microarchitecture&#160;that support Intel&#160;Hyper-Threading Technology.</p>
<p style="position:absolute;top:652px;left:68px;white-space:nowrap" class="ft06">11.6 SELF-MODIFYING&#160;</p>
<p style="position:absolute;top:652px;left:311px;white-space:nowrap" class="ft06">CODE</p>
<p style="position:absolute;top:688px;left:68px;white-space:nowrap" class="ft07">A write&#160;to&#160;a memory location&#160;in&#160;a code segment that&#160;is&#160;currently cached in&#160;the processor causes&#160;the&#160;associated&#160;<br/>cache line&#160;(or lines)&#160;to be invalidated. This&#160;check is&#160;based&#160;on the physical address&#160;of&#160;the instruction.&#160;In addition,&#160;<br/>the P6 family and&#160;Pentium processors check&#160;whether&#160;a write to&#160;a code segment may modify&#160;an instruction that&#160;has&#160;<br/>been prefetched&#160;for execution.&#160;If&#160;the&#160;write&#160;affects&#160;a prefetched instruction,&#160;the prefetch queue is&#160;invalidated.&#160;This&#160;<br/>latter check is based on the&#160;linear address of the&#160;instruction. For&#160;the&#160;Pentium 4&#160;and Intel Xeon processors, a write&#160;<br/>or a snoop of an&#160;instruction in a code segment, where the&#160;target instruction is already decoded and resident in the&#160;<br/>trace&#160;cache, invalidates the entire trace cache. The latter&#160;behavior&#160;means that programs that self-modify&#160;code&#160;can&#160;<br/>cause&#160;severe&#160;degradation of performance&#160;when&#160;run&#160;on&#160;the Pentium 4 and&#160;Intel Xeon processors.<br/>In practice, the check on&#160;linear&#160;addresses should not create&#160;compatibility problems among IA-32 processors. Appli-<br/>cations that&#160;include self-modifying&#160;code use&#160;the same&#160;linear&#160;address for modifying&#160;and fetching&#160;the instruction.&#160;<br/>Systems software, such&#160;as a&#160;debugger,&#160;that might&#160;possibly modify an&#160;instruction&#160;using a&#160;different linear&#160;address&#160;<br/>than&#160;that used to fetch the&#160;instruction,&#160;will execute a serializing operation, such&#160;as a&#160;CPUID instruction, before the&#160;<br/>modified instruction is&#160;executed, which&#160;will&#160;automatically&#160;resynchronize&#160;the instruction cache and prefetch&#160;queue.&#160;<br/>(See<a href="o_fe12b1e2a880e0ce-260.html">&#160;Section 8.1.3, “Handling Self-&#160;and Cross-Modifying&#160;Code,”&#160;for more&#160;</a>information about&#160;the use&#160;of self-modi-<br/>fying&#160;code.)<br/>For Intel486&#160;processors, a&#160;write to&#160;an&#160;instruction&#160;in the&#160;cache will modify&#160;it in both&#160;the&#160;cache&#160;and memory,&#160;but if&#160;<br/>the instruction was prefetched&#160;before the&#160;write,&#160;the old version of the&#160;instruction&#160;could be the&#160;one executed. To&#160;<br/>prevent the&#160;old&#160;instruction&#160;from being&#160;executed,&#160;flush&#160;the instruction prefetch unit by coding a&#160;jump&#160;instruction&#160;<br/>immediately after&#160;any write that&#160;modifies an&#160;instruction.</p>
</div>
</body>
</html>
