<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 272</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:18px;font-family:Times;color:#000000;}
	.ft04{font-size:11px;font-family:Times;color:#000000;}
	.ft05{font-size:8px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page272-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce272.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">8-16&#160;Vol. 3A</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">MULTIPLE-PROCESSOR&#160;MANAGEMENT</p>
<p style="position:absolute;top:100px;left:68px;white-space:nowrap" class="ft06">Synchronization mechanisms in&#160;multiple-processor&#160;systems may&#160;depend&#160;upon a strong memory-ordering&#160;model.&#160;<br/>Here,&#160;a program can&#160;use a&#160;locking instruction such as&#160;the&#160;XCHG instruction&#160;or&#160;the LOCK&#160;prefix to ensure that a&#160;<br/>read-modify-write&#160;operation on memory is&#160;carried&#160;out&#160;atomically.&#160;Locking operations typically operate&#160;like&#160;I/O&#160;<br/>operations&#160;in that they wait for&#160;all&#160;previous&#160;instructions&#160;to complete&#160;and for all buffered writes to drain to memory&#160;<br/><a href="o_fe12b1e2a880e0ce-259.html">(see Section&#160;8.1.2, “Bus Locking”).<br/></a>Program synchronization&#160;can&#160;also be carried out&#160;with&#160;seri<a href="o_fe12b1e2a880e0ce-273.html">alizing instructions (see Section 8.3</a>). These instructions&#160;<br/>are&#160;typically used at&#160;critical procedure&#160;or task boundaries&#160;to force&#160;completion of all&#160;previous instructions&#160;before a&#160;<br/>jump to a&#160;new section&#160;of&#160;code or a context switch&#160;occurs. Like the I/O and&#160;locking instructions, the processor&#160;waits&#160;<br/>until all&#160;previous instructions have&#160;been completed&#160;and all buffered writes&#160;have&#160;been&#160;drained&#160;to memory before&#160;<br/>executing&#160;the serializing instruction.<br/>The&#160;SFENCE, LFENCE,&#160;and MFENCE instructions provide a&#160;performance-efficient way of ensuring&#160;load&#160;and store&#160;<br/>memory ordering&#160;between routines that produce weakly-ordered&#160;results and routines that consume&#160;that data. The&#160;<br/>functions of&#160;these instructions are&#160;as follows:</p>
<p style="position:absolute;top:335px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:336px;left:93px;white-space:nowrap" class="ft06"><b>SFENCE</b>&#160;— Serializes&#160;all store (write) operations&#160;that occurred prior&#160;to the&#160;SFENCE instruction in the program&#160;<br/>instruction stream, but&#160;does&#160;not affect load operations.</p>
<p style="position:absolute;top:374px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:375px;left:93px;white-space:nowrap" class="ft06"><b>LFENCE</b>&#160;—&#160;Serializes&#160;all&#160;load (read) operations&#160;that&#160;occurred&#160;prior to&#160;the LFENCE instruction in&#160;the program&#160;<br/>instruction stream, but&#160;does&#160;not affect store&#160;operations.</p>
<p style="position:absolute;top:389px;left:471px;white-space:nowrap" class="ft05">2</p>
<p style="position:absolute;top:413px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:414px;left:93px;white-space:nowrap" class="ft06"><b>MFENCE</b>&#160;— Serializes&#160;all store&#160;and load operations that&#160;occurred&#160;prior to&#160;the&#160;MFENCE instruction in the&#160;<br/>program instruction stream.</p>
<p style="position:absolute;top:454px;left:68px;white-space:nowrap" class="ft06">Note&#160;that&#160;the SFENCE, LFENCE,&#160;and MFENCE instructions&#160;provide&#160;a more&#160;efficient method&#160;of controlling memory&#160;<br/>ordering than&#160;the CPUID&#160;instruction.<br/>The&#160;MTRRs&#160;were introduced in&#160;the P6 family processors to&#160;define the&#160;cache&#160;characteristics&#160;for specified&#160;areas of&#160;<br/>physical&#160;memory.&#160;The following&#160;are two examples of how memory types&#160;set up with MTRRs can be&#160;used strengthen&#160;<br/>or&#160;weaken memory ordering for the&#160;Pentium&#160;4,&#160;Intel Xeon, and P6&#160;family&#160;processors:</p>
<p style="position:absolute;top:550px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:550px;left:93px;white-space:nowrap" class="ft06">The&#160;strong uncached&#160;(UC) memory type forces&#160;a strong-ordering model on&#160;memory&#160;accesses.&#160;Here,&#160;all&#160;reads&#160;<br/>and writes&#160;to the&#160;UC memory&#160;region&#160;appear on&#160;the bus&#160;and out-of-order or&#160;speculative accesses are not&#160;<br/>performed.&#160;This&#160;memory&#160;type&#160;can&#160;be&#160;applied&#160;to&#160;an address range&#160;dedicated&#160;to memory mapped&#160;I/O devices to&#160;<br/>force strong&#160;memory ordering.</p>
<p style="position:absolute;top:622px;left:68px;white-space:nowrap" class="ft03">•</p>
<p style="position:absolute;top:622px;left:93px;white-space:nowrap" class="ft06">For areas&#160;of memory&#160;where weak ordering&#160;is&#160;acceptable,&#160;the write&#160;back (WB) memory type can&#160;be&#160;chosen.&#160;<br/>Here, reads can be&#160;performed speculatively&#160;and writes can be buffered&#160;and combined. For this type of&#160;memory,&#160;<br/>cache locking&#160;is performed on&#160;atomic&#160;(locked)&#160;operations that do not split across&#160;cache&#160;lines,&#160;which&#160;helps to&#160;<br/>reduce the&#160;performance penalty associated&#160;with the&#160;use&#160;of&#160;the typical synchronization instructions,&#160;such as&#160;<br/>XCHG,&#160;that lock&#160;the&#160;bus during the&#160;entire&#160;read-modify-write operation.&#160;With the&#160;WB memory type,&#160;the XCHG&#160;<br/>instruction locks the&#160;cache&#160;instead&#160;of&#160;the bus&#160;if&#160;the memory&#160;access is&#160;contained within a&#160;cache line.</p>
<p style="position:absolute;top:729px;left:68px;white-space:nowrap" class="ft06">The PAT was introduced in the&#160;Pentium&#160;III&#160;processor&#160;to enhance&#160;the&#160;caching characteristics&#160;that can be assigned&#160;to&#160;<br/>pages or groups of pages.&#160;The PAT&#160;mechanism typically&#160;used&#160;to strengthen&#160;caching characteristics at&#160;the&#160;page&#160;level&#160;<br/>with respect&#160;to the&#160;caching characteristics established by&#160;<a href="o_fe12b1e2a880e0ce-427.html">the MTRRs. Table 11-7 shows the&#160;</a>interaction of&#160;the PAT&#160;<br/>with the&#160;MTRRs.<br/>Intel recommends&#160;that software&#160;written&#160;to run on&#160;Intel&#160;Core&#160;2 Duo,&#160;Intel Atom,&#160;Intel Core&#160;Duo,&#160;Pentium 4,&#160;Intel&#160;<br/>Xeon,&#160;and P6 family processors assume&#160;the processor-ordering&#160;model or&#160;a weaker memory-ordering model.&#160;The&#160;<br/>Intel Core 2&#160;Duo,&#160;Intel Atom, Intel&#160;Core&#160;Duo,&#160;Pentium 4,&#160;Intel Xeon, and&#160;P6 family processors&#160;do not implement&#160;a&#160;<br/>strong&#160;memory-ordering model,&#160;except when using&#160;the UC&#160;memory&#160;type. Despite the&#160;fact that Pentium 4,&#160;Intel&#160;<br/>Xeon,&#160;and P6 family processors support&#160;processor&#160;ordering,&#160;Intel does not guarantee&#160;that future processors will&#160;<br/>support&#160;this model. To&#160;make&#160;software&#160;portable&#160;to future&#160;processors, it&#160;is recommended that&#160;operating systems&#160;<br/>provide&#160;critical region and&#160;resource&#160;control&#160;constructs and&#160;API’s (application program interfaces) based&#160;on&#160;I/O,&#160;<br/>locking,&#160;and/or serializing instructions be&#160;used to synchronize&#160;access&#160;to shared&#160;areas of memory in multiple-<br/>processor systems. Also, software&#160;should not&#160;depend on&#160;processor ordering in situations&#160;where&#160;the&#160;system&#160;hard-<br/>ware does not support this&#160;memory-ordering model.</p>
<p style="position:absolute;top:988px;left:68px;white-space:nowrap" class="ft02">2.&#160;Specifically, LFENCE&#160;does not execute until&#160;all prior&#160;instructions have&#160;completed locally, and&#160;no&#160;later&#160;instruction&#160;begins&#160;execution&#160;</p>
<p style="position:absolute;top:1005px;left:89px;white-space:nowrap" class="ft02">until LFENCE completes.&#160;As a result, an&#160;instruction that&#160;loads&#160;from memory&#160;and that&#160;precedes&#160;an&#160;LFENCE&#160;receives data&#160;from&#160;mem-</p>
<p style="position:absolute;top:1021px;left:89px;white-space:nowrap" class="ft02">ory prior&#160;to&#160;completion&#160;of&#160;the&#160;LFENCE.&#160;An&#160;LFENCE&#160;that&#160;follows&#160;an&#160;instruction&#160;that&#160;stores&#160;to&#160;memory&#160;might complete&#160;before&#160;the&#160;data&#160;</p>
<p style="position:absolute;top:1038px;left:89px;white-space:nowrap" class="ft02">being stored&#160;have&#160;become globally visible.&#160;Instructions&#160;following&#160;an&#160;LFENCE may be&#160;fetched&#160;from&#160;memory before&#160;the&#160;LFENCE, but&#160;</p>
<p style="position:absolute;top:1054px;left:89px;white-space:nowrap" class="ft02">they&#160;will not&#160;execute until the LFENCE completes.</p>
</div>
</body>
</html>
