<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 1226</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:14px;font-family:Times;color:#0860a8;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft05{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page1226-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_fe12b1e2a880e0ce1226.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">31-16&#160;Vol. 3C</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">VIRTUAL-MACHINE MONITOR PROGRAMMING CONSIDERATIONS</p>
<p style="position:absolute;top:99px;left:68px;white-space:nowrap" class="ft02">31.10.4.1&#160;&#160;&#160;Handling IA32_EFER&#160;MSR</p>
<p style="position:absolute;top:127px;left:68px;white-space:nowrap" class="ft04">The IA32_EFER MSR includes bit fields that allow system&#160;software to enable&#160;processor&#160;features. For example:&#160;the&#160;<br/>SCE&#160;bit enables&#160;SYSCALL/SYSRET and the&#160;NXE bit enables&#160;the&#160;execute-disable bits&#160;in the&#160;paging-structure entries.&#160;<br/>VMX&#160;provides hardware support to load&#160;the IA32_EFER MSR&#160;on&#160;VMX transitions&#160;and to&#160;save it&#160;on VM&#160;exits. Because&#160;<br/>of this,&#160;VMM software need not&#160;use&#160;the RDMSR and WRMSR instruction to&#160;give&#160;the register&#160;different&#160;values during&#160;<br/>host&#160;and guest execution.&#160;</p>
<p style="position:absolute;top:245px;left:68px;white-space:nowrap" class="ft02">31.10.4.2&#160;&#160;&#160;Handling the&#160;SYSENTER and SYSEXIT Instructions</p>
<p style="position:absolute;top:274px;left:68px;white-space:nowrap" class="ft04">The SYSENTER and SYSEXIT instructions use&#160;three&#160;dedicated&#160;MSRs (IA32_SYSENTER_CS,&#160;IA32_SYSENTER_ESP&#160;<br/>and&#160;IA32_SYSENTER_EIP)&#160;to manage fast system&#160;calls.&#160;These MSRs&#160;may be&#160;utilized&#160;by both the&#160;VMM and&#160;the&#160;<br/>guest OS to&#160;manage system&#160;calls in&#160;VMX root&#160;operation&#160;and VMX non-root&#160;operation respectively.&#160;<br/>VM&#160;entries load&#160;these&#160;MSRs&#160;from&#160;fields&#160;in the&#160;guest-state&#160;area&#160;of the&#160;VMCS. VM&#160;exits save&#160;the values of&#160;these&#160;MSRs&#160;<br/>into&#160;those fields and&#160;loads&#160;the MSRs from&#160;fields in&#160;the host-state&#160;area.</p>
<p style="position:absolute;top:391px;left:68px;white-space:nowrap" class="ft02">31.10.4.3&#160;&#160;&#160;Handling the&#160;SYSCALL and SYSRET Instructions</p>
<p style="position:absolute;top:420px;left:68px;white-space:nowrap" class="ft04">The&#160;SYSCALL/SYSRET&#160;instructions are similar to&#160;SYSENTER/SYSEXIT but&#160;are&#160;designed to&#160;operate within the&#160;<br/>context of a&#160;64-bit flat code&#160;segment.&#160;They are&#160;available&#160;only&#160;in 64-bit&#160;mode and&#160;only&#160;when&#160;the SCE bit of the&#160;<br/>IA32_EFER MSR&#160;is set. SYSCALL/SYSRET&#160;invocations can&#160;occur from&#160;either&#160;32-bit compatibility mode&#160;application&#160;<br/>code&#160;or from 64-bit application&#160;code.&#160;Three&#160;related&#160;MSR&#160;registers (IA32_STAR,&#160;IA32_LSTAR,&#160;IA32_FMASK) are&#160;<br/>used&#160;in conjunction with fast&#160;system&#160;calls/returns that&#160;use these instructions.<br/>64-Bit hosts&#160;which&#160;make&#160;use&#160;of these instructions in the VMM environment&#160;will&#160;need&#160;to save&#160;the guest&#160;state&#160;of&#160;the&#160;<br/>above registers&#160;on VM&#160;exit,&#160;load&#160;the&#160;host&#160;state,&#160;and&#160;restore&#160;the&#160;guest state&#160;on VM&#160;entry.&#160;One possible&#160;approach&#160;is&#160;<br/>to use the VM-exit MSR-save&#160;and&#160;MSR-load areas and the VM-entry MSR-load area defined by controls in the VMCS.&#160;<br/>A disadvantage&#160;to this approach,&#160;however,&#160;is that&#160;the approach&#160;results in&#160;the&#160;unconditional saving, loading,&#160;and&#160;<br/>restoring of MSR&#160;registers on&#160;each&#160;VM exit&#160;or&#160;VM entry.<br/>Depending&#160;on the design of the&#160;VMM, it is likely that many&#160;VM-exits will require no fast&#160;system call support but the&#160;<br/>VMM will be&#160;burdened with the&#160;additional&#160;overhead of saving and restoring&#160;MSRs&#160;if&#160;the&#160;VMM&#160;chooses&#160;to&#160;support fast&#160;<br/>system call&#160;uniformly.&#160;Further,&#160;even if&#160;the host&#160;intends to&#160;support fast system&#160;calls during a&#160;VM-exit, some&#160;of&#160;the&#160;<br/>MSR values&#160;(such&#160;as the setting of the SCE&#160;bit in&#160;IA32_EFER) may not require modification&#160;as they&#160;may already be&#160;<br/>set to&#160;the appropriate&#160;value in the&#160;guest.&#160;<br/>For performance reasons,&#160;a VMM may perform lazy save, load, and restore of these&#160;MSR&#160;values&#160;on certain VM&#160;exits&#160;<br/>when it&#160;is determined&#160;that this&#160;is acceptable.&#160;The lazy-save-load-restore operation can be carried&#160;out&#160;“manually”&#160;<br/>using RDMSR and&#160;WRMSR.</p>
<p style="position:absolute;top:767px;left:68px;white-space:nowrap" class="ft02">31.10.4.4&#160;&#160;&#160;Handling the&#160;SWAPGS Instruction</p>
<p style="position:absolute;top:796px;left:68px;white-space:nowrap" class="ft04">The SWAPGS&#160;instruction is&#160;available only in&#160;64-bit&#160;mode.&#160;It swaps the&#160;contents of two specific MSRs&#160;<br/>(IA32_GSBASE and IA32_KERNEL_GSBASE).&#160;The IA32_GSBASE MSR&#160;shadows the base address portion&#160;of the GS&#160;<br/>descriptor register; the IA32_KERNEL_GSBASE MSR holds the&#160;base&#160;address&#160;of&#160;the&#160;GS&#160;segment used&#160;by the kernel&#160;<br/>(typically it&#160;houses kernel structures). SWAPGS is&#160;intended&#160;for use&#160;with&#160;fast&#160;system calls&#160;when&#160;in 64-bit mode&#160;to&#160;<br/>allow immediate access to&#160;kernel&#160;structures on&#160;transition&#160;to kernel mode.<br/>Similar to&#160;SYSCALL/SYSRET, IA-32e&#160;mode hosts&#160;which use&#160;fast system&#160;calls may&#160;need&#160;to save,&#160;load, and&#160;restore&#160;<br/>these&#160;MSR&#160;registers on&#160;VM&#160;exit and&#160;VM&#160;entry using the&#160;guidelines discussed&#160;in previous&#160;paragraphs.</p>
<p style="position:absolute;top:946px;left:68px;white-space:nowrap" class="ft02">31.10.4.5&#160;&#160;&#160;Implementation Specific&#160;Behavior&#160;on&#160;Writing to Certain MSRs&#160;</p>
<p style="position:absolute;top:975px;left:68px;white-space:nowrap" class="ft04">As noted in<a href="o_fe12b1e2a880e0ce-1109.html">&#160;Section&#160;26.4 and&#160;</a><a href="o_fe12b1e2a880e0ce-1142.html">Section&#160;27.4, a&#160;</a>processor&#160;may prevent&#160;writing to&#160;certain MSRs&#160;when&#160;loading guest&#160;<br/>states&#160;on&#160;VM&#160;entries or storing&#160;guest&#160;states&#160;on VM&#160;exits.&#160;This&#160;is done to&#160;ensure consistent&#160;operation. The subset&#160;<br/>and&#160;number&#160;of MSRs&#160;subject to&#160;restrictions&#160;are&#160;implementation specific. For initial&#160;VMX&#160;implementations, there are&#160;<br/>two&#160;MSRs: IA32_BIOS_UPDT_TRIG and&#160;IA32_BIOS_SIGN_ID&#160;(see&#160;<a href="o_fe12b1e2a880e0ce-1281.html">Chapter 35</a>).</p>
</div>
</body>
</html>
