<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Document Outline</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head>
<body>
<a name="outline"></a><h1>Document Outline</h1>
<ul>
<li><a href="o_7281d5ea06a5b67a-23.html">Chapter 1 About This Manual</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-23.html">1.1 Intel® 64 and IA-32 Processors Covered in this Manual</a></li>
<li><a href="o_7281d5ea06a5b67a-25.html">1.2 Overview of Volume 1: Basic Architecture</a></li>
<li><a href="o_7281d5ea06a5b67a-27.html">1.3 Notational Conventions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-27.html">1.3.1 Bit and Byte Order</a></li>
<li><a href="o_7281d5ea06a5b67a-27.html">1.3.2 Reserved Bits and Software Compatibility</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-28.html">1.3.2.1 Instruction Operands</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-28.html">1.3.3 Hexadecimal and Binary Numbers</a></li>
<li><a href="o_7281d5ea06a5b67a-28.html">1.3.4 Segmented Addressing</a></li>
<li><a href="o_7281d5ea06a5b67a-29.html">1.3.5 A New Syntax for CPUID, CR, and MSR Values</a></li>
<li><a href="o_7281d5ea06a5b67a-29.html">1.3.6 Exceptions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-30.html">1.4 Related Literature</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-31.html">Chapter 2 Intel® 64 and IA-32 Architectures</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-31.html">2.1 Brief History of Intel® 64 and IA-32 Architecture</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-31.html">2.1.1 16-bit Processors and Segmentation (1978)</a></li>
<li><a href="o_7281d5ea06a5b67a-31.html">2.1.2 The Intel® 286 Processor (1982)</a></li>
<li><a href="o_7281d5ea06a5b67a-31.html">2.1.3 The Intel386™ Processor (1985)</a></li>
<li><a href="o_7281d5ea06a5b67a-32.html">2.1.4 The Intel486™ Processor (1989)</a></li>
<li><a href="o_7281d5ea06a5b67a-32.html">2.1.5 The Intel® Pentium® Processor (1993)</a></li>
<li><a href="o_7281d5ea06a5b67a-32.html">2.1.6 The P6 Family of Processors (1995-1999)</a></li>
<li><a href="o_7281d5ea06a5b67a-33.html">2.1.7 The Intel® Pentium® 4 Processor Family (2000-2006)</a></li>
<li><a href="o_7281d5ea06a5b67a-33.html">2.1.8 The Intel® Xeon® Processor (2001- 2007)</a></li>
<li><a href="o_7281d5ea06a5b67a-33.html">2.1.9 The Intel® Pentium® M Processor (2003-2006)</a></li>
<li><a href="o_7281d5ea06a5b67a-34.html">2.1.10 The Intel® Pentium® Processor Extreme Edition (2005)</a></li>
<li><a href="o_7281d5ea06a5b67a-34.html">2.1.11 The Intel® Core™ Duo and Intel® Core™ Solo Processors (2006-2007)</a></li>
<li><a href="o_7281d5ea06a5b67a-34.html">2.1.12 The Intel® Xeon® Processor 5100, 5300 Series and Intel® Core™2 Processor Family (2006)</a></li>
<li><a href="o_7281d5ea06a5b67a-35.html">2.1.13 The Intel® Xeon® Processor 5200, 5400, 7400 Series and Intel® Core™2 Processor Family (2007)</a></li>
<li><a href="o_7281d5ea06a5b67a-35.html">2.1.14 The Intel® Atom™ Processor Family (2008)</a></li>
<li><a href="o_7281d5ea06a5b67a-35.html">2.1.15 The Intel® Atom™ Processor Family Based on Silvermont Microarchitecture (2013)</a></li>
<li><a href="o_7281d5ea06a5b67a-35.html">2.1.16 The Intel® Core™i7 Processor Family (2008)</a></li>
<li><a href="o_7281d5ea06a5b67a-36.html">2.1.17 The Intel® Xeon® Processor 7500 Series (2010)</a></li>
<li><a href="o_7281d5ea06a5b67a-36.html">2.1.18 2010 Intel® Core™ Processor Family (2010)</a></li>
<li><a href="o_7281d5ea06a5b67a-36.html">2.1.19 The Intel® Xeon® Processor 5600 Series (2010)</a></li>
<li><a href="o_7281d5ea06a5b67a-36.html">2.1.20 The Second Generation Intel® Core™ Processor Family (2011)</a></li>
<li><a href="o_7281d5ea06a5b67a-37.html">2.1.21 The Third Generation Intel® Core™ Processor Family (2012)</a></li>
<li><a href="o_7281d5ea06a5b67a-37.html">2.1.22 The Fourth Generation Intel® Core™ Processor Family (2013)</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-37.html">2.2 More on SPECIFIC advances</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-37.html">2.2.1 P6 Family Microarchitecture</a></li>
<li><a href="o_7281d5ea06a5b67a-38.html">2.2.2 Intel NetBurst® Microarchitecture</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-40.html">2.2.2.1 The Front End Pipeline</a></li>
<li><a href="o_7281d5ea06a5b67a-41.html">2.2.2.2 Out-Of-Order Execution Core</a></li>
<li><a href="o_7281d5ea06a5b67a-41.html">2.2.2.3 Retirement Unit</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-41.html">2.2.3 Intel® Core™ Microarchitecture</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-42.html">2.2.3.1 The Front End</a></li>
<li><a href="o_7281d5ea06a5b67a-43.html">2.2.3.2 Execution Core</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-43.html">2.2.4 Intel® Atom™ Microarchitecture</a></li>
<li><a href="o_7281d5ea06a5b67a-43.html">2.2.5 Intel® Microarchitecture Code Name Nehalem</a></li>
<li><a href="o_7281d5ea06a5b67a-44.html">2.2.6 Intel® Microarchitecture Code Name Sandy Bridge</a></li>
<li><a href="o_7281d5ea06a5b67a-45.html">2.2.7 SIMD Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-47.html">2.2.8 Intel® Hyper-Threading Technology</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-48.html">2.2.8.1 Some Implementation Notes</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-49.html">2.2.9 Multi-Core Technology</a></li>
<li><a href="o_7281d5ea06a5b67a-51.html">2.2.10 Intel® 64 Architecture</a></li>
<li><a href="o_7281d5ea06a5b67a-51.html">2.2.11 Intel® Virtualization Technology (Intel® VT)</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-51.html">2.3 Intel® 64 and IA-32 processor generations</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-61.html">Chapter 3 Basic Execution Environment</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-61.html">3.1 Modes of Operation</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-61.html">3.1.1 Intel® 64 Architecture</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-62.html">3.2 Overview of the Basic Execution Environment</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-65.html">3.2.1 64-Bit Mode Execution Environment</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-66.html">3.3 Memory Organization</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-67.html">3.3.1 IA-32 Memory Models</a></li>
<li><a href="o_7281d5ea06a5b67a-68.html">3.3.2 Paging and Virtual Memory</a></li>
<li><a href="o_7281d5ea06a5b67a-68.html">3.3.3 Memory Organization in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-69.html">3.3.4 Modes of Operation vs. Memory Model</a></li>
<li><a href="o_7281d5ea06a5b67a-69.html">3.3.5 32-Bit and 16-Bit Address and Operand Sizes</a></li>
<li><a href="o_7281d5ea06a5b67a-69.html">3.3.6 Extended Physical Addressing in Protected Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-70.html">3.3.7 Address Calculations in 64-Bit Mode</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-70.html">3.3.7.1 Canonical Addressing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-70.html">3.4 Basic Program Execution Registers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-71.html">3.4.1 General-Purpose Registers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-72.html">3.4.1.1 General-Purpose Registers in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-73.html">3.4.2 Segment Registers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-75.html">3.4.2.1 Segment Registers in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-75.html">3.4.3 EFLAGS Register</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-76.html">3.4.3.1 Status Flags</a></li>
<li><a href="o_7281d5ea06a5b67a-77.html">3.4.3.2 DF Flag</a></li>
<li><a href="o_7281d5ea06a5b67a-77.html">3.4.3.3 System Flags and IOPL Field</a></li>
<li><a href="o_7281d5ea06a5b67a-78.html">3.4.3.4 RFLAGS Register in 64-Bit Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-78.html">3.5 Instruction Pointer</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-78.html">3.5.1 Instruction Pointer in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-78.html">3.6 Operand-Size and Address-Size Attributes</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-79.html">3.6.1 Operand Size and Address Size in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-79.html">3.7 Operand Addressing</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-80.html">3.7.1 Immediate Operands</a></li>
<li><a href="o_7281d5ea06a5b67a-80.html">3.7.2 Register Operands</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-81.html">3.7.2.1 Register Operands in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-81.html">3.7.3 Memory Operands</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-81.html">3.7.3.1 Memory Operands in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-81.html">3.7.4 Specifying a Segment Selector</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-82.html">3.7.4.1 Segmentation in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-82.html">3.7.5 Specifying an Offset</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-84.html">3.7.5.1 Specifying an Offset in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-84.html">3.7.6 Assembler and Compiler Addressing Modes</a></li>
<li><a href="o_7281d5ea06a5b67a-84.html">3.7.7 I/O Port Addressing</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-85.html">Chapter 4 Data Types</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-85.html">4.1 Fundamental Data Types</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-86.html">4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-86.html">4.2 Numeric Data Types</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-87.html">4.2.1 Integers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-87.html">4.2.1.1 Unsigned Integers</a></li>
<li><a href="o_7281d5ea06a5b67a-88.html">4.2.1.2 Signed Integers</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-88.html">4.2.2 Floating-Point Data Types</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-90.html">4.3 Pointer Data Types</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-91.html">4.3.1 Pointer Data Types in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-91.html">4.4 Bit Field Data Type</a></li>
<li><a href="o_7281d5ea06a5b67a-92.html">4.5 String Data Types</a></li>
<li><a href="o_7281d5ea06a5b67a-92.html">4.6 Packed SIMD Data Types</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-92.html">4.6.1 64-Bit SIMD Packed Data Types</a></li>
<li><a href="o_7281d5ea06a5b67a-92.html">4.6.2 128-Bit Packed SIMD Data Types</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-93.html">4.7 BCD and Packed BCD Integers</a></li>
<li><a href="o_7281d5ea06a5b67a-95.html">4.8 Real Numbers and Floating-Point Formats</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-95.html">4.8.1 Real Number System</a></li>
<li><a href="o_7281d5ea06a5b67a-95.html">4.8.2 Floating-Point Format</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-97.html">4.8.2.1 Normalized Numbers</a></li>
<li><a href="o_7281d5ea06a5b67a-97.html">4.8.2.2 Biased Exponent</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-97.html">4.8.3 Real Number and Non-number Encodings</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-98.html">4.8.3.1 Signed Zeros</a></li>
<li><a href="o_7281d5ea06a5b67a-98.html">4.8.3.2 Normalized and Denormalized Finite Numbers</a></li>
<li><a href="o_7281d5ea06a5b67a-99.html">4.8.3.3 Signed Infinities</a></li>
<li><a href="o_7281d5ea06a5b67a-99.html">4.8.3.4 NaNs</a></li>
<li><a href="o_7281d5ea06a5b67a-100.html">4.8.3.5 Operating on SNaNs and QNaNs</a></li>
<li><a href="o_7281d5ea06a5b67a-100.html">4.8.3.6 Using SNaNs and QNaNs in Applications</a></li>
<li><a href="o_7281d5ea06a5b67a-101.html">4.8.3.7 QNaN Floating-Point Indefinite</a></li>
<li><a href="o_7281d5ea06a5b67a-101.html">4.8.3.8 Half-Precision Floating-Point Operation</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-101.html">4.8.4 Rounding</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-102.html">4.8.4.1 Rounding Control (RC) Fields</a></li>
<li><a href="o_7281d5ea06a5b67a-102.html">4.8.4.2 Truncation with SSE and SSE2 Conversion Instructions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-102.html">4.9 Overview of Floating-Point Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-103.html">4.9.1 Floating-Point Exception Conditions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-104.html">4.9.1.1 Invalid Operation Exception (#I)</a></li>
<li><a href="o_7281d5ea06a5b67a-104.html">4.9.1.2 Denormal Operand Exception (#D)</a></li>
<li><a href="o_7281d5ea06a5b67a-104.html">4.9.1.3 Divide-By-Zero Exception (#Z)</a></li>
<li><a href="o_7281d5ea06a5b67a-104.html">4.9.1.4 Numeric Overflow Exception (#O)</a></li>
<li><a href="o_7281d5ea06a5b67a-105.html">4.9.1.5 Numeric Underflow Exception (#U)</a></li>
<li><a href="o_7281d5ea06a5b67a-106.html">4.9.1.6 Inexact-Result (Precision) Exception (#P)</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-107.html">4.9.2 Floating-Point Exception Priority</a></li>
<li><a href="o_7281d5ea06a5b67a-107.html">4.9.3 Typical Actions of a Floating-Point Exception Handler</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-109.html">Chapter 5 Instruction Set Summary</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-111.html">5.1 General-Purpose Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-111.html">5.1.1 Data Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-112.html">5.1.2 Binary Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-112.html">5.1.3 Decimal Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-112.html">5.1.4 Logical Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-112.html">5.1.5 Shift and Rotate Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-113.html">5.1.6 Bit and Byte Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-113.html">5.1.7 Control Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-114.html">5.1.8 String Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-115.html">5.1.9 I/O Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-115.html">5.1.10 Enter and Leave Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-115.html">5.1.11 Flag Control (EFLAG) Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-115.html">5.1.12 Segment Register Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-116.html">5.1.13 Miscellaneous Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-116.html">5.1.14 User Mode Extended Sate Save/Restore Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-116.html">5.1.15 Random Number Generator Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-116.html">5.1.16 BMI1, BMI2</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-117.html">5.1.16.1 Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-117.html">5.2 x87 FPU Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-117.html">5.2.1 x87 FPU Data Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-117.html">5.2.2 x87 FPU Basic Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-118.html">5.2.3 x87 FPU Comparison Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-119.html">5.2.4 x87 FPU Transcendental Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-119.html">5.2.5 x87 FPU Load Constants Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-119.html">5.2.6 x87 FPU Control Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-120.html">5.3 x87 FPU AND SIMD State Management Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-120.html">5.4 MMX™ Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-120.html">5.4.1 MMX Data Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-120.html">5.4.2 MMX Conversion Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-121.html">5.4.3 MMX Packed Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-121.html">5.4.4 MMX Comparison Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-121.html">5.4.5 MMX Logical Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-121.html">5.4.6 MMX Shift and Rotate Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-122.html">5.4.7 MMX State Management Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-122.html">5.5 SSE Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-122.html">5.5.1 SSE SIMD Single-Precision Floating-Point Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-122.html">5.5.1.1 SSE Data Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-123.html">5.5.1.2 SSE Packed Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-123.html">5.5.1.3 SSE Comparison Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-123.html">5.5.1.4 SSE Logical Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-123.html">5.5.1.5 SSE Shuffle and Unpack Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-124.html">5.5.1.6 SSE Conversion Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-124.html">5.5.2 SSE MXCSR State Management Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-124.html">5.5.3 SSE 64-Bit SIMD Integer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-124.html">5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-125.html">5.6 SSE2 Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-125.html">5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-125.html">5.6.1.1 SSE2 Data Movement Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-126.html">5.6.1.2 SSE2 Packed Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-126.html">5.6.1.3 SSE2 Logical Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-126.html">5.6.1.4 SSE2 Compare Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-126.html">5.6.1.5 SSE2 Shuffle and Unpack Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-127.html">5.6.1.6 SSE2 Conversion Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-127.html">5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-127.html">5.6.3 SSE2 128-Bit SIMD Integer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-128.html">5.6.4 SSE2 Cacheability Control and Ordering Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-128.html">5.7 SSE3 Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-128.html">5.7.1 SSE3 x87-FP Integer Conversion Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-128.html">5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-129.html">5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-129.html">5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-129.html">5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-129.html">5.7.6 SSE3 Agent Synchronization Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-129.html">5.8 Supplemental Streaming SIMD Extensions 3 (SSSE3) Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-130.html">5.8.1 Horizontal Addition/Subtraction</a></li>
<li><a href="o_7281d5ea06a5b67a-130.html">5.8.2 Packed Absolute Values</a></li>
<li><a href="o_7281d5ea06a5b67a-130.html">5.8.3 Multiply and Add Packed Signed and Unsigned Bytes</a></li>
<li><a href="o_7281d5ea06a5b67a-130.html">5.8.4 Packed Multiply High with Round and Scale</a></li>
<li><a href="o_7281d5ea06a5b67a-131.html">5.8.5 Packed Shuffle Bytes</a></li>
<li><a href="o_7281d5ea06a5b67a-131.html">5.8.6 Packed Sign</a></li>
<li><a href="o_7281d5ea06a5b67a-131.html">5.8.7 Packed Align Right</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-131.html">5.9 SSE4 Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-132.html">5.10 SSE4.1 Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-132.html">5.10.1 Dword Multiply Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-132.html">5.10.2 Floating-Point Dot Product Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-132.html">5.10.3 Streaming Load Hint Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-132.html">5.10.4 Packed Blending Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-132.html">5.10.5 Packed Integer MIN/MAX Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-133.html">5.10.6 Floating-Point Round Instructions with Selectable Rounding Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-133.html">5.10.7 Insertion and Extractions from XMM Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-133.html">5.10.8 Packed Integer Format Conversions</a></li>
<li><a href="o_7281d5ea06a5b67a-134.html">5.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks</a></li>
<li><a href="o_7281d5ea06a5b67a-134.html">5.10.10 Horizontal Search</a></li>
<li><a href="o_7281d5ea06a5b67a-134.html">5.10.11 Packed Test</a></li>
<li><a href="o_7281d5ea06a5b67a-134.html">5.10.12 Packed Qword Equality Comparisons</a></li>
<li><a href="o_7281d5ea06a5b67a-134.html">5.10.13 Dword Packing With Unsigned Saturation</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-134.html">5.11 SSE4.2 Instruction Set</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-134.html">5.11.1 String and Text Processing Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-135.html">5.11.2 Packed Comparison SIMD integer Instruction</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-135.html">5.12 AESNI and PCLMULQDQ</a></li>
<li><a href="o_7281d5ea06a5b67a-135.html">5.13 Intel® Advanced Vector Extensions (Intel® AVX)</a></li>
<li><a href="o_7281d5ea06a5b67a-135.html">5.14 16-bit Floating-Point Conversion</a></li>
<li><a href="o_7281d5ea06a5b67a-136.html">5.15 Fused-Multiply-ADD (FMA)</a></li>
<li><a href="o_7281d5ea06a5b67a-136.html">5.16 Intel® Advanced Vector Extensions 2 (Intel® AVX2)</a></li>
<li><a href="o_7281d5ea06a5b67a-136.html">5.17 Intel® Transactional Synchronization Extensions (Intel® TSX)</a></li>
<li><a href="o_7281d5ea06a5b67a-136.html">5.18 Intel® SHA Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-136.html">5.19 Intel® Advanced Vector Extensions 512 (Intel® AVX-512)</a></li>
<li><a href="o_7281d5ea06a5b67a-140.html">5.20 System Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-141.html">5.21 64-Bit Mode Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-142.html">5.22 Virtual-Machine Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-142.html">5.23 Safer Mode Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-143.html">5.24 Intel® Memory Protection Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-143.html">5.25 Intel® Security Guard Extensions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-145.html">Chapter 6 Procedure Calls, Interrupts, and Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-145.html">6.1 Procedure Call Types</a></li>
<li><a href="o_7281d5ea06a5b67a-145.html">6.2 Stacks</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-146.html">6.2.1 Setting Up a Stack</a></li>
<li><a href="o_7281d5ea06a5b67a-146.html">6.2.2 Stack Alignment</a></li>
<li><a href="o_7281d5ea06a5b67a-147.html">6.2.3 Address-Size Attributes for Stack Accesses</a></li>
<li><a href="o_7281d5ea06a5b67a-147.html">6.2.4 Procedure Linking Information</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-147.html">6.2.4.1 Stack-Frame Base Pointer</a></li>
<li><a href="o_7281d5ea06a5b67a-147.html">6.2.4.2 Return Instruction Pointer</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-148.html">6.2.5 Stack Behavior in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-148.html">6.3 Calling Procedures Using CALL and RET</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-148.html">6.3.1 Near CALL and RET Operation</a></li>
<li><a href="o_7281d5ea06a5b67a-148.html">6.3.2 Far CALL and RET Operation</a></li>
<li><a href="o_7281d5ea06a5b67a-149.html">6.3.3 Parameter Passing</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-149.html">6.3.3.1 Passing Parameters Through the General-Purpose Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-149.html">6.3.3.2 Passing Parameters on the Stack</a></li>
<li><a href="o_7281d5ea06a5b67a-150.html">6.3.3.3 Passing Parameters in an Argument List</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-150.html">6.3.4 Saving Procedure State Information</a></li>
<li><a href="o_7281d5ea06a5b67a-150.html">6.3.5 Calls to Other Privilege Levels</a></li>
<li><a href="o_7281d5ea06a5b67a-151.html">6.3.6 CALL and RET Operation Between Privilege Levels</a></li>
<li><a href="o_7281d5ea06a5b67a-153.html">6.3.7 Branch Functions in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-153.html">6.4 Interrupts and Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-154.html">6.4.1 Call and Return Operation for Interrupt or Exception Handling Procedures</a></li>
<li><a href="o_7281d5ea06a5b67a-157.html">6.4.2 Calls to Interrupt or Exception Handler Tasks</a></li>
<li><a href="o_7281d5ea06a5b67a-157.html">6.4.3 Interrupt and Exception Handling in Real-Address Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-157.html">6.4.4 INT n, INTO, INT 3, and BOUND Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-158.html">6.4.5 Handling Floating-Point Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-158.html">6.4.6 Interrupt and Exception Behavior in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-158.html">6.5 Procedure Calls for Block-Structured Languages</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-158.html">6.5.1 ENTER Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-163.html">6.5.2 LEAVE Instruction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-165.html">Chapter 7 Programming With General-Purpose Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-165.html">7.1 Programming environment for GP Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-165.html">7.2 Programming Environment for GP Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-166.html">7.3 Summary of GP Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-166.html">7.3.1 Data Transfer Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-167.html">7.3.1.1 General Data Movement Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-168.html">7.3.1.2 Exchange Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-169.html">7.3.1.3 Exchange Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-169.html">7.3.1.4 Stack Manipulation Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-171.html">7.3.1.5 Stack Manipulation Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-171.html">7.3.1.6 Type Conversion Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-172.html">7.3.1.7 Type Conversion Instructions in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-172.html">7.3.2 Binary Arithmetic Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-172.html">7.3.2.1 Addition and Subtraction Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-172.html">7.3.2.2 Increment and Decrement Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-172.html">7.3.2.3 Increment and Decrement Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-172.html">7.3.2.4 Comparison and Sign Change Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-173.html">7.3.2.5 Multiplication and Division Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-173.html">7.3.3 Decimal Arithmetic Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-173.html">7.3.3.1 Packed BCD Adjustment Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-173.html">7.3.3.2 Unpacked BCD Adjustment Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-174.html">7.3.4 Decimal Arithmetic Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-174.html">7.3.5 Logical Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-174.html">7.3.6 Shift and Rotate Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-174.html">7.3.6.1 Shift Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-176.html">7.3.6.2 Double-Shift Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-177.html">7.3.6.3 Rotate Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-177.html">7.3.7 Bit and Byte Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-178.html">7.3.7.1 Bit Test and Modify Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-178.html">7.3.7.2 Bit Scan Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-178.html">7.3.7.3 Byte Set on Condition Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-178.html">7.3.7.4 Test Instruction</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-178.html">7.3.8 Control Transfer Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-178.html">7.3.8.1 Unconditional Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-179.html">7.3.8.2 Conditional Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-181.html">7.3.8.3 Control Transfer Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-181.html">7.3.8.4 Software Interrupt Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-182.html">7.3.8.5 Software Interrupt Instructions in 64-bit Mode and Compatibility Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-182.html">7.3.9 String Operations</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-182.html">7.3.9.1 String Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-183.html">7.3.9.2 Repeated String Operations</a></li>
<li><a href="o_7281d5ea06a5b67a-183.html">7.3.9.3 Fast-String Operation</a></li>
<li><a href="o_7281d5ea06a5b67a-184.html">7.3.9.4 String Operations in 64-Bit Mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-184.html">7.3.10 I/O Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-184.html">7.3.11 I/O Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-185.html">7.3.12 Enter and Leave Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-185.html">7.3.13 Flag Control (EFLAG) Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-185.html">7.3.13.1 Carry and Direction Flag Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-185.html">7.3.13.2 EFLAGS Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-186.html">7.3.13.3 Interrupt Flag Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-186.html">7.3.14 Flag Control (RFLAG) Instructions in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-186.html">7.3.15 Segment Register Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-186.html">7.3.15.1 Segment-Register Load and Store Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-186.html">7.3.15.2 Far Control Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-187.html">7.3.15.3 Software Interrupt Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-187.html">7.3.15.4 Load Far Pointer Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-187.html">7.3.16 Miscellaneous Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-187.html">7.3.16.1 Address Computation Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-187.html">7.3.16.2 Table Lookup Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-187.html">7.3.16.3 Processor Identification Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-187.html">7.3.16.4 No-Operation and Undefined Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-188.html">7.3.17 Random Number Generator Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-188.html">7.3.17.1 RDRAND</a></li>
<li><a href="o_7281d5ea06a5b67a-188.html">7.3.17.2 RDSEED</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-191.html">Chapter 8 Programming with the x87 FPU</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-191.html">8.1 x87 FPU Execution Environment</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-191.html">8.1.1 x87 FPU in 64-Bit Mode and Compatibility Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-191.html">8.1.2 x87 FPU Data Registers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-193.html">8.1.2.1 Parameter Passing With the x87 FPU Register Stack</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-194.html">8.1.3 x87 FPU Status Register</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-194.html">8.1.3.1 Top of Stack (TOP) Pointer</a></li>
<li><a href="o_7281d5ea06a5b67a-194.html">8.1.3.2 Condition Code Flags</a></li>
<li><a href="o_7281d5ea06a5b67a-195.html">8.1.3.3 x87 FPU Floating-Point Exception Flags</a></li>
<li><a href="o_7281d5ea06a5b67a-196.html">8.1.3.4 Stack Fault Flag</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-196.html">8.1.4 Branching and Conditional Moves on Condition Codes</a></li>
<li><a href="o_7281d5ea06a5b67a-197.html">8.1.5 x87 FPU Control Word</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-197.html">8.1.5.1 x87 FPU Floating-Point Exception Mask Bits</a></li>
<li><a href="o_7281d5ea06a5b67a-197.html">8.1.5.2 Precision Control Field</a></li>
<li><a href="o_7281d5ea06a5b67a-198.html">8.1.5.3 Rounding Control Field</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-198.html">8.1.6 Infinity Control Flag</a></li>
<li><a href="o_7281d5ea06a5b67a-198.html">8.1.7 x87 FPU Tag Word</a></li>
<li><a href="o_7281d5ea06a5b67a-199.html">8.1.8 x87 FPU Instruction and Data (Operand) Pointers</a></li>
<li><a href="o_7281d5ea06a5b67a-200.html">8.1.9 Last Instruction Opcode</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-200.html">8.1.9.1 Fopcode Compatibility Sub-mode</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-201.html">8.1.10 Saving the x87 FPU’s State with FSTENV/FNSTENV and FSAVE/FNSAVE</a></li>
<li><a href="o_7281d5ea06a5b67a-202.html">8.1.11 Saving the x87 FPU’s State with FXSAVE</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-203.html">8.2 x87 FPU Data Types</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-204.html">8.2.1 Indefinites</a></li>
<li><a href="o_7281d5ea06a5b67a-204.html">8.2.2 Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-205.html">8.3 x87 FPU Instruction Set</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-205.html">8.3.1 Escape (ESC) Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-205.html">8.3.2 x87 FPU Instruction Operands</a></li>
<li><a href="o_7281d5ea06a5b67a-206.html">8.3.3 Data Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-208.html">8.3.4 Load Constant Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-208.html">8.3.5 Basic Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-209.html">8.3.6 Comparison and Classification Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-210.html">8.3.6.1 Branching on the x87 FPU Condition Codes</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-211.html">8.3.7 Trigonometric Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-211.html">8.3.8 Approximation of Pi</a></li>
<li><a href="o_7281d5ea06a5b67a-212.html">8.3.9 Logarithmic, Exponential, and Scale</a></li>
<li><a href="o_7281d5ea06a5b67a-212.html">8.3.10 Transcendental Instruction Accuracy</a></li>
<li><a href="o_7281d5ea06a5b67a-214.html">8.3.11 x87 FPU Control Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-214.html">8.3.12 Waiting vs. Non-waiting Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-215.html">8.3.13 Unsupported x87 FPU Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-215.html">8.4 x87 FPU Floating-Point Exception Handling</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-215.html">8.4.1 Arithmetic vs. Non-arithmetic Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-216.html">8.5 x87 FPU Floating-Point Exception Conditions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-217.html">8.5.1 Invalid Operation Exception</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-217.html">8.5.1.1 Stack Overflow or Underflow Exception (#IS)</a></li>
<li><a href="o_7281d5ea06a5b67a-217.html">8.5.1.2 Invalid Arithmetic Operand Exception (#IA)</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-218.html">8.5.2 Denormal Operand Exception (#D)</a></li>
<li><a href="o_7281d5ea06a5b67a-219.html">8.5.3 Divide-By-Zero Exception (#Z)</a></li>
<li><a href="o_7281d5ea06a5b67a-219.html">8.5.4 Numeric Overflow Exception (#O)</a></li>
<li><a href="o_7281d5ea06a5b67a-220.html">8.5.5 Numeric Underflow Exception (#U)</a></li>
<li><a href="o_7281d5ea06a5b67a-221.html">8.5.6 Inexact-Result (Precision) Exception (#P)</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-221.html">8.6 x87 FPU Exception Synchronization</a></li>
<li><a href="o_7281d5ea06a5b67a-222.html">8.7 Handling x87 FPU Exceptions in Software</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-222.html">8.7.1 Native Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-223.html">8.7.2 MS-DOS* Compatibility Sub-mode</a></li>
<li><a href="o_7281d5ea06a5b67a-223.html">8.7.3 Handling x87 FPU Exceptions in Software</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-225.html">Chapter 9 Programming with Intel® MMX™ Technology</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-225.html">9.1 Overview of MMX Technology</a></li>
<li><a href="o_7281d5ea06a5b67a-225.html">9.2 The MMX Technology Programming Environment</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-226.html">9.2.1 MMX Technology in 64-Bit Mode and Compatibility Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-226.html">9.2.2 MMX Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-227.html">9.2.3 MMX Data Types</a></li>
<li><a href="o_7281d5ea06a5b67a-227.html">9.2.4 Memory Data Formats</a></li>
<li><a href="o_7281d5ea06a5b67a-228.html">9.2.5 Single Instruction, Multiple Data (SIMD) Execution Model</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-228.html">9.3 Saturation and Wraparound Modes</a></li>
<li><a href="o_7281d5ea06a5b67a-229.html">9.4 MMX Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-230.html">9.4.1 Data Transfer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-230.html">9.4.2 Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-231.html">9.4.3 Comparison Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-231.html">9.4.4 Conversion Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-231.html">9.4.5 Unpack Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-231.html">9.4.6 Logical Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-232.html">9.4.7 Shift Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-232.html">9.4.8 EMMS Instruction</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-232.html">9.5 Compatibility with x87 FPU Architecture</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-232.html">9.5.1 MMX Instructions and the x87 FPU Tag Word</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-232.html">9.6 WRITING APPLICATIONS WITH MMX CODE</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-232.html">9.6.1 Checking for MMX Technology Support</a></li>
<li><a href="o_7281d5ea06a5b67a-233.html">9.6.2 Transitions Between x87 FPU and MMX Code</a></li>
<li><a href="o_7281d5ea06a5b67a-233.html">9.6.3 Using the EMMS Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-234.html">9.6.4 Mixing MMX and x87 FPU Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-234.html">9.6.5 Interfacing with MMX Code</a></li>
<li><a href="o_7281d5ea06a5b67a-234.html">9.6.6 Using MMX Code in a Multitasking Operating System Environment</a></li>
<li><a href="o_7281d5ea06a5b67a-235.html">9.6.7 Exception Handling in MMX Code</a></li>
<li><a href="o_7281d5ea06a5b67a-235.html">9.6.8 Register Mapping</a></li>
<li><a href="o_7281d5ea06a5b67a-235.html">9.6.9 Effect of Instruction Prefixes on MMX Instructions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-237.html">Chapter 10 Programming with Intel® Streaming SIMD Extensions (Intel® SSE)</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-237.html">10.1 Overview of SSE Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-238.html">10.2 SSE Programming Environment</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-239.html">10.2.1 SSE in 64-Bit Mode and Compatibility Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-239.html">10.2.2 XMM Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-239.html">10.2.3 MXCSR Control and Status Register</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-240.html">10.2.3.1 SIMD Floating-Point Mask and Flag Bits</a></li>
<li><a href="o_7281d5ea06a5b67a-240.html">10.2.3.2 SIMD Floating-Point Rounding Control Field</a></li>
<li><a href="o_7281d5ea06a5b67a-240.html">10.2.3.3 Flush-To-Zero</a></li>
<li><a href="o_7281d5ea06a5b67a-241.html">10.2.3.4 Denormals-Are-Zeros</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-241.html">10.2.4 Compatibility of SSE Extensions with SSE2/SSE3/MMX and the x87 FPU</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-241.html">10.3 SSE Data Types</a></li>
<li><a href="o_7281d5ea06a5b67a-242.html">10.4 SSE Instruction Set</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-242.html">10.4.1 SSE Packed and Scalar Floating-Point Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-243.html">10.4.1.1 SSE Data Movement Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-244.html">10.4.1.2 SSE Arithmetic Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-245.html">10.4.2 SSE Logical Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-245.html">10.4.2.1 SSE Comparison Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-245.html">10.4.2.2 SSE Shuffle and Unpack Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-247.html">10.4.3 SSE Conversion Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-247.html">10.4.4 SSE 64-Bit SIMD Integer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-248.html">10.4.5 MXCSR State Management Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-248.html">10.4.6 Cacheability Control, Prefetch, and Memory Ordering Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-248.html">10.4.6.1 Cacheability Control Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-248.html">10.4.6.2 Caching of Temporal vs. Non-Temporal Data</a></li>
<li><a href="o_7281d5ea06a5b67a-249.html">10.4.6.3 PREFETCHh Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-250.html">10.4.6.4 SFENCE Instruction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-250.html">10.5 FXSAVE and FXRSTOR Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-250.html">10.5.1 FXSAVE Area</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-251.html">10.5.1.1 x87 State</a></li>
<li><a href="o_7281d5ea06a5b67a-252.html">10.5.1.2 SSE State</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-252.html">10.5.2 Operation of FXSAVE</a></li>
<li><a href="o_7281d5ea06a5b67a-253.html">10.5.3 Operation of FXRSTOR</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-253.html">10.6 Handling SSE Instruction Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-253.html">10.7 Writing Applications with the SSE Extensions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-255.html">Chapter 11 Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2)</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-255.html">11.1 Overview of SSE2 Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-256.html">11.2 SSE2 Programming Environment</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-257.html">11.2.1 SSE2 in 64-Bit Mode and Compatibility Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-257.html">11.2.2 Compatibility of SSE2 Extensions with SSE, MMX Technology and x87 FPU Programming Environment</a></li>
<li><a href="o_7281d5ea06a5b67a-257.html">11.2.3 Denormals-Are-Zeros Flag</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-257.html">11.3 SSE2 Data Types</a></li>
<li><a href="o_7281d5ea06a5b67a-258.html">11.4 SSE2 Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-258.html">11.4.1 Packed and Scalar Double-Precision Floating-Point Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-259.html">11.4.1.1 Data Movement Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-260.html">11.4.1.2 SSE2 Arithmetic Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-261.html">11.4.1.3 SSE2 Logical Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-261.html">11.4.1.4 SSE2 Comparison Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-261.html">11.4.1.5 SSE2 Shuffle and Unpack Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-263.html">11.4.1.6 SSE2 Conversion Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-264.html">11.4.2 SSE2 64-Bit and 128-Bit SIMD Integer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-265.html">11.4.3 128-Bit SIMD Integer Instruction Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-266.html">11.4.4 Cacheability Control and Memory Ordering Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-266.html">11.4.4.1 FLUSH Cache Line</a></li>
<li><a href="o_7281d5ea06a5b67a-266.html">11.4.4.2 Cacheability Control Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-266.html">11.4.4.3 Memory Ordering Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-266.html">11.4.4.4 Pause</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-267.html">11.4.5 Branch Hints</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-267.html">11.5 SSE, SSE2, and SSE3 Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-267.html">11.5.1 SIMD Floating-Point Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-268.html">11.5.2 SIMD Floating-Point Exception Conditions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-268.html">11.5.2.1 Invalid Operation Exception (#I)</a></li>
<li><a href="o_7281d5ea06a5b67a-269.html">11.5.2.2 Denormal-Operand Exception (#D)</a></li>
<li><a href="o_7281d5ea06a5b67a-269.html">11.5.2.3 Divide-By-Zero Exception (#Z)</a></li>
<li><a href="o_7281d5ea06a5b67a-269.html">11.5.2.4 Numeric Overflow Exception (#O)</a></li>
<li><a href="o_7281d5ea06a5b67a-270.html">11.5.2.5 Numeric Underflow Exception (#U)</a></li>
<li><a href="o_7281d5ea06a5b67a-270.html">11.5.2.6 Inexact-Result (Precision) Exception (#P)</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-270.html">11.5.3 Generating SIMD Floating-Point Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-270.html">11.5.3.1 Handling Masked Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-271.html">11.5.3.2 Handling Unmasked Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-272.html">11.5.3.3 Handling Combinations of Masked and Unmasked Exceptions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-272.html">11.5.4 Handling SIMD Floating-Point Exceptions in Software</a></li>
<li><a href="o_7281d5ea06a5b67a-272.html">11.5.5 Interaction of SIMD and x87 FPU Floating-Point Exceptions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-273.html">11.6 Writing Applications with SSE/SSE2 Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-273.html">11.6.1 General Guidelines for Using SSE/SSE2 Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-273.html">11.6.2 Checking for SSE/SSE2 Support</a></li>
<li><a href="o_7281d5ea06a5b67a-274.html">11.6.3 Checking for the DAZ Flag in the MXCSR Register</a></li>
<li><a href="o_7281d5ea06a5b67a-274.html">11.6.4 Initialization of SSE/SSE2 Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-274.html">11.6.5 Saving and Restoring the SSE/SSE2 State</a></li>
<li><a href="o_7281d5ea06a5b67a-275.html">11.6.6 Guidelines for Writing to the MXCSR Register</a></li>
<li><a href="o_7281d5ea06a5b67a-275.html">11.6.7 Interaction of SSE/SSE2 Instructions with x87 FPU and MMX Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-276.html">11.6.8 Compatibility of SIMD and x87 FPU Floating-Point Data Types</a></li>
<li><a href="o_7281d5ea06a5b67a-276.html">11.6.9 Mixing Packed and Scalar Floating-Point and 128-Bit SIMD Integer Instructions and Data</a></li>
<li><a href="o_7281d5ea06a5b67a-277.html">11.6.10 Interfacing with SSE/SSE2 Procedures and Functions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-277.html">11.6.10.1 Passing Parameters in XMM Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-277.html">11.6.10.2 Saving XMM Register State on a Procedure or Function Call</a></li>
<li><a href="o_7281d5ea06a5b67a-278.html">11.6.10.3 Caller-Save Recommendation for Procedure and Function Calls</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-278.html">11.6.11 Updating Existing MMX Technology Routines Using 128-Bit SIMD Integer Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-278.html">11.6.12 Branching on Arithmetic Operations</a></li>
<li><a href="o_7281d5ea06a5b67a-279.html">11.6.13 Cacheability Hint Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-279.html">11.6.14 Effect of Instruction Prefixes on the SSE/SSE2 Instructions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-281.html">Chapter 12 Programming with Intel® SSE3, SSSE3, Intel® SSE4 and Intel® AESNI</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-281.html">12.1 Programming Environment and Data types</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-281.html">12.1.1 SSE3, SSSE3, SSE4 in 64-Bit Mode and Compatibility Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-281.html">12.1.2 Compatibility of SSE3/SSSE3 with MMX Technology, the x87 FPU Environment, and SSE/SSE2 Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-281.html">12.1.3 Horizontal and Asymmetric Processing</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-282.html">12.2 Overview of SSE3 Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-282.html">12.3 SSE3 Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-283.html">12.3.1 x87 FPU Instruction for Integer Conversion</a></li>
<li><a href="o_7281d5ea06a5b67a-283.html">12.3.2 SIMD Integer Instruction for Specialized 128-bit Unaligned Data Load</a></li>
<li><a href="o_7281d5ea06a5b67a-283.html">12.3.3 SIMD Floating-Point Instructions That Enhance LOAD/MOVE/DUPLICATE Performance</a></li>
<li><a href="o_7281d5ea06a5b67a-284.html">12.3.4 SIMD Floating-Point Instructions Provide Packed Addition/Subtraction</a></li>
<li><a href="o_7281d5ea06a5b67a-284.html">12.3.5 SIMD Floating-Point Instructions Provide Horizontal Addition/Subtraction</a></li>
<li><a href="o_7281d5ea06a5b67a-285.html">12.3.6 Two Thread Synchronization Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-285.html">12.4 Writing Applications with SSE3 Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-285.html">12.4.1 Guidelines for Using SSE3 Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-285.html">12.4.2 Checking for SSE3 Support</a></li>
<li><a href="o_7281d5ea06a5b67a-286.html">12.4.3 Enable FTZ and DAZ for SIMD Floating-Point Computation</a></li>
<li><a href="o_7281d5ea06a5b67a-286.html">12.4.4 Programming SSE3 with SSE/SSE2 Extensions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-286.html">12.5 Overview of SSSE3 Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-286.html">12.6 SSSE3 Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-287.html">12.6.1 Horizontal Addition/Subtraction</a></li>
<li><a href="o_7281d5ea06a5b67a-287.html">12.6.2 Packed Absolute Values</a></li>
<li><a href="o_7281d5ea06a5b67a-288.html">12.6.3 Multiply and Add Packed Signed and Unsigned Bytes</a></li>
<li><a href="o_7281d5ea06a5b67a-288.html">12.6.4 Packed Multiply High with Round and Scale</a></li>
<li><a href="o_7281d5ea06a5b67a-288.html">12.6.5 Packed Shuffle Bytes</a></li>
<li><a href="o_7281d5ea06a5b67a-288.html">12.6.6 Packed Sign</a></li>
<li><a href="o_7281d5ea06a5b67a-288.html">12.6.7 Packed Align Right</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-289.html">12.7 Writing Applications with SSSE3 Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-289.html">12.7.1 Guidelines for Using SSSE3 Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-289.html">12.7.2 Checking for SSSE3 Support</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-289.html">12.8 SSE3/SSSE3 And SSE4 Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-289.html">12.8.1 Device Not Available (DNA) Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-289.html">12.8.2 Numeric Error flag and IGNNE#</a></li>
<li><a href="o_7281d5ea06a5b67a-290.html">12.8.3 Emulation</a></li>
<li><a href="o_7281d5ea06a5b67a-290.html">12.8.4 IEEE 754 Compliance of SSE4.1 Floating-Point Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-290.html">12.9 SSE4 Overview</a></li>
<li><a href="o_7281d5ea06a5b67a-291.html">12.10 SSE4.1 Instruction Set</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-291.html">12.10.1 Dword Multiply Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-291.html">12.10.2 Floating-Point Dot Product Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-292.html">12.10.3 Streaming Load Hint Instruction</a></li>
<li><a href="o_7281d5ea06a5b67a-294.html">12.10.4 Packed Blending Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-294.html">12.10.5 Packed Integer MIN/MAX Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-294.html">12.10.6 Floating-Point Round Instructions with Selectable Rounding Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-295.html">12.10.7 Insertion and Extractions from XMM Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-295.html">12.10.8 Packed Integer Format Conversions</a></li>
<li><a href="o_7281d5ea06a5b67a-296.html">12.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks</a></li>
<li><a href="o_7281d5ea06a5b67a-296.html">12.10.10 Horizontal Search</a></li>
<li><a href="o_7281d5ea06a5b67a-297.html">12.10.11 Packed Test</a></li>
<li><a href="o_7281d5ea06a5b67a-297.html">12.10.12 Packed Qword Equality Comparisons</a></li>
<li><a href="o_7281d5ea06a5b67a-297.html">12.10.13 Dword Packing With Unsigned Saturation</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-297.html">12.11 SSE4.2 Instruction Set</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-297.html">12.11.1 String and Text Processing Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-298.html">12.11.1.1 Memory Operand Alignment</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-298.html">12.11.2 Packed Comparison SIMD Integer Instruction</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-298.html">12.12 Writing Applications with SSE4 Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-298.html">12.12.1 Guidelines for Using SSE4 Extensions</a></li>
<li><a href="o_7281d5ea06a5b67a-299.html">12.12.2 Checking for SSE4.1 Support</a></li>
<li><a href="o_7281d5ea06a5b67a-299.html">12.12.3 Checking for SSE4.2 Support</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-299.html">12.13 AESNI Overview</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-299.html">12.13.1 Little-Endian Architecture and Big-Endian Specification (FIPS 197)</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-300.html">12.13.1.1 AES Data Structure in Intel 64 Architecture</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-301.html">12.13.2 AES Transformations and Functions</a></li>
<li><a href="o_7281d5ea06a5b67a-304.html">12.13.3 PCLMULQDQ</a></li>
<li><a href="o_7281d5ea06a5b67a-305.html">12.13.4 Checking for AESNI Support</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-307.html">Chapter 13 Managing State Using the XSAVE Feature Set</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-307.html">13.1 XSAVE-Supported Features and State-Component Bitmaps</a></li>
<li><a href="o_7281d5ea06a5b67a-308.html">13.2 Enumeration of CPU Support for XSAVE Instructions and XSAVE- Supported Features</a></li>
<li><a href="o_7281d5ea06a5b67a-310.html">13.3 Enabling the XSAVE Feature Set and XSAVE-Enabled Features</a></li>
<li><a href="o_7281d5ea06a5b67a-312.html">13.4 XSAVE Area</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-312.html">13.4.1 Legacy Region of an XSAVE Area</a></li>
<li><a href="o_7281d5ea06a5b67a-313.html">13.4.2 XSAVE Header</a></li>
<li><a href="o_7281d5ea06a5b67a-314.html">13.4.3 Extended Region of an XSAVE Area</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-314.html">13.5 XSAVE-Managed State</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-315.html">13.5.1 x87 State</a></li>
<li><a href="o_7281d5ea06a5b67a-315.html">13.5.2 SSE State</a></li>
<li><a href="o_7281d5ea06a5b67a-316.html">13.5.3 AVX State</a></li>
<li><a href="o_7281d5ea06a5b67a-316.html">13.5.4 MPX State</a></li>
<li><a href="o_7281d5ea06a5b67a-317.html">13.5.5 AVX-512 State</a></li>
<li><a href="o_7281d5ea06a5b67a-318.html">13.5.6 PT State</a></li>
<li><a href="o_7281d5ea06a5b67a-318.html">13.5.7 PKRU State</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-318.html">13.6 Processor Tracking of XSAVE-Managed State</a></li>
<li><a href="o_7281d5ea06a5b67a-320.html">13.7 Operation of XSAVE</a></li>
<li><a href="o_7281d5ea06a5b67a-320.html">13.8 Operation of XRSTOR</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-321.html">13.8.1 Standard Form of XRSTOR</a></li>
<li><a href="o_7281d5ea06a5b67a-321.html">13.8.2 Compacted Form of XRSTOR</a></li>
<li><a href="o_7281d5ea06a5b67a-322.html">13.8.3 XRSTOR and the Init and Modified Optimizations</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-322.html">13.9 Operation of XSAVEOPT</a></li>
<li><a href="o_7281d5ea06a5b67a-324.html">13.10 Operation of XSAVEC</a></li>
<li><a href="o_7281d5ea06a5b67a-325.html">13.11 Operation of XSAVES</a></li>
<li><a href="o_7281d5ea06a5b67a-326.html">13.12 Operation of XRSTORS</a></li>
<li><a href="o_7281d5ea06a5b67a-327.html">13.13 Memory Accesses by the XSAVE Feature Set</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-329.html">Chapter 14 Programming with AVX, FMA and AVX2</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-329.html">14.1 Intel AVX Overview</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-329.html">14.1.1 256-Bit Wide SIMD Register Support</a></li>
<li><a href="o_7281d5ea06a5b67a-330.html">14.1.2 Instruction Syntax Enhancements</a></li>
<li><a href="o_7281d5ea06a5b67a-330.html">14.1.3 VEX Prefix Instruction Encoding Support</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-331.html">14.2 Functional Overview</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-337.html">14.2.1 256-bit Floating-Point Arithmetic Processing Enhancements</a></li>
<li><a href="o_7281d5ea06a5b67a-337.html">14.2.2 256-bit Non-Arithmetic Instruction Enhancements</a></li>
<li><a href="o_7281d5ea06a5b67a-339.html">14.2.3 Arithmetic Primitives for 128-bit Vector and Scalar processing</a></li>
<li><a href="o_7281d5ea06a5b67a-341.html">14.2.4 Non-Arithmetic Primitives for 128-bit Vector and Scalar Processing</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-343.html">14.3 Detection of AVX Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-345.html">14.3.1 Detection of VEX-Encoded AES and VPCLMULQDQ</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-346.html">14.4 Half-Precision Floating-Point Conversion</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-348.html">14.4.1 Detection of F16C Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-349.html">14.5 Fused-Multiply-ADD (FMA) Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-350.html">14.5.1 FMA Instruction Operand Order and Arithmetic Behavior</a></li>
<li><a href="o_7281d5ea06a5b67a-350.html">14.5.2 Fused-Multiply-ADD (FMA) Numeric Behavior</a></li>
<li><a href="o_7281d5ea06a5b67a-353.html">14.5.3 Detection of FMA</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-354.html">14.6 Overview of Intel® Advanced Vector Extensions 2 (Intel® AVX2)</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-354.html">14.6.1 AVX2 and 256-bit Vector Integer Processing</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-354.html">14.7 Promoted Vector Integer Instructions in AVX2</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-360.html">14.7.1 Detection of AVX2</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-361.html">14.8 Accessing YMM Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-361.html">14.9 Memory alignment</a></li>
<li><a href="o_7281d5ea06a5b67a-363.html">14.10 SIMD floating-point ExCeptions</a></li>
<li><a href="o_7281d5ea06a5b67a-363.html">14.11 Emulation</a></li>
<li><a href="o_7281d5ea06a5b67a-363.html">14.12 Writing AVX floating-point exception handlers</a></li>
<li><a href="o_7281d5ea06a5b67a-364.html">14.13 General Purpose Instruction Set Enhancements</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-365.html">Chapter 15 Programming with Intel® AVX-512</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-365.html">15.1 Overview</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-365.html">15.1.1 512-Bit Wide SIMD Register Support</a></li>
<li><a href="o_7281d5ea06a5b67a-365.html">15.1.2 32 SIMD Register Support</a></li>
<li><a href="o_7281d5ea06a5b67a-365.html">15.1.3 Eight Opmask Register Support</a></li>
<li><a href="o_7281d5ea06a5b67a-366.html">15.1.4 Instruction Syntax Enhancement</a></li>
<li><a href="o_7281d5ea06a5b67a-367.html">15.1.5 EVEX Instruction Encoding Support</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-367.html">15.2 Detection of AVX-512 Foundation Instructions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-368.html">15.2.1 Additional 512-bit Instruction Extensions of the Intel AVX-512 Family</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-369.html">15.3 Detection of 512-bit Instruction Groups of Intel® AVX-512 Family</a></li>
<li><a href="o_7281d5ea06a5b67a-370.html">15.4 Detection of Intel AVX-512 Instruction Groups Operating at 256 and 128-bit Vector Lengths</a></li>
<li><a href="o_7281d5ea06a5b67a-372.html">15.5 Accessing XMM, YMM AND ZMM Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-372.html">15.6 Enhanced Vector Programming Environment Using EVEX Encoding</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-373.html">15.6.1 OPMASK Register to Predicate Vector Data Processing</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-373.html">15.6.1.1 Opmask Register K0</a></li>
<li><a href="o_7281d5ea06a5b67a-374.html">15.6.1.2 Example of Opmask Usages</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-375.html">15.6.2 OpMask Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-375.html">15.6.3 Broadcast</a></li>
<li><a href="o_7281d5ea06a5b67a-376.html">15.6.4 STATIC ROUNDING MODE AND SUPPRESS ALL EXCEPTIONS</a></li>
<li><a href="o_7281d5ea06a5b67a-377.html">15.6.5 Compressed Disp8*N Encoding</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-377.html">15.7 Memory Alignment</a></li>
<li><a href="o_7281d5ea06a5b67a-378.html">15.8 SIMD Floating-Point Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-379.html">15.9 Instruction Exception Specification</a></li>
<li><a href="o_7281d5ea06a5b67a-379.html">15.10 Emulation</a></li>
<li><a href="o_7281d5ea06a5b67a-379.html">15.11 Writing floating-point exception handlers</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-381.html">Chapter 16 Programming with Intel® Transactional Synchronization Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-381.html">16.1 Overview</a></li>
<li><a href="o_7281d5ea06a5b67a-381.html">16.2 Intel® Transactional Synchronization Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-382.html">16.2.1 HLE Software Interface</a></li>
<li><a href="o_7281d5ea06a5b67a-383.html">16.2.2 RTM Software Interface</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-383.html">16.3 Intel® TSX Application Programming Model</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-383.html">16.3.1 Detection of Transactional Synchronization Support</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-383.html">16.3.1.1 Detection of HLE Support</a></li>
<li><a href="o_7281d5ea06a5b67a-383.html">16.3.1.2 Detection of RTM Support</a></li>
<li><a href="o_7281d5ea06a5b67a-383.html">16.3.1.3 Detection of XTEST Instruction</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-384.html">16.3.2 Querying Transactional Execution Status</a></li>
<li><a href="o_7281d5ea06a5b67a-384.html">16.3.3 Requirements for HLE Locks</a></li>
<li><a href="o_7281d5ea06a5b67a-384.html">16.3.4 Transactional Nesting</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-384.html">16.3.4.1 HLE Nesting and Elision</a></li>
<li><a href="o_7281d5ea06a5b67a-385.html">16.3.4.2 RTM Nesting</a></li>
<li><a href="o_7281d5ea06a5b67a-385.html">16.3.4.3 Nesting HLE and RTM</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-385.html">16.3.5 RTM Abort Status Definition</a></li>
<li><a href="o_7281d5ea06a5b67a-385.html">16.3.6 RTM Memory Ordering</a></li>
<li><a href="o_7281d5ea06a5b67a-386.html">16.3.7 RTM-Enabled Debugger Support</a></li>
<li><a href="o_7281d5ea06a5b67a-386.html">16.3.8 Programming Considerations</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-386.html">16.3.8.1 Instruction Based Considerations</a></li>
<li><a href="o_7281d5ea06a5b67a-387.html">16.3.8.2 Runtime Considerations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-389.html">Chapter 17 Intel® Memory Protection Extensions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-389.html">17.1 Intel® Memory Protection Extensions (Intel® MPX)</a></li>
<li><a href="o_7281d5ea06a5b67a-389.html">17.2 Introduction</a></li>
<li><a href="o_7281d5ea06a5b67a-389.html">17.3 Intel MPX Programming Environment</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-390.html">17.3.1 Detection and Enumeration of Intel MPX Interfaces</a></li>
<li><a href="o_7281d5ea06a5b67a-390.html">17.3.2 Bounds Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-391.html">17.3.3 Configuration and Status Registers</a></li>
<li><a href="o_7281d5ea06a5b67a-392.html">17.3.4 Read and Write of IA32_BNDCFGS</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-392.html">17.4 Intel MPX Instruction Summary</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-393.html">17.4.1 Instruction Encoding</a></li>
<li><a href="o_7281d5ea06a5b67a-393.html">17.4.2 Usage and Examples</a></li>
<li><a href="o_7281d5ea06a5b67a-394.html">17.4.3 Loading and Storing Bounds in Memory</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-395.html">17.4.3.1 BNDLDX and BNDSTX in 64-Bit Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-396.html">17.4.3.2 BNDLDX and BNDSTX Outside 64-Bit Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-397.html">17.5 Interactions with Intel MPX</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-397.html">17.5.1 Intel MPX and Operating Modes</a></li>
<li><a href="o_7281d5ea06a5b67a-398.html">17.5.2 Intel MPX Support for Pointer Operations with Branching</a></li>
<li><a href="o_7281d5ea06a5b67a-398.html">17.5.3 CALL, RET, JMP and All Jcc</a></li>
<li><a href="o_7281d5ea06a5b67a-399.html">17.5.4 BOUND Instruction and Intel MPX</a></li>
<li><a href="o_7281d5ea06a5b67a-399.html">17.5.5 Programming Considerations</a></li>
<li><a href="o_7281d5ea06a5b67a-399.html">17.5.6 Intel MPX and System Manage Mode</a></li>
<li><a href="o_7281d5ea06a5b67a-399.html">17.5.7 Support of Intel MPX in VMCS</a></li>
<li><a href="o_7281d5ea06a5b67a-400.html">17.5.8 Support of Intel MPX in Intel TSX</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-401.html">Chapter 18 Input/Output</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-401.html">18.1 I/O Port Addressing</a></li>
<li><a href="o_7281d5ea06a5b67a-401.html">18.2 I/O Port Hardware</a></li>
<li><a href="o_7281d5ea06a5b67a-401.html">18.3 I/O Address Space</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-402.html">18.3.1 Memory-Mapped I/O</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-403.html">18.4 I/O Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-403.html">18.5 Protected-Mode I/O</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-403.html">18.5.1 I/O Privilege Level</a></li>
<li><a href="o_7281d5ea06a5b67a-404.html">18.5.2 I/O Permission Bit Map</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-405.html">18.6 Ordering I/O</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-407.html">Chapter 19 Processor Identification and Feature Determination</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-407.html">19.1 Using the CPUID Instruction</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-407.html">19.1.1 Notes on Where to Start</a></li>
<li><a href="o_7281d5ea06a5b67a-407.html">19.1.2 Identification of Earlier IA-32 Processors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-409.html">Appendix A EFLAGS Cross-Reference</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-409.html">A.1 EFLAGS and Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-413.html">Appendix B EFLAGS Condition Codes</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-413.html">B.1 Condition Codes</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-415.html">Appendix C Floating-Point Exceptions Summary</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-415.html">C.1 Overview</a></li>
<li><a href="o_7281d5ea06a5b67a-415.html">C.2 x87 FPU Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-417.html">C.3 SSE Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-419.html">C.4 SSE2 Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-421.html">C.5 SSE3 Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-421.html">C.6 SSSE3 Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-421.html">C.7 SSE4 Instructions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-423.html">Appendix D Guidelines for Writing x87 FPU Exception Handlers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-423.html">D.1 MS-DOS Compatibility Sub-mode for Handling x87 FPU Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-424.html">D.2 Implementation of the MS-DOS* Compatibility Sub-mode in the Intel486™, Pentium®, and P6 Processor Family, and Pentium® 4 Processors</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-424.html">D.2.1 MS-DOS* Compatibility Sub-mode in the Intel486™ and Pentium® Processors</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-425.html">D.2.1.1 Basic Rules: When FERR# Is Generated</a></li>
<li><a href="o_7281d5ea06a5b67a-426.html">D.2.1.2 Recommended External Hardware to Support the MS-DOS* Compatibility Sub-mode</a></li>
<li><a href="o_7281d5ea06a5b67a-427.html">D.2.1.3 No-Wait x87 FPU Instructions Can Get x87 FPU Interrupt in Window</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-429.html">D.2.2 MS-DOS* Compatibility Sub-mode in the P6 Family and Pentium® 4 Processors</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-429.html">D.3 Recommended Protocol for MS-DOS* Compatibility Handlers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-430.html">D.3.1 Floating-Point Exceptions and Their Defaults</a></li>
<li><a href="o_7281d5ea06a5b67a-430.html">D.3.2 Two Options for Handling Numeric Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-430.html">D.3.2.1 Automatic Exception Handling: Using Masked Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-431.html">D.3.2.2 Software Exception Handling</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-432.html">D.3.3 Synchronization Required for Use of x87 FPU Exception Handlers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-432.html">D.3.3.1 Exception Synchronization: What, Why, and When</a></li>
<li><a href="o_7281d5ea06a5b67a-433.html">D.3.3.2 Exception Synchronization Examples</a></li>
<li><a href="o_7281d5ea06a5b67a-433.html">D.3.3.3 Proper Exception Synchronization</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-434.html">D.3.4 x87 FPU Exception Handling Examples</a></li>
<li><a href="o_7281d5ea06a5b67a-437.html">D.3.5 Need for Storing State of IGNNE# Circuit If Using x87 FPU and SMM</a></li>
<li><a href="o_7281d5ea06a5b67a-437.html">D.3.6 Considerations When x87 FPU Shared Between Tasks</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-438.html">D.3.6.1 Speculatively Deferring x87 FPU Saves, General Overview</a></li>
<li><a href="o_7281d5ea06a5b67a-438.html">D.3.6.2 Tracking x87 FPU Ownership</a></li>
<li><a href="o_7281d5ea06a5b67a-439.html">D.3.6.3 Interaction of x87 FPU State Saves and Floating-Point Exception Association</a></li>
<li><a href="o_7281d5ea06a5b67a-440.html">D.3.6.4 Interrupt Routing From the Kernel</a></li>
<li><a href="o_7281d5ea06a5b67a-441.html">D.3.6.5 Special Considerations for Operating Systems that Support Streaming SIMD Extensions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-441.html">D.4 Differences For Handlers Using Native Mode</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-441.html">D.4.1 Origin with the Intel 286 and Intel 287, and Intel386 and Intel 387 Processors</a></li>
<li><a href="o_7281d5ea06a5b67a-442.html">D.4.2 Changes with Intel486, Pentium and Pentium Pro Processors with CR0.NE[bit 5] = 1</a></li>
<li><a href="o_7281d5ea06a5b67a-442.html">D.4.3 Considerations When x87 FPU Shared Between Tasks Using Native Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-443.html">Appendix E Guidelines for Writing SIMD Floating-Point Exception Handlers</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-443.html">E.1 Two Options for Handling Floating-Point Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-443.html">E.2 Software Exception Handling</a></li>
<li><a href="o_7281d5ea06a5b67a-445.html">E.3 Exception Synchronization</a></li>
<li><a href="o_7281d5ea06a5b67a-445.html">E.4 SIMD Floating-Point Exceptions and the IEEE Standard 754</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-445.html">E.4.1 Floating-Point Emulation</a></li>
<li><a href="o_7281d5ea06a5b67a-446.html">E.4.2 SSE/SSE2/SSE3 Response To Floating-Point Exceptions</a>
<ul>
<li><a href="o_7281d5ea06a5b67a-447.html">E.4.2.1 Numeric Exceptions</a></li>
<li><a href="o_7281d5ea06a5b67a-447.html">E.4.2.2 Results of Operations with NaN Operands or a NaN Result for SSE/SSE2/SSE3 Numeric Instructions</a></li>
<li><a href="o_7281d5ea06a5b67a-451.html">E.4.2.3 Condition Codes, Exception Flags, and Response for Masked and Unmasked Numeric Exceptions</a></li>
</ul>
</li>
<li><a href="o_7281d5ea06a5b67a-457.html">E.4.3 Example SIMD Floating-Point Emulation Implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</body>
</html>
