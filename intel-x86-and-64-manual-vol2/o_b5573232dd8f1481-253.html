<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 253</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:11px;font-family:Times;color:#000000;}
	.ft05{font-size:18px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft09{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page253-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_b5573232dd8f1481253.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">CALL‚ÄîCall Procedure</p>
<p style="position:absolute;top:47px;left:638px;white-space:nowrap" class="ft01">INSTRUCTION&#160;SET&#160;REFERENCE,&#160;A-L</p>
<p style="position:absolute;top:1103px;left:763px;white-space:nowrap" class="ft00">Vol. 2A&#160;3-125</p>
<p style="position:absolute;top:100px;left:69px;white-space:nowrap" class="ft06">On&#160;inter-privilege-level calls, the processor switches&#160;to the&#160;stack for the&#160;privilege&#160;level&#160;of the called procedure. The&#160;<br/>segment selector for the&#160;new stack segment is&#160;specified in&#160;the TSS for&#160;the currently&#160;running task.&#160;The&#160;branch&#160;to&#160;<br/>the new code segment occurs&#160;after the&#160;stack switch.&#160;(Note&#160;that when using&#160;a call&#160;gate&#160;to perform&#160;a far call&#160;to a&#160;<br/>segment&#160;at the same privilege&#160;level, no stack switch occurs.)&#160;On&#160;the new stack, the&#160;processor&#160;pushes the segment&#160;<br/>selector and&#160;stack pointer for the&#160;calling&#160;procedure‚Äôs stack,&#160;an&#160;optional set of parameters&#160;from&#160;the&#160;calling&#160;proce-<br/>dures stack, and the segment selector and instruction&#160;pointer for the calling procedure‚Äôs code segment. (A value&#160;in&#160;<br/>the call&#160;gate descriptor determines&#160;how many&#160;parameters&#160;to copy to&#160;the new stack.) Finally,&#160;the processor&#160;<br/>branches&#160;to the&#160;address of the procedure&#160;being called within the&#160;new&#160;code&#160;segment.<br/>Executing&#160;a task switch&#160;with the&#160;CALL&#160;instruction is&#160;similar to&#160;executing a&#160;call&#160;through&#160;a call&#160;gate. The target&#160;<br/>operand specifies the segment selector of the task&#160;gate for&#160;the new task activated&#160;by&#160;the&#160;switch&#160;(the offset in&#160;the&#160;<br/>target operand&#160;is ignored). The&#160;task gate in&#160;turn&#160;points&#160;to&#160;the TSS for the&#160;new task,&#160;which&#160;contains&#160;the segment&#160;<br/>selectors for&#160;the task‚Äôs&#160;code&#160;and stack&#160;segments. Note that&#160;the TSS also&#160;contains&#160;the&#160;EIP value for&#160;the next instruc-<br/>tion&#160;that was to be executed&#160;before the calling task was suspended. This instruction&#160;pointer value is loaded&#160;into&#160;the&#160;<br/>EIP register&#160;to re-start&#160;the calling task.&#160;<br/>The&#160;CALL instruction can also&#160;specify&#160;the segment selector of the&#160;TSS directly,&#160;which eliminates&#160;the&#160;indirection of&#160;<br/><a href="˛ˇ">the task gate. See Chapter&#160;7,&#160;‚ÄúTask Management,‚Äù</a>&#160;in the&#160;<a href="˛ˇ"><i>Intel¬Æ 64&#160;and&#160;IA-32&#160;Architectures Software Developer‚Äôs&#160;<br/>Manual, Volume&#160;3A</i></a>, for&#160;information on&#160;the&#160;mechanics of a&#160;task&#160;switch.<br/>When&#160;you&#160;execute at&#160;task switch with&#160;a CALL&#160;instruction,&#160;the&#160;nested task flag&#160;(NT)&#160;is set in&#160;the&#160;EFLAGS&#160;register&#160;<br/>and the&#160;new TSS‚Äôs previous&#160;task link field is&#160;loaded with&#160;the old task‚Äôs&#160;TSS&#160;selector. Code&#160;is expected&#160;to suspend&#160;<br/>this nested&#160;task by executing an&#160;IRET instruction which,&#160;because the NT flag is set, automatically uses the previous&#160;<br/>task link to return&#160;to the&#160;calling&#160;task.&#160;(See ‚ÄúTask Linkin<a href="˛ˇ">g‚Äù in&#160;Chapter 7&#160;</a>of&#160;the<a href="˛ˇ">&#160;<i>Intel¬Æ 64 and&#160;IA-32 Architectures&#160;<br/>Software Developer‚Äôs Manual, Volume&#160;3A</i></a>, for information&#160;on nested tasks.) Switching tasks with the&#160;CALL instruc-<br/>tion differs in this regard&#160;from JMP instruction. JMP does&#160;not set the&#160;NT flag and therefore does not expect an IRET&#160;<br/>instruction&#160;to suspend the&#160;task.</p>
<p style="position:absolute;top:530px;left:69px;white-space:nowrap" class="ft04"><b>Mixing&#160;16-Bit and&#160;32-Bit&#160;Calls.</b></p>
<p style="position:absolute;top:526px;left:260px;white-space:nowrap" class="ft02">&#160;When&#160;making&#160;far calls&#160;between&#160;16-bit and&#160;32-bit code segments,&#160;use a&#160;call gate. If&#160;</p>
<p style="position:absolute;top:543px;left:69px;white-space:nowrap" class="ft08">the far&#160;call is&#160;from&#160;a 32-bit code segment to&#160;a 16-bit&#160;code segment,&#160;the call&#160;should be made from the&#160;first&#160;64&#160;<br/>KBytes of&#160;the 32-bit code segment.&#160;This&#160;is because the&#160;operand-size attribute&#160;of the&#160;instruction is&#160;set&#160;to 16, so&#160;only&#160;<br/>a&#160;16-bit return&#160;address&#160;offset can&#160;be&#160;saved. Also,&#160;the call&#160;should be made using&#160;a 16-bit call gate so&#160;that&#160;16-bit&#160;<br/>values&#160;can be&#160;pushed&#160;on&#160;the stack.&#160;See&#160;<a href="˛ˇ">Chapter 21,&#160;‚ÄúMixing 16-Bit&#160;and 32-Bit Code,‚Äù</a>&#160;<a href="˛ˇ">in the&#160;<i>Intel¬Æ 64&#160;and&#160;IA-32&#160;<br/>Architectures&#160;Software Developer‚Äôs Manual, Volume&#160;3B</i>, for more i</a>nformation.</p>
<p style="position:absolute;top:637px;left:69px;white-space:nowrap" class="ft04"><b>Far&#160;Calls in&#160;Compatibility Mode.</b></p>
<p style="position:absolute;top:633px;left:271px;white-space:nowrap" class="ft02">&#160;When the processor&#160;is operating in compatibility mode, the CALL instruction can be&#160;</p>
<p style="position:absolute;top:649px;left:69px;white-space:nowrap" class="ft02">used&#160;to perform the&#160;following&#160;types&#160;of far calls:</p>
<p style="position:absolute;top:671px;left:69px;white-space:nowrap" class="ft05">‚Ä¢</p>
<p style="position:absolute;top:672px;left:95px;white-space:nowrap" class="ft02">Far call&#160;to the&#160;same&#160;privilege&#160;level,&#160;remaining in&#160;compatibility&#160;mode</p>
<p style="position:absolute;top:694px;left:69px;white-space:nowrap" class="ft05">‚Ä¢</p>
<p style="position:absolute;top:694px;left:95px;white-space:nowrap" class="ft02">Far call&#160;to the&#160;same&#160;privilege&#160;level,&#160;transitioning&#160;to 64-bit mode</p>
<p style="position:absolute;top:716px;left:69px;white-space:nowrap" class="ft05">‚Ä¢</p>
<p style="position:absolute;top:717px;left:95px;white-space:nowrap" class="ft02">Far call&#160;to a&#160;different&#160;privilege&#160;level (inter-privilege level&#160;call), transitioning&#160;to 64-bit&#160;mode</p>
<p style="position:absolute;top:741px;left:69px;white-space:nowrap" class="ft06">Note that a&#160;CALL instruction can&#160;not&#160;be&#160;used to&#160;cause a&#160;task switch in compatibility mode&#160;since&#160;task switches&#160;are&#160;<br/>not supported in&#160;IA-32e&#160;mode.<br/>In compatibility&#160;mode, the processor always uses the&#160;segment&#160;selector part of the far address&#160;to access&#160;the corre-<br/>sponding&#160;descriptor in the GDT or LDT.&#160;The descriptor type&#160;(code&#160;segment, call gate) and access rights determine&#160;<br/>the type of call operation to&#160;be&#160;performed.<br/>If&#160;the selected&#160;descriptor is&#160;for&#160;a code segment,&#160;a far&#160;call to&#160;a code segment at&#160;the same&#160;privilege level&#160;is&#160;<br/>performed.&#160;(If the selected code&#160;segment is at a different&#160;privilege&#160;level and the code&#160;segment is&#160;non-conforming,&#160;<br/>a&#160;general-protection&#160;exception is&#160;generated.) A far call&#160;to&#160;the same&#160;privilege level&#160;in compatibility mode&#160;is very&#160;<br/>similar to&#160;one carried out in&#160;protected&#160;mode.&#160;The target operand&#160;specifies an&#160;absolute far&#160;address either&#160;directly&#160;<br/>with a pointer (<i>ptr16:16</i>&#160;or&#160;<i>ptr16:32</i>) or indirectly with a memory location (<i>m16:16</i>&#160;or&#160;<i>m16:32</i>).&#160;The&#160;operand-size&#160;<br/>attribute determines the size of the offset&#160;(16 or 32 bits)&#160;in&#160;the&#160;far address. The new code segment selector and its&#160;<br/>descriptor are loaded&#160;into CS register&#160;and the&#160;offset from&#160;the instruction is loaded into the EIP register. The&#160;differ-<br/>ence&#160;is that&#160;64-bit&#160;mode&#160;may be entered. This&#160;specified&#160;by&#160;the L bit in the new code segment descriptor.<br/>Note that a&#160;64-bit call&#160;gate&#160;(described&#160;in&#160;the&#160;next paragraph) can&#160;also&#160;be&#160;used&#160;to perform&#160;a far call&#160;to a&#160;code&#160;<br/>segment at&#160;the same&#160;privilege level. However,&#160;using this mechanism requires that&#160;the target code&#160;segment&#160;<br/>descriptor have&#160;the L bit set,&#160;causing an entry&#160;to 64-bit mode.<br/>When executing an inter-privilege-level far call, the code&#160;segment for the procedure being called must&#160;be accessed&#160;<br/>through a 64-bit&#160;call gate.&#160;The&#160;segment&#160;selector specified&#160;by&#160;the target operand&#160;identifies&#160;the&#160;call gate. The target&#160;</p>
</div>
</body>
</html>
