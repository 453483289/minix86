<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
<title>Page 254</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<style type="text/css">
<!--
	p {margin: 0; padding: 0;}	.ft00{font-size:9px;font-family:Times;color:#000000;}
	.ft01{font-size:11px;font-family:Times;color:#0860a8;}
	.ft02{font-size:11px;font-family:Times;color:#000000;}
	.ft03{font-size:11px;font-family:Times;color:#000000;}
	.ft04{font-size:11px;font-family:Times;color:#000000;}
	.ft05{font-size:18px;font-family:Times;color:#000000;}
	.ft06{font-size:11px;line-height:16px;font-family:Times;color:#000000;}
	.ft07{font-size:11px;line-height:23px;font-family:Times;color:#000000;}
	.ft08{font-size:11px;line-height:24px;font-family:Times;color:#000000;}
-->
</style>
</head>
<body bgcolor="#A0A0A0" vlink="blue" link="blue">
<div id="page254-div" style="position:relative;width:918px;height:1188px;">
<img width="918" height="1188" src="o_b5573232dd8f1481254.png" alt="background image"/>
<p style="position:absolute;top:1103px;left:729px;white-space:nowrap" class="ft00">CALL—Call Procedure</p>
<p style="position:absolute;top:47px;left:68px;white-space:nowrap" class="ft01">INSTRUCTION SET REFERENCE, A-L</p>
<p style="position:absolute;top:1103px;left:68px;white-space:nowrap" class="ft00">3-126&#160;Vol. 2A</p>
<p style="position:absolute;top:100px;left:68px;white-space:nowrap" class="ft06">operand can specify the&#160;call gate&#160;segment selector either&#160;directly with a pointer (<i>ptr16:16</i>&#160;or&#160;<i>ptr16:32</i>) or indirectly&#160;<br/>with&#160;a memory location (<i>m16:16</i>&#160;or&#160;<i>m16:32</i>). The processor obtains&#160;the segment selector&#160;for&#160;the new code&#160;<br/>segment and the new instruction pointer (offset)&#160;from the 16-byte call gate&#160;descriptor. (The&#160;offset from the target&#160;<br/>operand&#160;is ignored when&#160;a&#160;call gate&#160;is used.)&#160;<br/>On&#160;inter-privilege-level calls, the processor&#160;switches to the&#160;stack for&#160;the privilege level of the called&#160;procedure. The&#160;<br/>segment selector&#160;for&#160;the new stack segment is&#160;set&#160;to NULL. The&#160;new stack pointer is&#160;specified in&#160;the&#160;TSS for the&#160;<br/>currently&#160;running task.&#160;The&#160;branch to&#160;the new code segment&#160;occurs after&#160;the stack&#160;switch. (Note&#160;that when using&#160;<br/>a call&#160;gate&#160;to perform a far call to a&#160;segment at&#160;the same&#160;privilege&#160;level,&#160;an implicit stack&#160;switch occurs&#160;as a result&#160;<br/>of&#160;entering 64-bit mode. The&#160;SS&#160;selector is unchanged,&#160;but stack segment accesses use&#160;a segment base of 0x0, the&#160;<br/>limit&#160;is&#160;ignored, and the default stack&#160;size is 64-bits. The&#160;full value of RSP is used for&#160;the&#160;offset,&#160;of which the&#160;upper&#160;<br/>32-bits are&#160;undefined.)&#160;On&#160;the&#160;new stack,&#160;the&#160;processor&#160;pushes&#160;the&#160;segment selector&#160;and stack pointer for the&#160;<br/>calling procedure’s&#160;stack and&#160;the segment selector and&#160;instruction pointer for the&#160;calling&#160;procedure’s code&#160;<br/>segment.&#160;(Parameter copy is&#160;not supported&#160;in IA-32e&#160;mode.)&#160;Finally,&#160;the processor branches to&#160;the&#160;address&#160;of the&#160;<br/>procedure&#160;being called&#160;within the&#160;new code&#160;segment.</p>
<p style="position:absolute;top:350px;left:68px;white-space:nowrap" class="ft04"><b>Near/(Far) Calls&#160;in&#160;64-bit&#160;Mode.</b></p>
<p style="position:absolute;top:346px;left:263px;white-space:nowrap" class="ft02">&#160;When&#160;the&#160;processor is operating in 64-bit mode, the CALL instruction can be&#160;used&#160;to&#160;</p>
<p style="position:absolute;top:363px;left:68px;white-space:nowrap" class="ft02">perform&#160;the following types of far&#160;calls:</p>
<p style="position:absolute;top:385px;left:68px;white-space:nowrap" class="ft05">•</p>
<p style="position:absolute;top:385px;left:93px;white-space:nowrap" class="ft02">Far call&#160;to the&#160;same&#160;privilege&#160;level, transitioning&#160;to compatibility mode</p>
<p style="position:absolute;top:407px;left:68px;white-space:nowrap" class="ft05">•</p>
<p style="position:absolute;top:408px;left:93px;white-space:nowrap" class="ft02">Far call&#160;to the&#160;same&#160;privilege&#160;level, remaining in&#160;64-bit mode</p>
<p style="position:absolute;top:430px;left:68px;white-space:nowrap" class="ft05">•</p>
<p style="position:absolute;top:430px;left:93px;white-space:nowrap" class="ft02">Far call&#160;to a&#160;different&#160;privilege&#160;level (inter-privilege level call),&#160;remaining in 64-bit&#160;mode</p>
<p style="position:absolute;top:454px;left:68px;white-space:nowrap" class="ft06">Note that in&#160;this mode&#160;the CALL&#160;instruction&#160;can not be&#160;used to&#160;cause a&#160;task switch in&#160;64-bit&#160;mode&#160;since task&#160;<br/>switches&#160;are not&#160;supported in IA-32e&#160;mode.<br/>In 64-bit mode, the processor always uses the&#160;segment selector part&#160;of&#160;the&#160;far&#160;address&#160;to access&#160;the&#160;corresponding&#160;<br/>descriptor&#160;in&#160;the GDT&#160;or LDT.&#160;The descriptor type (code segment, call gate) and access&#160;rights determine the type&#160;of&#160;<br/>call&#160;operation to&#160;be&#160;performed.<br/>If the&#160;selected&#160;descriptor&#160;is for a&#160;code&#160;segment, a&#160;far&#160;call to&#160;a code segment at&#160;the same&#160;privilege level&#160;is&#160;<br/>performed. (If&#160;the selected&#160;code segment is at a different privilege&#160;level and the code&#160;segment is non-conforming,&#160;<br/>a general-protection exception is generated.) A far call to&#160;the&#160;same privilege&#160;level in 64-bit&#160;mode is very similar&#160;to&#160;<br/>one carried&#160;out&#160;in compatibility mode. The&#160;target&#160;operand&#160;specifies&#160;an absolute&#160;far address&#160;indirectly with a&#160;<br/>memory&#160;location&#160;(<i>m16:16, m16:32</i>&#160;or&#160;<i>m16:64</i>). The form&#160;of CALL&#160;with a&#160;direct specification of absolute far&#160;<br/>address is&#160;not defined in&#160;64-bit mode.&#160;The&#160;operand-size&#160;attribute&#160;determines&#160;the size&#160;of the&#160;offset&#160;(16,&#160;32,&#160;or 64&#160;<br/>bits)&#160;in the&#160;far address. The&#160;new code segment&#160;selector&#160;and&#160;its descriptor are&#160;loaded into&#160;the CS&#160;register; the offset&#160;<br/>from&#160;the instruction is&#160;loaded into the&#160;EIP&#160;register. The&#160;new code&#160;segment may&#160;specify&#160;entry&#160;either&#160;into compati-<br/>bility or&#160;64-bit&#160;mode, based&#160;on&#160;the L bit value.<br/>A&#160;64-bit call&#160;gate&#160;(described in&#160;the&#160;next paragraph) can&#160;also be used&#160;to&#160;perform a&#160;far&#160;call&#160;to a&#160;code&#160;segment&#160;at the&#160;<br/>same privilege&#160;level.&#160;However,&#160;using&#160;this mechanism requires that&#160;the target code segment descriptor&#160;have&#160;the L&#160;<br/>bit set.<br/>When executing an inter-privilege-level far&#160;call, the code&#160;segment for the&#160;procedure being called must be accessed&#160;<br/>through a 64-bit call gate. The segment selector specified by&#160;the target operand identifies the&#160;call gate. The&#160;target&#160;<br/>operand&#160;can only specify&#160;the&#160;call gate segment selector indirectly&#160;with&#160;a memory location (<i>m16:16, m16:32</i>&#160;or&#160;<br/><i>m16:64</i>). The processor&#160;obtains&#160;the segment selector for the new code&#160;segment and&#160;the&#160;new&#160;instruction&#160;pointer&#160;<br/>(offset) from&#160;the 16-byte call gate descriptor.&#160;(The&#160;offset&#160;from&#160;the&#160;target operand&#160;is ignored when a&#160;call gate&#160;is&#160;<br/>used.)<br/>On&#160;inter-privilege-level calls, the processor&#160;switches to the&#160;stack for&#160;the privilege level of the called&#160;procedure. The&#160;<br/>segment selector&#160;for&#160;the new stack segment is&#160;set&#160;to NULL. The&#160;new stack pointer is&#160;specified in&#160;the&#160;TSS for the&#160;<br/>currently&#160;running task.&#160;The&#160;branch to&#160;the new code segment occurs&#160;after the&#160;stack switch.&#160;<br/>Note that when&#160;using&#160;a call&#160;gate to&#160;perform&#160;a far&#160;call to&#160;a segment at&#160;the&#160;same&#160;privilege&#160;level,&#160;an&#160;implicit&#160;stack&#160;<br/>switch&#160;occurs as a result of entering 64-bit mode. The&#160;SS&#160;selector is unchanged, but stack segment accesses&#160;use&#160;a&#160;<br/>segment&#160;base&#160;of 0x0,&#160;the&#160;limit is ignored,&#160;and the&#160;default stack size&#160;is 64-bits.&#160;(The full value of RSP is&#160;used&#160;for the&#160;<br/>offset.) On the new&#160;stack,&#160;the processor&#160;pushes&#160;the segment&#160;selector&#160;and&#160;stack pointer for&#160;the calling procedure’s&#160;<br/>stack and the segment selector and instruction pointer for the calling procedure’s&#160;code segment. (Parameter copy&#160;<br/>is&#160;not supported&#160;in&#160;IA-32e&#160;mode.)&#160;Finally,&#160;the&#160;processor&#160;branches&#160;to the&#160;address of the&#160;procedure being&#160;called&#160;<br/>within&#160;the new code segment.</p>
</div>
</body>
</html>
